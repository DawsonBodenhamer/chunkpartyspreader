# ➡️ Technical Specification Brief: Adorable Hamster Pets Mod

➡️ Active Session Context:

*   **Active Git Branch for this Session:** `1.20.x`
*   **Target Minecraft Version:** `1.21.1`
*   **Primary Goal for this Session:**
    ➡️ Core Project Details:

*   **Mod ID:** `adorablehamsterpets`
*   **Target Build Toolchain:** Architectury
*   **Primary API for Development:** **Architectury API.** *When implementing new features or refactoring, you must prioritize using Architectury API equivalents over loader-specific APIs wherever possible.*
*   **Core Dependencies:** GeckoLib, Fzzy Config, Mod Menu. *(Require loader-specific versions for Fabric/Forge).*
*   **Target Java Version:** Java 21 (for MC 1.21.x+), Java 17 (for MC 1.20.x)
*   **Published on:** modrinth.com

*Note: Features described in this document that are marked as incomplete (❌) or requiring implementation are generally not yet present or fully functional in the associated codebase unless explicitly stated otherwise.*

---
## 1. ➡️ Introduction & Overview

This document outlines the functional requirements and technical specifications for the "Adorable Hamster Pets" Minecraft mod. The mod introduces tameable hamster entities, new items, blocks, plants, and interactions focused around these new pets. Development is being undertaken by a solo developer who is using the Architectury toolchain to target multiple mod loaders (Fabric and Forge) simultaneously.** Your job is to provide detailed, step-by-step guidance and explanations suitable for a learner, assuming they have already provided all the code for the **Active Git Branch**.

---

## ➡️ 2. Development Environment & Dependencies

*   **Target Mod Loaders:** Fabric and Forge
*   **Primary API for Development:** **Architectury API.** *When implementing new features or refactoring, you must prioritize using Architectury API equivalents over loader-specific APIs wherever possible.*
*   **Dependencies:**
    *   **Animation Library:** GeckoLib (v4.4.9+). Requires separate versions for Fabric and Forge.
    *   **Configuration GUI:** Fzzy Config (v0.7.0+). Requires separate versions for Fabric and Forge.
        *   Its runtime dependency on Fabric is **Fabric Language Kotlin**.
        *   Its runtime dependency on Forge is **Kotlin for Forge**.
    *   **Mod List UI (Fabric):** Mod Menu (v7.2.2+). This is a Fabric-only dependency for accessing the config screen. Forge has a built-in equivalent.
    *   **Runtime Helper (Fabric):** Text Placeholder API (v2.1.1+). This is embedded into the Fabric JAR via `include()` in the build script.
*   **IDE:** IntelliJ IDEA (delegated build/run with Gradle)
*   **Build System:** Gradle 8 + Architectury Plugin (replaces Loom)
*   **Repositories:** FabricMC, GeckoLib, FzzyHmstrs, TerraformersMC, Nucleoid, Architectury, CurseMaven, Modrinth
*   **Language:** Java 17
# ➡️ Technical Specification Brief: Adorable Hamster Pets Mod

➡️ Active Session Context:

*   **Active Git Branch for this Session:** `1.20.x`
*   **Target Minecraft Version:** `1.21.1`
*   **Primary Goal for this Session:**
    ➡️ Core Project Details:

*   **Mod ID:** `adorablehamsterpets`
*   **Target Build Toolchain:** Architectury
*   **Primary API for Development:** **Architectury API.** *When implementing new features or refactoring, you must prioritize using Architectury API equivalents over loader-specific APIs wherever possible.*
*   **Core Dependencies:** GeckoLib, Fzzy Config, Mod Menu. *(Require loader-specific versions for Fabric/Forge).*
*   **Target Java Version:** Java 21 (for MC 1.21.x+), Java 17 (for MC 1.20.x)
*   **Published on:** modrinth.com

*Note: Features described in this document that are marked as incomplete (❌) or requiring implementation are generally not yet present or fully functional in the associated codebase unless explicitly stated otherwise.*

---
## 1. ➡️ Introduction & Overview

This document outlines the functional requirements and technical specifications for the "Adorable Hamster Pets" Minecraft mod. The mod introduces tameable hamster entities, new items, blocks, plants, and interactions focused around these new pets. Development is being undertaken by a solo developer who is using the Architectury toolchain to target multiple mod loaders (Fabric and Forge) simultaneously.** Your job is to provide detailed, step-by-step guidance and explanations suitable for a learner, assuming they have already provided all the code for the **Active Git Branch**.

---

## ➡️ 2. Development Environment & Dependencies

*   **Target Mod Loaders:** Fabric and Forge
*   **Primary API for Development:** **Architectury API.** *When implementing new features or refactoring, you must prioritize using Architectury API equivalents over loader-specific APIs wherever possible.*
*   **Dependencies:**
    *   **Animation Library:** GeckoLib (v4.4.9+). Requires separate versions for Fabric and Forge.
    *   **Configuration GUI:** Fzzy Config (v0.7.0+). Requires separate versions for Fabric and Forge.
        *   Its runtime dependency on Fabric is **Fabric Language Kotlin**.
        *   Its runtime dependency on Forge is **Kotlin for Forge**.
    *   **Mod List UI (Fabric):** Mod Menu (v7.2.2+). This is a Fabric-only dependency for accessing the config screen. Forge has a built-in equivalent.
    *   **Runtime Helper (Fabric):** Text Placeholder API (v2.1.1+). This is embedded into the Fabric JAR via `include()` in the build script.
*   **IDE:** IntelliJ IDEA (delegated build/run with Gradle)
*   **Build System:** Gradle 8 + Architectury Plugin (replaces Loom)
*   **Repositories:** FabricMC, GeckoLib, FzzyHmstrs, TerraformersMC, Nucleoid, Architectury, CurseMaven, Modrinth
*   **Language:** Java 17

---

## ➡️ 3. Project GitFlow Branching Model

This project utilizes the **GitFlow** branching model to manage development across multiple Minecraft versions and ensure stability. All Git operations should adhere to this structure. The primary branches are defined as follows.

### 3.1. `main` Branch (The Showroom)

*   **Purpose:** Contains the source code for the **latest stable, public release**. This branch is the "source of truth" for what players can download.
*   **Workflow:** Code is never committed directly to `main`. It only receives updates by merging from the `develop` branch when a new version is ready for release.

### 3.2. `develop` Branch (The Workshop)

*   **Purpose:** The **primary development branch** for all new features and bug fixes. This branch represents the cutting-edge, in-progress state of the *next* major or minor version of the mod.
*   **Workflow:** All feature work is done here. This branch may be unstable at times. It is the source from which backports to older versions are cherry-picked.

### 3.3. Version Branches (e.g., `1.20.x`)

*   **Purpose:** Long-running branches dedicated to supporting a specific older major version of Minecraft (e.g., 1.20).
*   **Workflow:** These branches do not receive new feature development directly. They only receive updates by **cherry-picking** completed and tested commits from the `develop` branch. They contain any necessary compatibility code to make newer features work on the older Minecraft version.

---

## ➡️ 4. Core Items & Blocks, & Entities

This section details the primary items, blocks, and entities added by the mod.

### 4.1. Items (`ModItems.java`)

*   `HAMSTER_SPAWN_EGG`: Spawns a Hamster entity. Uses a custom texture instead of the default tinting.
*   `GREEN_BEAN_SEEDS`: Plantable seeds for the Green Beans Crop. Obtained from Wild Green Bean Bushes. Item for `ModBlocks.GREEN_BEANS_CROP`.
*   `CUCUMBER_SEEDS`: Plantable seeds for the Cucumber Crop. Obtained from Wild Cucumber Bushes. Item for `ModBlocks.CUCUMBER_CROP`.
*   `SUNFLOWER_SEEDS`: Harvested from modded Sunflowers. Ingredient/Food.
*   `CUCUMBER`: Harvested from Cucumber Crop. Ingredient/Food (`ModFoodComponents.CUCUMBER`).
*   `SLICED_CUCUMBER`: Crafted from Cucumber (Recipe TBD). Used for taming/feeding hamsters (`ModFoodComponents.SLICED_CUCUMBER`).
*   `GREEN_BEANS`: Harvested from Green Beans Crop. Ingredient/Food (`ModFoodComponents.GREEN_BEANS`).
*   `STEAMED_GREEN_BEANS`: Crafted from Green Beans (Recipe TBD). Buff food for hamsters (`ModFoodComponents.STEAMED_GREEN_BEANS`).
*   `HAMSTER_FOOD_MIX`: Crafted item (Recipe TBD). Healing food for hamsters (`ModFoodComponents.HAMSTER_FOOD_MIX`). Stacks to 16.
*   `CHEESE`: Crafted item (from Milk Bucket). Player-edible (`ModFoodComponents.CHEESE`, custom eating sound), with **configurable nutrition and saturation values** (`AhpConfig.java`). The item's `FoodComponent` is generated dynamically to ensure full compatibility with mods like AppleSkin, even when config values are changed at runtime. Also used to summon a tamed hamster to the player's shoulder via direct interaction with the hamster while holding an item from the config-defined `shoulderMountFoods` list (`CheeseItem` and `HamsterEntity.interactMob` handle logic).
*   `HAMSTER_GUIDE_BOOK`: An introductory guide book powered by the Patchouli API. Given on first join and craftable. The item itself (`PatchouliGuideBookItem`) opens the book GUI, which is defined entirely by data files.
*   Item Group: All relevant items added to `ItemGroups.INGREDIENTS`.

### 4.2. Blocks (`ModBlocks.java`)

*   `GREEN_BEANS_CROP`: Custom crop block grown from `GREEN_BEAN_SEEDS`. Settings based on `Blocks.WHEAT`. Has 4 growth stages (age 0-3). (Class: `GreenBeansCropBlock`). ✅
*   `CUCUMBER_CROP`: Custom crop block grown from `CUCUMBER_SEEDS`. Settings based on `Blocks.WHEAT`. Has 4 growth stages (age 0-3). (Class: `CucumberCropBlock`). ✅
*   `SUNFLOWER_BLOCK`: Custom tall flower block mimicking vanilla Sunflower appearance but with added harvesting mechanics. Settings based on `Blocks.SUNFLOWER`. (Class: `SunflowerBlock`). ✅
*   `WILD_GREEN_BEAN_BUSH`: Block that generates in the world and drops `GREEN_BEAN_SEEDS`. Settings based on `Blocks.SWEET_BERRY_BUSH`. (Class: `WildGreenBeanBushBlock`). ✅
*   `WILD_CUCUMBER_BUSH`: Block that generates in the world and drops `CUCUMBER_SEEDS`. Settings based on `Blocks.SWEET_BERRY_BUSH`. (Class: `WildCucumberBushBlock`). ✅

### 4.3 Core Entity: `HamsterEntity.java`

The central entity of the mod is the `HamsterEntity`, extending `TameableEntity`, with distinct behaviors based on its tamed status and environment.

---

## ➡️ 5. Functional Requirements: World Interaction & Generation

This section covers interactions with the game world, including blocks and generation.

### 5.1. Sunflower Seed Harvesting

*   Requirement: Allow harvesting `SUNFLOWER_SEEDS` from a custom Sunflower block.
*   Implementation: Uses a custom `SunflowerBlock` (extends `TallFlowerBlock`), visually identical to vanilla Sunflowers.
*   Harvesting:
    *   Right-clicking seeded Sunflower drops 1-3 `SUNFLOWER_SEEDS`.
    *   Texture changes to "seedless" state.
    *   Block relies on random ticks to regrow seeds.
*   Conversion: To ensure compatibility with recipes from other mods that may require the vanilla sunflower, a simple shapeless crafting recipe is provided. Placing one custom `SunflowerBlock` item into a crafting grid yields one vanilla `minecraft:sunflower`.
*   Regrowth: When seedless, the top half block has random ticks. Regrows seeds (`HAS_SEEDS=true`) based on random chance. **Regrowth speed is configurable via `worldGen.sunflowerRegrowthModifier` in `/config/adorablehamsterpets/main.toml`.**
*   Placement/Generation:
    *   The mod replaces vanilla sunflowers with its harvestable version in any biome configured to have them. This system is designed for high compatibility with other mods. It first checks if a biome is on the user's allowed list (via `sunflowerBiomes` and `sunflowerBiomeTags` in the config) and then confirms that the biome was intended to spawn vanilla sunflowers in the first place. This prevents sunflowers from appearing in incorrect locations like oceans or caves. Player-placed `SunflowerBlock` starts seedless and requires random ticks to become harvestable. Bonemeal only affects initial growth to two blocks high, not seed regrowth.
    *   **Fabric:** Generation is handled by an Architectury `BiomeModifications` call in `ModWorldGenerationImpl.java`, which removes the vanilla feature and adds the custom one.
    *   **NeoForge:** Generation is handled by a data-driven biome modifier (`add_sunflowers.json`) that triggers a custom Java class (`ConfigurableFeatureModifier.java`) to perform the replacement.
*   Current Status: Functionality implemented and working as intended. ✅

### 5.2. World Gen: Wild Green Bean Bush

*   Requirement: Add a wild plant (`WILD_GREEN_BEAN_BUSH`) for obtaining `GREEN_BEAN_SEEDS`.
*   Appearance/Block: Implemented using `WildGreenBeanBushBlock` extending `PlantBlock`. Uses `minecraft:block/cross` model parent with textures `wild_green_bean_bush_seeded.png` and `wild_green_bean_bush_seedless.png`. Uses a `BooleanProperty` (`SEEDED`) for state.
*   Harvesting: Right-click when `SEEDED=true` yields 1-2 `GREEN_BEAN_SEEDS`, plays sound, and sets state to `SEEDED=false`. Breaking yields 1-2 seeds.
*   Regrowth: When `SEEDED=false`, block has random ticks. Regrows seeds (`SEEDED=true`) based on light level (>=9) and random chance. **Regrowth speed is configurable via `worldGen.wildBushRegrowthModifier` in `/config/adorablehamsterpets/main.toml`.**
*   Farming: Seeds grow `GREEN_BEANS_CROP` on farmland.
*   Spawning Biomes:
    *   Generation is fully configurable via `/config/adorablehamsterpets/main.toml`, allowing for high compatibility with modded biomes. The system uses a combination of specific biome IDs (`greenBeanBushBiomes`), vanilla tags (`greenBeanBushTags`), convention tags (`greenBeanBushConventionTags`), and an exclusion list (`greenBeanBushExclusions`) to provide fine-grained control over where the bushes can spawn. The default settings are tuned to place them in temperate and wet biomes. **Generation rarity is configurable via `worldGenMisc.greenBeanBushSettings.wildGreenBeanBushRarity`.** Naturally generated bushes start seeded.
    *   **Fabric:** Generation is handled by an Architectury `BiomeModifications` call in `ModWorldGenerationImpl.java`.
    *   **NeoForge:** Generation is handled by a data-driven biome modifier (`add_wild_green_bean_bush.json`) that triggers a custom Java class (`ConfigurableFeatureModifier.java`).
*   Current Status: Implemented and working as intended. ✅

### 5.3. World Gen: Wild Cucumber Bush

*   Requirement: Add a wild plant (`WILD_CUCUMBER_BUSH`) for obtaining `CUCUMBER_SEEDS`.
*   Appearance/Block: Implemented using `WildCucumberBushBlock` extending `PlantBlock`. Uses `minecraft:block/cross` model parent with textures `wild_cucumber_bush_seeded.png` and `wild_cucumber_bush_seedless.png`. Uses a `BooleanProperty` (`SEEDED`) for state.
*   Harvesting: Right-click when `SEEDED=true` yields 1-2 `CUCUMBER_SEEDS`, plays sound, and sets state to `SEEDED=false`. Breaking yields 1-2 seeds.
*   Regrowth: When `SEEDED=false`, block has random ticks. Regrows seeds (`SEEDED=true`) based on light level (>=9) and random chance. **Regrowth speed is configurable via `worldGen.wildBushRegrowthModifier` in `/config/adorablehamsterpets/main.toml`.**
*   Farming: Seeds grow `CUCUMBER_CROP` on farmland.
*   Spawning Biomes:
    *   Generation is fully configurable via `/config/adorablehamsterpets/main.toml`, allowing for high compatibility with modded biomes. The system uses a combination of specific biome IDs (`cucumberBushBiomes`), vanilla tags (`cucumberBushTags`), convention tags (`cucumberBushConventionTags`), and an exclusion list (`cucumberBushExclusions`) to provide fine-grained control. The default settings are tuned to place them in a wide variety of temperate, hot, and dry biomes. **Generation rarity is configurable via `worldGenMisc.cucumberBushSettings.wildCucumberBushRarity`.** Naturally generated bushes start seeded.
    *   **Fabric:** Generation is handled by an Architectury `BiomeModifications` call in `ModWorldGenerationImpl.java`.
    *   **NeoForge:** Generation is handled by a data-driven biome modifier (`add_wild_cucumber_bush.json`) that triggers a custom Java class (`ConfigurableFeatureModifier.java`).
*   Current Status: Implemented and working as intended. ✅

---
## ➡️ 6. User Interface & Experience

This section details UI elements and features enhancing player experience.

### 6.1. Custom Item Tooltips

*   Requirement: All mod-added items should have custom tooltips providing subtle hints about their usage.
*   Implementation: Achieved by overriding the `appendTooltip` method within anonymous inner classes during item registration (`ModItems.java`, `ModBlocks.java`) or within custom item classes (`CheeseItem.java`).
*   Formatting: Uses `Text.translatable` for localization and `.formatted(Formatting.COLOR)` for styling, adhering to the defined color palette:
    *   `dark_green` (`§2`) for positive effects/uses.
    *   `dark_aqua` (`§3`) for section titles/key mechanics (in book).
    *   `gold` (`§6`) for special interactions/items.
    *   `dark_red` (`§4`) for warnings (in book).
    *   `red` for warnings (in game).
    *   `dark_purple` (`§5`) for emphasis on specific items/actions (in book).
    *   `gray` (`§7`) / `dark_gray` (`§8`) for descriptive text/flavor/secondary hints.
    *   `aqua` (`§b`) for crafting/planting hints (in tooltips).
    *   `yellow` (`§e`) for neutral info/hints (in tooltips).
*   Content: Hints guide players subtly towards item purpose and mod mechanics, incorporating dry/sarcastic humor, without explicitly revealing mechanics. Entry-point items hint at their resource chain's ultimate purpose. `super.appendTooltip` is called last to preserve default info.
*   Current Status: Implemented and working as intended. ✅

### 6.2. The “Hamster Tips” Guide Book

*   **Requirement:** Provide players with a comprehensive, in-game guide book using the Patchouli API. The book is given once on first join, can be re-crafted, and features a custom GUI and dynamic text wrapping. An automatic upgrade system ensures backwards compatibility for players with older, pre-Patchouli versions of the book. (it used to be implemented with a vanilla book and custom NBT in older versions)
*   **Item ID:** `adorablehamsterpets:hamster_guide_book`
*   **Implementation:**
    *   **Core Technology:** The guide book is implemented using the Patchouli mod. All content, including categories, entries, and page layouts, is defined in data-driven JSON files located in the `resources/data/patchouli_books/` and `resources/assets/adorablehamsterpets/patchouli_books/` directories.
    *   **Item Definition:** The physical item is `PatchouliGuideBookItem.java`, a custom class extending `Item`. Its primary server-side function is to open the corresponding Patchouli book GUI for the player using `PatchouliAPI.get().openBookGUI()`.
    *   **Initial Distribution (First Join):** A "flag" advancement (`technical/has_received_initial_guidebook.json`) tracks delivery. If a player joins without this advancement and the feature is enabled in the config, the `technical/receive_guide_book.json` advancement is triggered, which in turn runs the `technical/give_guide_book.mcfunction`. This function gives the player the book item with the correct `patchouli:book` component (`/give @s adorablehamsterpets:hamster_guide_book[patchouli:book="..."] 1`).
    *   **Re-Crafting:** The re-crafting recipe is defined in a static data file (`data/adorablehamsterpets/recipes/hamster_guide_book_from_crafting.json`). It is a shapeless recipe (1 Vanilla Book + 1 Sliced Cucumber) that directly crafts the `hamster_guide_book` item with the necessary `patchouli:book` component, making it immediately functional.
    *   **Custom GUI & Text Wrapping:**
        *   The book uses a custom GUI texture, `hamster_guide_book_ui.png`, defined in `data/patchouli_books/hamster_tips_guide_book/book.json`.
        *   A mixin for Patchouli's `GuiBookLanding` class (`GuiBookLandingMixin`) replaces the header rendering logic specifically for this mod's book. This allows for a custom-positioned, multi-line wrapped subtitle that would otherwise be truncated.
        *   A dynamic pagination system is implemented to handle entry titles that are too long to comfortably fit on one line. A mixin for `GuiBookEntryList` (`GuiBookEntryListMixin`) replaces the button layout logic. It first simulates the layout by calculating the required height for each entry's wrapped title, determines the correct page breaks, and sets the total number of pages (`maxSpreads`) dynamically. A corresponding mixin for `GuiButtonEntry` (`GuiButtonEntryMixin`) then handles rendering the multi-line text within each button's calculated height.
    *   **Backwards Compatibility (Book Upgrade System):**
        *   To ensure a seamless transition for players from older mod versions, an automatic upgrade system is in place. The central logic is in `AdorableHamsterPets.replaceOldBooksInInventory()`.
        *   This method identifies outdated guide books by checking for the `hamster_guide_book` item's presence *without* the `patchouli:book` component.
        *   The upgrade is triggered in two scenarios: on player join (to scan the player's inventory) and whenever a player opens any container (via `ServerPlayerEntityMixin`), which scans the container's inventory. This ensures all old books are replaced with the new, functional Patchouli version.
*   **Texture/Model:** The item uses the `hamster_guide_book.json` model. The in-game book GUI uses a custom texture specified in `book.json`.
*   Current Status: Implemented and working as intended. ✅

### Section 6.3. Custom Advancements Tree

*   **Requirement:** Implement a custom advancement tab and tree to guide players through mod features.
*   **Implementation:**
    *   **Tab Root (`husbandry/root.json`):**
        *   Title: "The Hamster Life", Icon: `adorablehamsterpets:hamster_spawn_egg`.
        *   Trigger: `minecraft:location` (unlocks immediately for all players).
    *   **Advancement Tree Structure:**
        *   **Main Taming Path:** Root -> "Seed Money" (Get Cucumber Seeds) -> "The Bait" (Craft Sliced Cucumber) -> "A Furry Shadow" (Tame Hamster).
        *   **Post-Taming Branches (from "A Furry Shadow"):**
            *   -> "Shoulder Surfer" (Shoulder Hamster with Cheese) -> "The Hamster Yeet™" (Throw Hamster, Icon: Creeper Head).
            *   -> "Petal Pusher" (Apply Pink Petals to Hamster, Icon: `minecraft:pink_petals`).
        *   **Sunflower/Food Branch (from Root):** Root -> "Sunflower Hoarder" (Get Sunflower Seeds) -> "Pocket Snacks" (Craft Food Mix) -> "A Trustworthy Face" (Cheek Pouch Unlocked via Food Mix).
            *   **From "A Trustworthy Face":** -> "Pocket Paramedic" (Hamster auto-feeds from pouch, Icon: `adorablehamsterpets:hamster_food_mix`).
            *   **From "A Trustworthy Face":** -> "Chipmunk Aspirations" (Fill all cheek pouch slots, Icon: `minecraft:bundle`).
        *   **Green Bean Branch (from Root):** Root -> "Green Bean Gardener" (Get Green Bean Seeds) -> "Steamy Greens" (Obtain Steamed Beans) -> "Supercharged Squeaker" (Feed Steamed Beans).
        *   **Shoulder Pet Utility Branch (from "Shoulder Surfer"):**
            *   -> "Nose for Treasure" (Shoulder hamster alerts to diamonds, Icon: `minecraft:diamond`).
            *   -> "Impending Doom Squeak" (Shoulder hamster alerts to Creeper, Icon: `minecraft:gunpowder`).
    *   **Custom Criteria:**
        *   `adorablehamsterpets:hamster_on_shoulder`: Triggers "Shoulder Surfer".
        *   `adorablehamsterpets:hamster_thrown`: Triggers "The Hamster Yeet™".
        *   `adorablehamsterpets:fed_hamster_steamed_beans`: Triggers "Supercharged Squeaker".
        *   `adorablehamsterpets:cheek_pouch_unlocked`: Triggers "A Trustworthy Face".
        *   `adorablehamsterpets:first_join_guidebook_check`: Used for initial guidebook delivery.
        *   `adorablehamsterpets:applied_pink_petal`: Triggers "Petal Pusher".
        *   `adorablehamsterpets:hamster_auto_fed`: Triggers "Pocket Paramedic".
        *   `adorablehamsterpets:hamster_diamond_alert_triggered`: Triggers "Nose for Treasure".
        *   `adorablehamsterpets:hamster_creeper_alert_triggered`: Triggers "Impending Doom Squeak".
        *   `adorablehamsterpets:hamster_pouch_filled`: Triggers "Chipmunk Aspirations".
    *   **Technical Advancements (Hidden):**
        *   `technical/sweet_potato_named.json`: Triggers on player interacting with a hamster using a name tag. Rewards function `technical/check_sweet_potato_name`.
        *   `technical/sweet_potato_easter_egg_triggered_flag.json`: Granted by `technical/sweet_potato_effects` to make easter egg effects one-time per player.
    *   **Display:** Advancements use custom titles/descriptions aligned with brand voice. "Goal" and "Challenge" frames used for key milestones. Newly added advancements are "task" frame.
    *   **Crafting Recipe Advancement (`technical/crafted_guide_book.json`):** Triggers on crafting the guide book, plays particle effects via a function reward.
*   Current Status: Implemented and working as intended. ✅

### Section 6.4. Client-Side Announcement & Update Notification System

*   **Requirement:** Implement a robust, client-side system to deliver dynamic announcements and update notifications to players without requiring a mod update. The system must feature a highly configurable HUD icon, use Patchouli as a front-end for listing notifications, and display content in a custom Markdown-rendering GUI with clear, accessible controls.
*   **Implementation:**
    *   **Core Logic (`AnnouncementManager.java`):** A central singleton class manages the entire system. It uses lazy initialization to ensure it's robust against mod loading order variations, particularly in large modpacks.
    *   **Remote Content Fetching:** On game launch, the `AnnouncementManager` asynchronously fetches a `manifest.json` file from a public GitHub repository. This manifest contains a list of all announcements, update notes, and the latest mod version string. The system uses HTTP `ETag` and `If-Modified-Since` headers to avoid re-downloading the manifest if it hasn't changed. The manifest and individual message markdown files are cached locally.
        *   **Hypothetical Example `manifest.json` (Hosted on GitHub, but also cached locally):**
            ```json
            {
              "latest_version": "3.3.2",
              "messages": [
                {
                  "id": "whats-new-3.3.2",
                  "title": "What's New in v3.3.2? (The Server Sanity Patch)",
                  "kind": "update",
                  "semver": "3.3.2",
                  "published": "2025-10-07T18:00:00Z",
                  "markdown": "messages/v3.3.2-whats-new.md",
                  "mandatory": true
                },
                {
                  "id": "compat-data-progress-1",
                  "title": "Compatibility Data Progress!",
                  "kind": "announcement",
                  "semver": "3.3.1",
                  "published": "2025-10-07T19:00:00Z",
                  "markdown": "messages/compat-data-progress.md",
                  "mandatory": false
                }
              ]
            }
            ```
    *   **State Management (`ClientAnnouncementState.java`):** A local `announcements.json` file is stored in the config directory to persist player state. It tracks which messages have been seen, which update notifications have been snoozed (and until when), and whether notifications have been disabled for the current game session.
        *   **Hypothetical Example `announcements.json` (Local user file):**
            ```json
            {
              "seen_ids": [
                "whats-new-3.3.1"
              ],
              "snoozed_ids": {
                "whats-new-3.3.2": "2025-10-12T20:30:00Z"
              },
              "last_acknowledged_update": "3.3.1",
              "opt_out_announcements": false,
              "manifest_etag": "\"gh-etag-string-12345abcde\"",
              "manifest_last_modified": "Tue, 07 Oct 2025 19:05:00 GMT"
            }
            ```
    *   **Notification Icon:**
        *   A 16x16 bell icon (`announcement_bell_icon.png`) appears when there are pending notifications. Its state is managed by a central `AnnouncementIconAnimator` singleton, which uses a spring-damper physics simulation for smooth, resolution-independent transitions of its position, scale, and rotation.
        *   **HUD Icon (`AnnouncementHudRenderer.java`):** A non-interactive version of the icon is rendered on the main game HUD. Its position is configurable via presets (e.g., `TOP_LEFT`) and fine-tuned with X/Y offsets in the config.
        *   **Widget Icon (`AnnouncementIconWidget.java`):** An interactive, clickable version of the icon is dynamically injected onto GUI screens (Title Screen, Inventory) via `AHPClientScreenEvents` and a `TitleScreenMixin`. It intelligently positions itself relative to the parent GUI.
    *   **Patchouli Integration (`PatchouliIntegration.java`):**
        *   **Virtual Content Injection:** A `BookContentsBuilderMixin` dynamically injects two virtual categories ("Announcements" and "Update Notes") and their corresponding virtual entries into the Hamster Tips guide book at runtime. This content does not exist in the mod's JAR files.
        *   **GUI Hijacking:** A `BookContentsMixin` intercepts clicks on these virtual entries. Instead of opening a standard Patchouli page, it opens the custom `AnnouncementScreen`.
        *   **UI Polish:** Mixins for `GuiBookLanding` and `GuiBookIndex` are used to center the category icons and hide virtual entries from the main index, respectively. A mixin for `GuiButtonBookMarkRead` was updated to allow Patchouli's "Mark All as Read" button to correctly process and dismiss all announcement notifications.
    *   **Custom GUI (`AnnouncementScreen.java`):**
        *   A custom screen with a unique background (`announcement_ui.png`) is used to display the content of announcements. The entire UI (including the buttons) dynamically scales to fit any window size, preventing elements from being cut off.
        *   It features a `MarkdownRenderer` that parses and displays formatted text, including headings, bold/italic, lists, code spans, links, and dividers.
        *   The action buttons are organized into two rows. It includes buttons for "Mark As Read" (with Shift-click to mark all), "Disable All" (which toggles the icon visibility configs), "Snooze (Session)" (which disables notifications until the next game launch), and other contextual actions like "See Changelog".
    *   **Configuration (`AhpConfig.java`):** The system is highly configurable. It includes a master "Enable Announcements" toggle, which synchronizes with the individual `enableHudIcon` and `enableWidgetIcon` settings for ease of use, and also a `ConfigAction` button to "Mark All as Read" for convenience.
*   Current Status: Implemented and working as intended. ✅

---
## ➡️ 7. Functional Requirements: `HamsterEntity` & Interactions

This section covers the specific behaviors and interactions involving the `HamsterEntity`.

### 7.1. Wild Spawning, Biome Variants, and Breeding Inheritance

*   Requirement: Hamsters should spawn naturally in a wide variety of Overworld biomes, with their color variants tied to biome characteristics. Spawn eggs and chunk generation should also respect biome variants. The entire spawning system is driven by user-configurable lists of biome IDs and tags for maximum mod compatibility. Baby hamsters inherit variants based on their parents. Hamsters avoid pathing into hazards.
*   **Biome Spawning Restrictions (Config-Driven):**
    *   The decision to add hamster spawns to a biome is now entirely controlled by the config file (`adorablehamsterpets.json5`).
    *   The logic, handled in `ModEntitySpawns.java`, checks if a biome matches the user-defined lists in the following order:
        1.  **Inclusion:** The biome is in the `includeBiomes` list OR matches a tag in the `spawnBiomeTags` (vanilla) or `spawnBiomeConventionTags` (`c:` tags) lists.
        2.  **Exclusion:** If it's a candidate for inclusion, a final check is performed against the `excludeBiomes` list, which acts as a final veto.
    *   This system allows for broad compatibility with modded biomes out-of-the-box while giving users precise control to add or remove specific biomes.
    *   **Fabric:** Spawns are added by calling Architectury's `BiomeModifications.addProperties` from the main Fabric initializer. This uses a predicate (`shouldSpawnInBiome`) that checks against the config lists.
    *   **NeoForge:** Spawns are added via a data-driven biome modifier (`data/adorablehamsterpets/neoforge/biome_modifier/hamster_spawns.json`). This modifier triggers a custom Java class (`ConfigurableHamsterSpawnModifier`) that reads the config for spawn weight/count and allowed biomes, and uses a similar common `shouldSpawnInBiomeNeoForge` method to apply spawns to the correct biomes.
    *   Biomes like Oceans and Rivers are generally excluded unless a specific variant rule applies.
    *   Spawn weight and max group size are configurable at runtime via the config file. Min group size is hardcoded to 1.
*   **Block Spawning Restrictions (`ModEntitySpawns.java`):**
    *   Valid ground blocks are checked via `AnimalEntity.isValidNaturalSpawn` OR by checking a custom `VALID_SPAWN_BLOCKS` set. The default light level check (`> 8`) is purposefully removed to allow cave spawns.
*   **Biome-Specific Variant Assignment (`HamsterEntity.determineVariantForBiome`):**
    *   The logic for assigning a color variant has been rewritten to be "hamster-centric," prioritizing rare variants first to ensure correct distribution. It uses a hierarchical series of checks combining specific biome keys, vanilla tags (`minecraft:`), and convention tags (`c:`/`forge:`) via the mod's own "union tags" (`ModBiomeTags`).
    *   **Blue:** Spawns in icy biomes (e.g., `c:is_icy` which covers Ice Spikes and Frozen Peaks, Terralith's `glacial_chasm`, `mirage_isles`, `moonlight_valley` and Biomes O' Plenty's `enchanted_garden`). In vanilla Ice Spikes, there is a 70% chance for a Blue variant and a 30% chance for a White variant.
    *   **Lavender:** Spawns in magical/mushroom/lavender-themed biomes (e.g., `c:is_magical`, `c:is_mushroom`, vanilla Cherry Grove, Terralith's `sakura_valley`, and Biomes O' Plenty's `fungi_forest` and `mystic_grove`), excluding any biomes that are already classified as Blue-spawning biomes.
    *   **White:** Spawns in a wide range of snowy/cold biomes (e.g., `c:is_cold`, `c:is_snowy`, Terralith's `snowy_maple_forest`, `wintry_forest`, `alpine_grove`, `siberian_grove`), but is explicitly excluded from higher-priority Blue/Lavender biomes and certain non-snowy cold biomes like `minecraft:taiga` or `minecraft:stony_shore` to maintain thematic consistency.
    *   **Gray (Light/Dark):** Spawns in mountainous or sparse biomes (e.g., `c:is_mountain`, `c:is_sparse_vegetation`, Terralith's `cliffs`, `stony_spires`), but is excluded from any biome that qualifies for the higher-priority colors above, as well as Badlands, Jungles, and Savannas since those have sparse vegetation but do not fit the "gray" color theme.
    *   **Black:** Spawns in wet or cave-like biomes (e.g., `c:is_wet`, `c:is_cave`, vanilla Deep Dark). It is excluded from higher-priority biomes and specific "wet" biomes that don't fit the theme, like Jungles and Beaches. Wild-spawned black hamsters are restricted to their solid base color; overlays for this variant can only be obtained through breeding.
    *   **Cream:** Spawns in sandy biomes (e.g., `c:is_sandy`, Terralith's `ancient_sands`, `sandstone_valley`, and Biomes O' Plenty's `wasteland`) and Birch Forests. It is excluded from all higher-priority biomes and sandy areas within Badlands as well as Terralith's `gravel_beach`.
    *   **Chocolate:** Spawns in most generic forest and dense vegetation biomes (e.g., `c:is_forest`, `c:is_dense_vegetation`, Terralith's `cloud_forest`, and Biomes O' Plenty's `redwood_forest`) that do not meet the criteria for any of the more specific variants listed above.
    *   **Orange (Default):** Acts as the fallback variant for common biomes like Plains and Savannas that do not fit into any of the more specialized categories.
    *   A random sub-variant (overlays from 1-8) is selected from the determined pool, except for black, which do not spawn with any of the white overlays.
*   **Breeding Inheritance (`HamsterEntity.createChild`):**
    *   Baby's base color is randomly chosen from one parent's base color.
    *   **Overlay Inheritance Rules:**
        *   If both parents have an overlay (e.g., `LAVENDER_OVERLAY3`, `LIGHT_GRAY_OVERLAY6`), the baby *must* have an overlay. The baby's overlay will be randomly chosen from the available overlays for its base color, *excluding* the specific overlay patterns its parents have, if possible. If excluding parent overlays leaves no other overlay options for the baby's base color, it will pick any available overlay for its base color (potentially matching a parent's overlay type).
        *   If one or neither parent has an overlay, the baby can randomly have any of the eligible overlays for its base color (excluding parent overlays if applicable) or no overlay (i.e., just the base color).
        *   The `WHITE` base color never gets overlays.
*   **Behavior (Wild):** Skittish, flees unless player crouched + holding `SLICED_CUCUMBER`, `CHEESE`, or `STEAMED_GREEN_BEANS`. Sleeps during the day, wanders at night. Wild hamsters use `anim_hamster_wild_settle_sleep` before their main sleep loop.
*   **Daytime Sleep (Wild):** Implemented via `HamsterSleepGoal`.
*   **Pink Petal Overlays (Interaction Update):**
    *   Players right-click a tamed, owned hamster with `Items.PINK_PETALS` to cycle through three cosmetic pink petal overlay types (1, 2, 3, then back to 1). Each application consumes one petal item and plays sound/particles.
    *   Players right-click a tamed, owned hamster with `Items.SHEARS` to remove any active pink petal overlay. This plays a shear sound, spawns removal particles, damages the shears, and drops one `Items.PINK_PETALS` item.
    *   This state (`PINK_PETAL_TYPE` DataTracker: 0 for none, 1-3 for active) is saved to NBT and shoulder data, and rendered as a third layer.
*   **Hazard Avoidance:** Hamsters have pathfinding penalties set in their constructor (`HamsterEntity.java`) to make them avoid pathing into `PathNodeType.WATER` (penalty -1.0F), `PathNodeType.DANGER_FIRE` (penalty 16.0F), and `PathNodeType.DAMAGE_FIRE` (penalty 16.0F).
*   **Ravager & Spider Fleeing:** Ravagers and Spiders are naturally afraid of hamsters (both wild and tamed) and will flee from them. This behavior is implemented via mixins on `RavagerEntity` and `SpiderEntity` that add a `FleeEntityGoal`. The goal's activation is controlled by a `Predicate` that checks the live config values (`core.mobInteractions.enableRavagerFlee` and `core.mobInteractions.enableSpiderFlee`), allowing the feature to be toggled at runtime without a world reload.
*   Current Status: Implemented and working as intended. ✅

### 7.2. State Management & Data Synchronization

*   **Requirement:** Implement a robust and conflict-resistant method for synchronizing the hamster's various states between the server and client, while maintaining backward compatibility with existing worlds.
*   **Implementation:**
    *   **Core System:** The hamster's state is managed using Minecraft's `DataTracker` system, which automatically synchronizes data from the server to all clients observing the entity.
    *   **Bitmasking for Boolean States:**
        *   To drastically reduce the risk of `DataTracker` ID collisions with other mods, what was originally seventeen individual boolean states have since been consolidated into a single `TrackedData<Integer>` field named `HAMSTER_FLAGS`.
        *   Each boolean state is assigned a unique bitmask constant (e.g., `SITTING_FLAG = 1 << 1`, `KNOCKED_OUT_FLAG = 1 << 8`).
        *   Private helper methods (`getHamsterFlag(int mask)` and `setHamsterFlag(int mask, boolean value)`) handle the bitwise operations (`&`, `|`, `~`) to read and write individual flags within the integer.
        *   All public-facing getter and setter methods (e.g., `isSitting()`, `setKnockedOut(boolean)`) were preserved in the refactor. They call the internal helper methods, making the bitmask implementation transparent to other parts of the codebase, such as AI goals.
    *   **NBT Compatibility:**
        *   The `writeCustomDataToNbt` and `readCustomDataFromNbt` methods serve as a compatibility layer.
        *   When saving, the game reads the state from the bitmask but writes individual boolean tags (e.g., `"Sitting": true`) to the NBT data.
        *   When loading, the game reads these individual boolean tags and correctly sets the corresponding bits in the `HAMSTER_FLAGS` integer. This ensures full backward compatibility with worlds saved before the refactor.
    *   **Shoulder Data Persistence:** The `HamsterShoulderData` record, used for storing the state of a shoulder-mounted hamster, was updated to store the packed `hamsterFlags` integer, ensuring all states are correctly preserved during mounting and dismounting.
*   Current Status: Implemented and working as intended. ✅

### 7.3. Taming and Basic Interaction

*   Requirement: Players can tame wild hamsters using items defined in the `tamingFoods` config list (defaults to `SLICED_CUCUMBER`, with built-in compatibility for Cultural Delights' `cut_cucumber`. Cultural Delights is an addon to the popular farming mod called “Farmers Delight”). Tamed hamsters should sit reliably, have a persistent "personality" that dictates their sitting animation, and not rotate their heads unnaturally when sitting, sleeping, or knocked out.
*   Taming Outcome: Sets player's UUID as owner. The hamster's maximum health attribute is updated to the value specified by `tamedMaxHealth` in the config, and its current health is set to this new maximum. Taming chance (1 in X) is configurable via `tamingChanceDenominator` in config.
*   Behavior (Tamed):
    *   Follows owner.
    *   Sits/stays on owner right-click.
*   Sit/Stay Mode (Tamed):
    *   Trigger: Right-click toggle by owner.
    *   State Management: Vanilla `SitGoal` is used. The custom `IS_SITTING` DataTracker is synchronized with the vanilla sitting pose via an override of `HamsterEntity.setInSittingPose(boolean)`. This ensures animations correctly reflect the actual sitting state, even when interrupted by defensive AI goals.
    *   **Animation Personality:**
        *   Upon first spawn, each hamster is assigned a permanent "personality ID" (1, 2, or 3) stored in a `DataTracker`. This ID is saved to NBT and persists across sessions and shoulder mounting.
        *   This ID determines which sitting animation (`anim_hamster_sitting_pose1`, `_pose2`, or `_pose3`) the hamster uses whenever it is in a sitting state.
    *   **Cleaning Behavior:**
        *   While sitting (and not in a sleep phase), hamsters have a random chance to begin a cleaning animation (`anim_hamster_cleaning`).
        *   The frequency of this behavior is **configurable via `cleaningChanceDenominator` in config.**
        *   When cleaning, a continuous, looping scratch sound is played, managed by a custom `TickableSoundInstance`.
    *   Physics: Stationary.
    *   Teleportation: Does not teleport while sitting.
*   **Look Behavior Control:**
    *   Custom AI goals `HamsterLookAtEntityGoal` and `HamsterLookAroundGoal` (extending vanilla counterparts) are implemented.
    *   These custom goals prevent the hamster from turning its head if it `isSitting()` (which includes player-commanded sit, wild sleep, or being knocked out) or `isSleeping()` (which covers the tamed hamster's advanced sleep phases via `DozingPhase` checks within the `isSitting()` effective logic for look goals).
*   Current Status: Implemented and working as intended. ✅

### 7.4. Feeding, Healing, and Breeding

*   Requirement: Tamed hamsters can be fed specific items for healing, buffs, or breeding, with all valid items being defined by the user in the config file for maximum compatibility.
*   **Healing & Breeding Foods (Config-Driven):**
    *   The items that can be used for healing or breeding are defined by the `standardFoods` list in `/config/adorablehamsterpets/main.toml`. This list accepts item IDs (e.g., `minecraft:apple`) and item tags (e.g., `#minecraft:fishes`).
    *   By default, this list includes `adorablehamsterpets:hamster_food_mix`, `sunflower_seeds`, `green_beans`, `cucumber`, `green_bean_seeds`, `cucumber_seeds`, and the vanilla items `minecraft:apple`, `carrot`, `melon_slice`, `sweet_berries`, `beetroot`, `wheat`, and `wheat_seeds`. It also includes built-in compatibility for several items from Farmer's Delight and its addons.
    *   Feeding an item from this list to a hamster with less than maximum health will heal it. The **healing amount is configurable via `foodHealing.standardFoodHealing`**.
    *   Feeding an item from this list when the hamster is at full health and its breeding cooldown is zero will trigger "love mode" (`customLoveTimer` set, `IS_IN_LOVE` tracker set). The **breeding cooldown is configurable via `cooldowns.breedingCooldownTicks`**.
*   **Buff Food (Config-Driven):** Items defined in the `buffFoods` config list provide status effect buffs instead of healing or breeding (See section 7.9).
*   **Implementation:** The logic is managed by the `ModItemTags` class, which parses the config lists at startup into high-performance caches. The `HamsterEntity.interactMob` and `HamsterEntity.tryFeedingAsTamed` methods call helper methods like `ModItemTags.isStandardFood()` to perform near-instantaneous checks against these caches.
*   Current Status: Implemented and working as intended. ✅

### 7.5. Repeat Food Refusal

*   **Requirement:** Prevent feeding the same standard food item twice consecutively, with a configurable list of exceptions. The refusal animation should adapt to the hamster's movement.
*   **Tracking:** The `HamsterEntity` tracks the last food `ItemStack` it consumed.
*   **Refusal Trigger:** Attempting to feed the exact same non-exempt food item again immediately.
*   **Refusal Behavior:** The feed attempt fails. The hamster plays a headshake animation.
    *   If the hamster is stationary, it plays `anim_hamster_stationary_headshake`.
    *   If the hamster is moving, it plays `anim_hamster_moving_headshake`, allowing it to continue walking while refusing the food.
*   **Exceptions (Configurable):** The list of items that are exempt from this refusal mechanic is defined in the `itemTags.repeatableFoods` list in the config file. By default, this includes `adorablehamsterpets:hamster_food_mix` and `adorablehamsterpets:steamed_green_beans`.
*   Current Status: Implemented and working as intended. ✅

### 7.6. Melee Attack (Tamed)

*   Requirement: Tamed hamsters should defend their owner and attack targets designated by the owner, mimicking vanilla wolf behavior but synchronized with custom animations/sounds. They should not attack other pets owned by the same player. Additionally, spawn a small particle effect at the point of impact during the attack animation.
*   **Trigger:**
    *   Owner is attacked by a `LivingEntity`.
    *   Owner attacks a `LivingEntity` (that is not another of their own pets).
*   **Implementation (Core Attack Logic):**
    *   Utilize vanilla AI targeting goals: `TrackOwnerAttackerGoal`, `AttackWithOwnerGoal`, `RevengeGoal`.
    *   Custom goal `HamsterMeleeAttackGoal` extends `MeleeAttackGoal`.
        *   Overrides `attack()` to check `canAttack(target)` before proceeding.
        *   If `canAttack` is true, it plays a random custom sound (`ModSounds.HAMSTER_ATTACK_SOUNDS`), triggers the `anim_hamster_attack` animation, and calls `mob.tryAttack(target)`.
        *   **Damage Application:** Instead of `mob.tryAttack(target)`, the goal manually creates a `DamageSource` using `hamster.getDamageSources().mobAttack(hamster)`. This explicitly sets the hamster as the attacker, ensuring that any resulting death messages correctly attribute the kill to the hamster by its name, rather than its owner.
        *   **Cooldown Handling (Cross-Platform):** To ensure the 35-tick attack animation is not interrupted, the goal's internal `cooldown` field must be set. Access is handled with a **Mixin Accessor** (`MeleeAttackGoalAccessor`). The `resetCooldown()` and `start()` methods in `HamsterMeleeAttackGoal` use this accessor to set the cooldown, making the logic compatible with both Fabric and NeoForge.
    *   Overrides `getMaxCooldown()` to return **35 ticks**.
    *   `HamsterEntity` overrides `isInAttackRange(LivingEntity)` to use a smaller horizontal expansion (**0.8 blocks**).
*   Damage: Base attack damage set via `EntityAttributes.GENERIC_ATTACK_DAMAGE`. **Damage value configurable via `hamsterBehavior.meleeDamage` in `/config/adorablehamsterpets/main.toml`.**
*   **Implementation (Particle Effect):**
    *   Uses Geckolib's Particle Keyframe system.
    *   An `attack_poof` effect in `anim_hamster_attack` is handled on the client by `HamsterRenderer` to spawn `ParticleTypes.WHITE_SMOKE` at the `left_foot` bone's world position.
*   **Entity Exclusions:**
    *   `HamsterEntity.canAttackWithOwner` and `HamsterEntity.setTarget` are overridden to prevent attacking other pets owned by the same player, Creepers, and Armor Stands.
*   Current Status: Implemented and working as intended. ✅

### 7.7. Cheek Pouch Inventory

*   Requirement: Tamed hamsters possess a 6-slot inventory. Access is conditional and item restrictions are fully customizable.
*   **Locking Mechanic (Config-Driven):**
    *   By default (`core.requireFoodMixToUnlockCheeks = true`), pouches are locked. They unlock permanently when the hamster is fed an item specified in the `itemTags.pouchUnlockFoods` config list (defaults to `adorablehamsterpets:hamster_food_mix`).
    *   An advancement ("A Trustworthy Face") triggers on unlock. Sound (`ENTITY_PLAYER_LEVELUP`) and particles (of the unlock item) play upon unlock.
    *   The config option can disable this lock entirely.
*   **Access & GUI:**
    *   **Interaction:** Crouch + Right-click a tamed hamster to open.
    *   **Screen Registration (Cross-Platform):** The `HamsterInventoryScreen` is registered using a loader-aware approach.
        *   **Fabric:** Uses `MenuRegistry.registerScreenFactory` in the main client initializer.
        *   **NeoForge:** Uses the native `RegisterMenuScreensEvent` to register the screen factory.
*   Visual Feedback (Geckolib `cheek` Bones):
    *   Empty: `*_deflated` bones visible, `*_inflated` hidden.
    *   Not Empty: `*_inflated` bones visible, `*_deflated` hidden.
*   **Item Restrictions (Config-Driven):**
    *   The item restriction system is managed by the central `ModItemTags` manager.
    *   The logic is implemented in `HamsterEntity.isItemDisallowed(ItemStack)` and follows a clear hierarchy:
        1.  **High-Priority Allow:** If an item is in the `itemTags.pouchRestrictions.pouchAllowedItems` config list, it is **always allowed**, overriding all other rules.
        2.  **Explicit Disallow:** If an item is in the `itemTags.pouchRestrictions.pouchDisallowedItems` or `itemTags.pouchRestrictions.pouchDisallowedTags` lists, it is disallowed.
        3.  **General Rule:** By default, any item that is a `BlockItem` or a `SpawnEggItem` is disallowed.
    *   These rules are enforced by `HamsterSlot`, `HamsterInventoryScreenHandler.quickMove()`, and `HamsterEntity.isValid()`.
*   **Item Ejection:** Periodically checks for and ejects any items that have become disallowed due to a config change.
*   Functionality: Stores allowed items, enables auto-consumption, drops contents on death.
*   Current Status: Implemented and working as intended. ✅

### 7.8. Shoulder Riding Mechanics

*   **Requirement:** Allow players to mount up to three tamed hamsters simultaneously (one on each shoulder, one on the head) using items defined in the config. The system must ensure all pet data persists, render the primary animated GeckoLib model for visual consistency, and provide a configurable dismount order.
*   **Mounting:** Mounting is triggered by one of two configurable methods:
    *   **Item-Based:** Right-clicking a tamed hamster with an item from the `shoulderMountFoods` config list (`adorablehamsterpets:cheese` by default). Item consumption can be disabled via the `consumeShoulderMountItem` config setting.
    *   **Keybind-Based:** Pressing the "Force-Mount Hamster" keybind while looking at a tamed hamster. This feature is disabled by default and can be enabled via `enableShoulderMountKeybind` in the config.
    *   In both cases, the hamster is mounted to the next available slot in the sequence: Right Shoulder -> Left Shoulder -> Head.
*   **Dismounting (Sequential):** The standard dismount action removes one hamster at a time. This is highly configurable via the "Dismount Settings" in the config menu, allowing the player to choose their preferred `Dismount Button` (`SNEAK_KEY` or a `CUSTOM_KEYBIND`), `Button-Press Behavior` (`SINGLE_PRESS` or `DOUBLE_TAP`), and `Dismount Order` (`LIFO` or `FIFO`).
    *   **LIFO (Last-In, First-Out):** Removes the most recently added hamster.
    *   **FIFO (First-In, First-Out):** Removes the hamster that has been mounted the longest.
*   **Data Persistence on Death:** If a player dies with hamsters mounted, all pets are safely dismounted at the player's death location instead of being deleted.
*   **Implementation (Data Attachment):** To ensure high mod compatibility and avoid `DataTracker` ID collisions, the system uses a single `TrackedData<NbtCompound>` on the `PlayerEntity` (via `PlayerEntityMixin`). This compound acts as a container, storing separate NBT data for each of the three `ShoulderLocation` slots (`RIGHT_SHOULDER`, `LEFT_SHOULDER`, `HEAD`).
*   **Data Persistence (Order):** A transient, server-side `ArrayDeque<ShoulderLocation>` on the `PlayerEntity` tracks the mount order. This queue is saved to and loaded from the player's NBT data to ensure the LIFO/FIFO order is persistent across game sessions.
*   **Visuals (Rendering):**
    *   **Model:** The system renders the primary, animated GeckoLib model for all shoulder pets, but because a `FeatureRenderer` cannot render a `GeoModel` directly, this is achieved by creating a client-only "dummy" `HamsterEntity` for each slot. This dummy entity is never added to the world but serves as a data-driven "ViewModel" whose sole purpose is to hold the necessary state to drive the GeckoLib animation controller.
    *   **Renderer:** A specialized `ShoulderHamsterRenderer` (extending the main `HamsterRenderer`) is used to bypass logic that is irrelevant for a cosmetic shoulder pet, such as snow-offset adjustments. The main `HamsterShoulderFeatureRenderer` manages the three dummy entities, applying data from NBT and feeding them pre-calculated animation states from a per-player state machine before rendering them in the correct positions on the player's model.
    *   **Fresh Animations Compatibility:** The renderer anchors the pets directly to the player's animated body parts (`rightArm`, `leftArm`, `head`). This allows them to move and bounce realistically with the player's movements when using animation-overhaul resource packs like Fresh Moves.
*   **Physics-Lite Simulation (Bounce & Squish/Stretch):**
    *   A client-side physics simulation, managed by the `ClientShoulderHamsterData` class, is ticked for each shoulder pet to create a dynamic, reactive bouncing and deformation effect.
    *   The simulation is driven by the player's vertical velocity and acceleration. Inside `ClientShoulderHamsterData#clientTick`, it calculates inertial, spring, damping, and gravity forces to update a `PhysicsState` object for each hamster.
    *   This results in a vertical offset (`hamsterOffsetY`) that makes the hamster float up during a fall and bounce upon landing. The simulation includes a hard collision floor (`hamsterOffsetY = Math.max(0, hamsterOffsetY)`), preventing the hamster from clipping down into the player model.
    *   The hamster's model also visually deforms. Its vertical scale (`hamsterScaleY`) is calculated based on player acceleration and a separate `impactSquashFactor`, creating a squash-and-stretch effect that makes jumps and landings feel more impactful.
    *   The final interpolated offset and scale are applied to the dummy `HamsterEntity`'s `dynamicScaleY` field and then used within `HamsterShoulderFeatureRenderer` and `HamsterModel` respectively.
*   **Visual Adjustment (Age, Textures, Cheeks):** The renderer correctly applies all visual data from the deserialized NBT, including baby scaling, variant textures, overlays, and cheek pouch inflation, ensuring the shoulder pet is a perfect visual match to its in-world counterpart.
*   **Audio:** The mounting sound is dynamic. It uses the `getDynamicItemSound()` helper to play a sound appropriate for the item used for mounting (e.g., a "squish" for cheese, a "clink" for a diamond). The standard dismount sound remains.
*   Current Status: Implemented and working as intended.✅

### 7.9. Steamed Green Beans Buff

*   Requirement: Feeding specific items grants temporary buffs.
*   Trigger: Feeding an item from the `buffFoods` list (defined in `AhpConfig.java`) to a tamed hamster (owner only). Defaults to `STEAMED_GREEN_BEANS`.
*   Effects: Applies Speed, Strength, Absorption, and Regeneration. **Duration and amplifier levels for each effect are individually configurable via the `greenBeanBuffs` settings group in `/config/adorablehamsterpets/main.toml`.**
*   Cooldown: Prevents re-buffing for a set time after a buff food is consumed. **Cooldown duration is configurable via `cooldowns.steamedGreenBeansBuffCooldown` in `/config/adorablehamsterpets/main.toml`.** The cooldown persists across sessions.
*   Visuals: Emits `ENTITY_EFFECT` particles while the buff is active.
*   Current Status: Implemented and working as intended. ✅

### 7.10. Auto-Feeding from Inventory

*   Requirement: Tamed hamsters automatically consume specific healing foods from their Cheek Pouch Inventory when injured, after a short delay.
*   **Configurability:** The specific items that can be auto-consumed are defined by the user in the `itemTags.autoHealFoods` list in the config. By default, this is limited to `adorablehamsterpets:hamster_food_mix`.
*   Trigger: Server-side tick (`HamsterEntity.tick()`), tamed, `health < maxHealth`, not already in an auto-eat cycle (`!isAutoEating()`, `!isConsideringAutoEat()`), main auto-eat cooldown (`autoEatCooldownTicks`) is 0, not thrown/KO'd, and an eligible healing food is available in an unlocked cheek pouch.
*   **Process:**
    1.  **Consideration Phase:** If eligible, sets `IS_CONSIDERING_AUTO_EAT` to true and starts `preAutoEatDelayTicks` (40 ticks / 2 seconds). No item is consumed yet.
    2.  **Eating Phase:** After `preAutoEatDelayTicks` finishes (and food is still available):
        *   Sets `isAutoEating` flag to true (for potential animation).
        *   Starts `autoEatProgressTicks` (60 ticks / 3 seconds).
        *   Plays `SoundEvents.ENTITY_GENERIC_EAT`.
        *   Spawns `ItemStackParticleEffect` of the consumed food item.
        *   Consumes one eligible food item from inventory.
    3.  **Healing & Cooldown Phase:** When `autoEatProgressTicks` finishes:
        *   Applies healing (**healing amount configurable via `foodHealing.hamsterFoodMixHealing` in `/config/adorablehamsterpets/main.toml`**).
        *   Sets `autoEatCooldownTicks` to 60 ticks (3 seconds).
        *   Resets `isAutoEating` flag.
        *   Triggers `ModCriteria.HAMSTER_AUTO_FED` advancement.
*   State/Cooldown:
    *   `IS_CONSIDERING_AUTO_EAT` (DataTracker<Boolean>): Tracks if in pre-eat delay.
    *   `preAutoEatDelayTicks` (int): Timer for the pre-eat delay. (Does not persist NBT/Shoulder for simplicity).
    *   `isAutoEating` (boolean flag): Tracks if currently in the eating animation/process.
    *   `autoEatProgressTicks` (int): Timer for the eating duration.
    *   `autoEatCooldownTicks` (int): Main cooldown after healing. Persists via NBT and `HamsterShoulderData`.
*   Current Status: Implemented and working as intended. ✅

### 7.11. Creeper Detection (Shoulder)

*   Requirement: While on shoulder, alert player to nearby Creepers targeting them.
*   Implementation: Server-side logic in `PlayerEntityMixin` tick.
*   Detection: Every `CHECK_INTERVAL_TICKS` (20), checks if nearby Creepers have the player as target. **Detection radius configurable via `features.shoulderCreeperDetectionRadius` in `/config/adorablehamsterpets/main.toml`.** **Feature can be disabled via `features.enableShoulderCreeperDetection` in `/config/adorablehamsterpets/main.toml`.**
*   Alert: If detected and sound cooldown is 0, plays random sound (`HAMSTER_CREEPER_DETECT_SOUNDS`) and sends action bar message.
*   Frequency: Sound/message triggers only if `creeperSoundCooldownTicks` is 0. Cooldown then set to hardcoded random duration (100-160 ticks).
*   Current Status: Implemented and working as intended. ✅

### 7.12. Diamond Ore Detection (Shoulder)

*   Requirement: While on shoulder, alert player to nearby Diamond Ore, prioritizing exposed ores.
*   Implementation: Server-side logic in `PlayerEntityMixin` tick.
*   Detection: Every `CHECK_INTERVAL_TICKS` (20), scans for diamond ore blocks. **Detection radius configurable via `features.shoulderDiamondDetectionRadius` in `/config/adorablehamsterpets/main.toml`.** **Feature can be disabled via `features.enableShoulderDiamondDetection` in `/config/adorablehamsterpets/main.toml`.**
*   Alert: If detected and sound cooldown is 0, plays random sound (`HAMSTER_DIAMOND_SNIFF_SOUNDS`) and sends action bar message.
*   Frequency: Sound/message triggers only if `diamondSoundCooldownTicks` is 0. Cooldown then set to hardcoded random duration (140-200 ticks).
*   Current Status: Implemented and working as intended. ✅

### 7.13. Throwing Attack (From Shoulder)

*   Requirement: Allow player to "throw" their tamed hamster from their shoulder as a projectile attack.
*   Trigger: Pressing the dedicated "Throw Hamster" keybind ('G'). Conditions checked client-side (`AdorableHamsterPetsClient.handleClientTick`).
*   Action: Client sends `ThrowHamsterPayload`.
*   Server receives, verifies, checks config toggle `features.enableHamsterThrowing`, creates hamster instance, (loading data including `throwCooldownEndTick`), checks cooldown/baby status, removes shoulder data, sets state (`isThrown=true`, `throwTicks=0`, `interactionCooldown=10`), sets hamster's throw cooldown, calculates position/velocity based on buff state (configurable via `hamsterThrowVelocity` and `hamsterThrowVelocityBuffed`), spawns hamster, sends sound packets (`StartHamsterFlightSoundPayload`, `StartHamsterThrowSoundPayload`). Client plays `TickableSoundInstance`s. Server spawns trail particles.
*   **Animation (Flying):** `HamsterEntity.registerControllers` plays `anim_hamster_flying` (looping) while `isThrown()` is true.
*   Impact: Server-side raycasting in `HamsterEntity.tick()`.
    *   On collision (block or entity):
        *   Sets `isThrown=false`.
        *   Sets `IS_KNOCKED_OUT = true`.
        *   Plays impact sound (`ModSounds.HAMSTER_IMPACT`).
        *   Spawns `ParticleTypes.POOF` particles.
        *   **Triggers `anim_hamster_crash`** server-side using `triggerAnimOnServer("mainController", "crash")`.
        *   **Block Collision:** The hamster is placed in the air adjacent to the impacted block face, allowing vanilla gravity to handle the fall naturally. This prevents clipping.
        *   **Entity Collision:** A safe landing spot is found near the impacted entity using the `findSafeSpawnPosition` algorithm.
        *   If entity hit: Deals damage using a `mobAttack` damage source (crediting the hamster, not the owner) and applies Nausea (excluding Armor Stands).
*   **Friendly-Fire Prevention:** A global damage handler (`AHPCommonEvents.onLivingHurt`) intercepts all damage events on the server. It uses a generic owner-resolution algorithm to determine the owner of both the attacker and the victim. This algorithm checks for `TameableEntity`, `AbstractHorseEntity`, and `Ownable` interfaces, and includes reflection-based fallbacks for mod compatibility. If both entities are pets and share the same owner, the damage event is cancelled, preventing thrown hamsters from harming other same-owner pets (and vice-versa).
*   Post-Impact (Knocked Out State):
    *   AI: `HamsterEntity.isSitting()` returns `true` when `IS_KNOCKED_OUT` is true, preventing movement.
    *   **Animation:** `HamsterEntity.registerControllers` detects `isKnockedOut()` and plays `anim_hamster_ko` (looping). The `crash` animation plays once on trigger, then the controller defaults to the `ko` loop.
    *   Client-side flight/throw sounds stop/fade out.
*   Exiting Knocked Out State:
    *   Next player interaction (`interactMob`) while `isKnockedOut()` is true:
        *   Sets `IS_KNOCKED_OUT = false`.
        *   Plays random wake-up sound (`ModSounds.HAMSTER_WAKE_UP_SOUNDS`).
        *   **Triggers `anim_hamster_wakeup`** server-side using `triggerAnimOnServer("mainController", "wakeup")`.
        *   Interaction is consumed.
        *   Normal AI/animation resumes after `wakeup` finishes.
*   Visuals: Uses layered textures (`HamsterRenderer`, `HamsterOverlayLayer`). The server spawns a `GUST` particle trail; its spawn position is calculated based on the hamster's previous tick's position and offset backwards along its velocity vector to correct for client-server desync.  there is a delay before the particled there is a delay before particles appear to ensure they do not block the player’s vision. This delay is shorter if the hamster is buffed, since it will be traveling away from the player faster. (3 ticks vs 5).
*   Inventory, age, buff status, and all other relevant data: Preserved via `HamsterShoulderData`.
*   Keybind Handling: Dedicated keybind ('G').
*   Current Status: Implemented and working as intended. ✅

### 7.14. Model Visuals
#### 7.14.1. Animation Logic & State Machine

This section details the animation states and transitions for the `HamsterEntity`, managed primarily through Geckolib's `AnimationController` in `HamsterEntity.registerControllers` and procedural updates in `HamsterEntity.tick()` and `HamsterModel.setCustomAnimations()`.

*   **I. Shoulder Pet Animation System:**
    *   **Architecture:** Shoulder-mounted hamsters are rendered using a client-side "dummy" `HamsterEntity` for each of the three slots (shoulders and head). Their animation state is managed by a per-player `ClientShoulderHamsterData` object, which is ticked safely on the main client thread.
    *   **Dynamic State Machine (`ShoulderHamsterState`):**
        *   By default (`enableDynamicShoulderAnimations = true`), each shoulder pet independently cycles through three states: `STANDING`, `SITTING`, and `LAYING_DOWN`.
        *   The duration of each state is randomized based on configurable min/max values (`shoulderMinStateSeconds`, `shoulderMaxStateSeconds`).
        *   If dynamic animations are disabled, pets will adopt the single pose defined by the `forcedShoulderState` config option.
    *   **Reactive Animations:**
        *   If `forceLayDownOnSprint` is true, all shoulder pets will be forced into their "laying down" animation when the player sprints, as if holding on. A randomized micro-delay prevents them from reacting in perfect unison.
        *   If `forceLayDownOnWalk` is true, the same behavior applies to any player movement, not just sprinting.
    *   **Location-Specific Poses:** The "laying down" state uses one of three unique animations (`..._laying_down_head`, `..._laying_down_right_shoulder`, `..._laying_down_left_shoulder`) chosen based on the pet's location, ensuring a natural fit on the player model.


*   **II. Core Animation System Overview:**
    *   **Core Locomotion & States (Looping):**
        *   `anim_hamster_idle1`, `anim_hamster_idle2`: Two distinct default animations that are randomly selected when the hamster is stationary. Includes subtle breathing and ear/tail movements.
            *   *Visuals:* Subtle breathing, ear twitches, and tail flicks.
        *   `anim_hamster_walking`: Plays when moving slowly.
            *   *Visuals:* A bouncy walk cycle with gentle body/ear/tail/head rotation. The hamster's legs are essentially just small cubes under its body which rotate, so the main thing that makes it look like walking is the bouncing.
        *   `anim_hamster_running`: Plays when moving at a medium speed.
            *   *Visuals:* A faster-paced run with more pronounced rotation and a faster tempo.
        *   `anim_hamster_sprinting`: Plays at the hamster's highest speeds, used during the "zoomies" buff and when fleeing during a heist.
            *   *Visuals:* A rapid, more energetic run with even more pronounced rotation, faster tempo and a higher bounce on each step.
        *   `anim_hamster_sitting_pose1`, `_pose2`, `_pose3`: One of three poses chosen based on the hamster's persistent "personality ID". Plays when sitting and not in a deeper sleep or shoulder-pet state.
            *   *Visuals:* One is a standard upright sit, another is a more relaxed, slightly slouched sit, and the other is a prim, alert sit with paws held closer together.
        *   `anim_hamster_cleaning`: Short, looping animation that plays randomly while sitting. Frequency is configurable.
            *   *Visuals:* The hamster brings its paw to its face and makes rapid grooming motions. This involves repetitive head/hand rotation and cheek wiggleing.
        *   `anim_hamster_begging`: A multi-purpose animation used when the hamster is tempted by food and also when it is celebrating after leading the player to diamond ore.
            *   *Visuals:* The hamster stands up on its hind legs, holds its front paws together, and bounces eagerly. Very bouncy and even scales the hamster vertically during the bounces make it cuter.
        *   `anim_hamster_flying`: Plays continuously while `isThrown()` is true.
            *   *Visuals:* The hamster's body rotates constantly around it’s forward axis, with legs splayed out and ears folded back, mimicking a "superhero" flight pose with the “sprial” rotation of an american football when thrown.
        *   `anim_hamster_ko`: Plays when `isKnockedOut()` is true.
            *   *Visuals:* The hamster lies flat on its stomach with its legs splayed out. This is a close replica of the “flying” animation, but dramatically squished vertically and with very subtle breathing instead of rotation. Swirling "dizzy" particles are rendered above its head via particle keyframes.
        *   `anim_hamster_diamond_taunt`: Plays when the hamster is taunting the player during the item stealing chase.
            *   *Visuals:* The hamster sticks its butt up in the air and front legs out forward like a dog playing with a toy, holding the stolen item in it’s “mouth”, and performs a playful, jiggly taunt wiggle loop while cocking its head back and forth.
        *   `anim_hamster_seeking_diamond`: Plays while the hamster is actively pathfinding towards a target ore.
            *   *Visuals:* A determined, sniffing bounce-walk, with the hamster's nose close to the ground. This is slower than the default `anim_hamster_walking`, and also involves a horizontal scaling of the hamster’s body with each sniff. Sniffing dust particles are rendered near the nose bone to mimic dust kicked up by the sniffing.
        *   `anim_hamster_wants_to_seek_diamond`: Plays when the hamster is primed to seek ore but its path is blocked.
            *   *Visuals:* The hamster stands in place, repeatedly looking up and down from the ground under its face to the path in front, with the occasional “clear the head” headshake.
        *   `anim_hamster_sulking`: Plays when the hamster has "mistakenly" led the player to gold ore instead of diamond.
            *   *Visuals:* The hamster lays flat on its stomach with legs splayed out to the sides, ears flattened in a posture of dramatic disappointment.
    *   **Shoulder & Sleep Animations (Looping & Non-Looping):**
        *   `anim_hamster_drifting_off_pose1`, `_pose2`, `_pose3`: A 90-second non-looping animation for tamed hamsters entering sleep.
            *   *Visuals:* The hamster's blinking becomes slower and its head gradually droops as it succumbs to sleepiness.
        *   `anim_hamster_sleep_pose1`, `_pose2`, `_pose3`: Looping sleep poses for both wild and tamed hamsters.
            *   *Visuals:*  One of the poses has the hasmter lying on its side, the other is lying on the stomach, and the other is lying on the back, all with random ear/leg twitches included.
        *   `anim_hamster_shoulder_laying_down_head`, `..._right_shoulder`, `..._left_shoulder`: Three unique looping animations used for the "laying down" state of a shoulder-mounted pet, chosen based on its location.
            *   *Visuals:* Each animation shows the hamster lying down in a relaxed pose that conforms to the shape of the player's head or shoulder. For the shoulder poses, the legs on the outer side hang down off the side of the player’s shoulder.
    *   **Triggerable Animations (Single Play):**
        *   `anim_hamster_attack`: Melee attack.
            *   *Visuals:* A quick lunge up and forward, accompanied by a 360-degree spin round-house kick with one of its hind legs, and then “bounces” off the target and returns to starting t-pose. Renders particles at the foot bone for dramatic effect.
        *   `anim_hamster_crash`: Impact after being thrown.
            *   *Visuals:* A dramatic, bouncy crash that transitions from the “flying” animation to the “ko” animation.
        *   `anim_hamster_wakeup`: Transition from KO to normal.
            *   *Visuals:* The hamster un-squishes by quickly inflating back to it’s normal vertical thickness; very bouncy.
        *   `anim_hamster_stationary_headshake`: Plays for food refusal when the hamster is not moving.
            *   *Visuals:* The hamster stands in place and shakes its head from side to side as if to say “no.”
        *   `anim_hamster_moving_headshake`: Plays for food refusal when the hamster is moving.
            *   *Visuals:* Same as the standing head shake, but the rest of the body is key framed for the walking animation.
        *   `anim_hamster_diamond_pounce`: Plays when the hamster lunges to steal an item.
            *   *Visuals:* A quick, targeted leap towards the item's location; the final frame perfectly matches the starting position of the “taunting” animation.
        *   `anim_hamster_celebrate_chase`: Plays when the player successfully retrieves a stolen item.
            *   *Visuals:*  A shorter, non looping version of the “begging” animation which just includes two bounces and then a slight head wiggle as the hamster returns to the default t-pose.
        *   `anim_hamster_sulk`: A short, non-looping transition into the `anim_hamster_sulking` state.
            *   *Visuals:*  A transition from the default t-pose to the “sulking” loop. Involves a dramatic bounce and forward flop.
        *   `anim_hamster_sit_settle_sleep1`, `_settle_sleep2`, `_settle_sleep3`: 1s transitions into deep sleep for tamed hamsters.
            *   *Visuals:*  Transitions from all the “drifting off” poses into their associated sleep poses. Very bouncy and jiggly as the hamster sort of “flops” into position.
        *   `anim_hamster_stand_settle_sleep1`, `_settle_sleep2`, `_settle_sleep3`: 1s transitions into deep sleep for wild hamsters.
            *   *Visuals:*  Same as the `sit_settle_sleep` animations, but transitioning from the default t-pose into the three sleeping poses.
    *   **Procedural Visuals & Sounds:**
        *   **Footstep Sounds:** A hybrid system is used. When the hamster is on-screen, footstep sounds are triggered by keyframes in the walk/run animations for perfect sync. When off-screen, a fallback movement-based sound is used to ensure the player can always hear them. Volume is adjusted for loud surfaces like gravel.
        *   **Cleaning Sound:** A continuous, looping scratch sound plays for the duration of the cleaning animation, managed by a `TickableSoundInstance`.
        *   **Baby Scaling:** Managed in `HamsterModel.setCustomAnimations()`.
        *   **Cheek Pouch Inflation:** Managed in `HamsterModel.setCustomAnimations()`.
        *   **Pink Petal Overlay:** Rendered by `HamsterPinkPetalOverlayLayer`.
        *   **Snow Y-Offset:** A client-side adjustment in `HamsterRenderer` smoothly lifts the model when on snow layers to prevent visual clipping.

*   **III. Advanced Sleep Behavior:**
    The "Path to Slumber" and "Quick Sleep Onset" behaviors are implemented as described below.

    *   **A. Overview of Animations for Sleep (as listed in section I).**

    *   **B. Tamed Hamster Exclusive: "The Path to Slumber" Sequence**
        Implemented using the `DozingPhase` enum (`NONE, QUIESCENT_SITTING, DRIFTING_OFF, SETTLING_INTO_SLUMBER, DEEP_SLEEP`), associated timers, and state fields (`currentDeepSleepAnimationId`, `ANIMATION_PERSONALITY_ID`) in `HamsterEntity.java`. Logic is managed in `HamsterEntity.tick()`.

        *   **Phase 1: Quiescent Sitting (Entry Point)**
            *   **Entry Condition:** Player commands sit (`dataTracker.get(IS_SITTING)` true), `DozingPhase` is `NONE`, `quiescentSitDurationTimer` is 0.
            *   **Behavior:** `DozingPhase` set to `QUIESCENT_SITTING`. `quiescentSitDurationTimer` starts (random duration based on config). Animation: The hamster's personality-specific sitting pose (`anim_hamster_sitting_pose1/2/3`) loops. Can be interrupted by the cleaning animation. Visuals: Standard procedural blinking.
            *   **Transition to Phase 2:** `quiescentSitDurationTimer` expires AND {{Conditions for Initiating Drowsiness (Tamed)}} met.
            *   **Interruption & Reset (Phase 1):** Player interaction or conditions no longer being met resets phase to `NONE`.

        *   **Phase 2: Drifting into Drowsiness**
            *   **Entry Condition:** Successful transition from Phase 1.
            *   **Behavior:** `DozingPhase` set to `DRIFTING_OFF`. `driftingOffTimer` set to 90 seconds. Animation: The hamster's personality-specific `anim_hamster_drifting_off_pose1/2/3` plays. Visuals: Blinking/cleaning deactivated. `closed_eyes` bone made visible for animation control.
            *   **Transition to Phase 3:** `driftingOffTimer` expires AND {{Conditions for Sustaining Slumber (Tamed)}} met.
            *   **Interruption & Reset (Phase 2):** Conditions no longer being met resets phase to `NONE`.

        *   **Phase 3: Settling into Slumber**
            *   **Entry Condition:** Successful transition from Phase 2.
            *   **Behavior:** `DozingPhase` set to `SETTLING_INTO_SLUMBER`. Target `currentDeepSleepAnimationId` (e.g., "anim_hamster_sleep_pose1") and corresponding `settleAnimId` (e.g., "anim_hamster_settle_sleep1") are chosen. `settleAnimId` is triggered. `settleSleepAnimationCooldown` (1 second) starts. Visuals: Blinking/cleaning deactivated. `closed_eyes` bone visible for animation control.
            *   **Transition to Phase 4:** `settleSleepAnimationCooldown` expires.
            *   **Interruption & Reset (Phase 3):** Conditions no longer being met resets phase to `NONE`.

        *   **Phase 4: Deep Sleep**
            *   **Entry Condition:** Successful transition from Phase 3.
            *   **Behavior:** `DozingPhase` set to `DEEP_SLEEP`. Animation: Loops the animation specified by `currentDeepSleepAnimationId`. Visuals: Blinking/cleaning deactivated. `closed_eyes` bone visible (static closed via animation).
            *   **Exiting Deep Sleep (Interruption of Phase 4):** Conditions no longer being met resets phase to `NONE`.

    *   **C. Wild Hamster Exclusive: "Quick Sleep Onset"**
        Managed by `HamsterSleepGoal.java`.

        *   **Trigger:** `HamsterSleepGoal.start()` invoked.
        *   **Behavior:** `HamsterSleepGoal` sets `hamster.setSleeping(true)` and `hamster.setInSittingPose(true)`. It randomly selects one of the three sleep poses, stores its name in a `DataTracker`, and triggers the corresponding `anim_hamster_stand_settle_sleep` animation server-side.
        *   **Post-Transition Loop:** The main animation controller reads the stored animation name from the `DataTracker` and loops the corresponding `anim_hamster_sleep_pose` while `hamster.isSleeping()` is true.
        *   **Exiting Sleep:** Managed by `HamsterSleepGoal.shouldContinue()` and `stop()`.
*   Current Status: Implemented and working as intended. ✅

#### 7.14.2. Baby Scaling Logic

*   Requirement: Baby hamsters should appear smaller than adults, using the main GeckoLib model, with a small body and a relatively larger head for cuteness. JSON-defined scaling animations (like breathing) must still work proportionally.
*   Implementation:
    *   Modified `HamsterModel.setCustomAnimations()`:
        *   The `root` and `head_parent` bones (which are un-animated in JSON) are used as the master controllers for overall baby/adult size.
        *   If `entity.isBaby()`:
            *   `root` bone is scaled down (e.g., to 0.5x).
            *   `head_parent` bone is scaled procedurally (e.g., 1.2x relative to the scaled `root`) to achieve the "big head" look that makes the babies cuter.
            *   `body_parent` bone is *not* scaled procedurally in `setCustomAnimations`, which is on purpose. Its scale is determined by its default 1.0x relative to `root`, crucially allowing JSON animations (like breathing that scales `body_parent`) to apply their transformations proportionally to the baby's (and adult’s) size.
        *   If adult:
            *   `root` bone scale is reset to default (1.0x scale).
            *   `head_parent` bone scale is reset to 1.0x relative to `root`.
    *   This approach ensures that procedural scaling for baby/adult state is applied every frame, and JSON animations for specific parts like `body_parent` can still function correctly and proportionally.
*   Shadow Rendering (`HamsterRenderer.java`):
    *   The `shadowRadius` is dynamically adjusted in the `render()` method. For baby hamsters, the shadow radius is halved.
*   Current Status: Implemented and working as intended. ✅

#### 7.14.3. Unified Body & Head Rotation

*   **Requirement:** Resolves an unpleasant visual where the hamster's rotation appears to "hitch" or stutter, especially during rapid, non-pathfinding turns (like looking at a player). This is caused by vanilla's default `BodyControl` logic, which is designed for models with distinct head and body parts and attempts to slowly interpolate the body's rotation to catch up with the head's rotation. For a single-piece GeckoLib model, this results in an unnatural, two-stage turn.
*   **Implementation to fix this:**
    *   **Custom Body Control:** The `HamsterBodyControl` class extends `BodyControl`.
    *   **Logic Override:** The `tick()` method within this class is overridden. Instead of performing vanilla's complex interpolation, it now executes a single, critical line of logic on every tick: it forces the entity's `bodyYaw` to be set directly to the value of its `headYaw`. This ensures the entire model rotates as one cohesive unit, instantly and smoothly.
    *   **Centralized Speed Constants:** To ensure all non-pathfinding rotations are consistent, two constants (`FAST_YAW_CHANGE` and `FAST_PITCH_CHANGE`) exist in `HamsterEntity`. These constants are used by the `HamsterLookAtEntityGoal`, `HamsterLookAroundGoal`, and anywhere else in the code that rotates the hamster to provide a snappy, responsive feel.
    *   **Integration:** The custom body control is activated by overriding the `createBodyControl()` method in `HamsterEntity` to return an instance of `HamsterBodyControl`.
*   Current Status: Implemented and working as intended. ✅


---

### 7.15. Easter Egg: "Sweet Potato" Name

*   Requirement: Display a special message and effects when a player names a hamster "Sweet Potato" using a Name Tag.
*   Trigger: Player uses a Name Tag to name a hamster "Sweet Potato" (common capitalizations like "sweet potato" and "Sweet potato" also checked).
*   **Implementation (Advancement-Based):**
    *   The old Java-based check in `HamsterEntity.interactMob` has been removed.
    *   A hidden technical advancement, `adorablehamsterpets:technical/sweet_potato_named`, is defined.
        *   **Trigger:** `minecraft:player_interacted_with_entity`, specifically when the player interacts with an `adorablehamsterpets:hamster`.
        *   **Reward:** Grants the function `adorablehamsterpets:technical/check_sweet_potato_name`.
    *   **Function `adorablehamsterpets:technical/check_sweet_potato_name.mcfunction`:**
        *   Runs as the player who performed the interaction.
        *   Checks if the nearest hamster (within ~3 blocks) is now named "Sweet Potato" (or "sweet potato", "Sweet potato").
        *   If the name matches, it executes the function `adorablehamsterpets:technical/sweet_potato_effects`.
        *   Revokes the `adorablehamsterpets:technical/sweet_potato_named` advancement from the player, allowing the check to be triggered again if other hamsters are named.
    *   **Function `adorablehamsterpets:technical/sweet_potato_effects.mcfunction`:**
        *   Runs as the player.
        *   **Conditional Execution:** Only proceeds if the player does *not* already have the flag advancement `adorablehamsterpets:technical/sweet_potato_easter_egg_triggered_flag`. This ensures the special effects are a one-time occurrence per player.
        *   **Effects:**
            *   Sends an action bar message: `message.adorablehamsterpets.sweet_potato_secret` ("Sweet Potato? An inspired name. Very well.") formatted as Gold and Bold.
            *   Plays sound: `minecraft:entity.firework_rocket.launch` at the player.
            *   Spawns particles around the player: `minecraft:happy_villager` (25 count) and `minecraft:flash` (10 count).
        *   **Grants Flag:** After playing effects, grants the player the `adorablehamsterpets:technical/sweet_potato_easter_egg_triggered_flag` advancement.
    *   **Configuration:** The feature is always enabled; the previous config toggle `features.enableSweetPotatoEasterEgg` was removed for simplicity, as the effects are now one-time per player. The `sweet_potato_named.json` advancement is always loaded.
*   Current Status: Implemented and working as intended. ✅

---

### 7.16. Independent Diamond Ore Seeking (and Gold Ore "Mistake")

*   **Requirement:** Allow a tamed hamster, after being on a player's shoulder while a diamond alert was active, to independently seek out nearby diamond ore upon dismount. Introduce a chance for the hamster to "mistakenly" seek gold ore instead, leading to a humorous "sulking" state.
*   **Implementation:**
    *   **Priming Mechanism:**
        *   A flag (`ahp_isDiamondAlertConditionMet`) is set on the `PlayerEntity` via `PlayerEntityMixin` when its shoulder hamster's diamond detection conditions are met (even if the sound/message alert is on cooldown).
        *   When a hamster is dismounted, if this player flag is true, the `HamsterEntity` instance has its persistent `isPrimedToSeekDiamonds` NBT flag set to `true`. This flag indicates the hamster is eligible to start seeking. The player's flag is then reset.
        *   The `isPrimedToSeekDiamonds` flag on the hamster is cleared once it successfully leads to an ore (diamond or gold), if its targeted ore block is broken while seeking/waiting, or if the player picks the hamster back up onto their shoulder.
    *   **AI Goal (`HamsterSeekDiamondGoal.java`):**
        *   A new `Goal` with high priority.
        *   **Activation:** Can only start if `isPrimedToSeekDiamonds` is true, the hamster is not sitting/sleeping/KO'd/sulking/in combat, the "found ore cooldown" is not active, and the feature is enabled in config (`featureToggles.enableIndependentDiamondSeeking`).
        *   **Targeting:**
            *   Scans a configurable radius (`behavior.diamondSeekRadius`) for diamond ore and gold ore.It separates the found ores into two lists: "exposed" (adjacent to an air block) and "buried".
            *   The hamster will always prioritize targeting the closest **exposed** diamond ore over any buried ones.
            *   If no exposed diamond ores are found, it will target the closest **buried** diamond ore.
            *   If both diamond and gold ore are found, a gold ore "mistake" can occur, but only if all detected ores are buried, preserving the surprise for the player. The chance is configurable via `independentDiamondSeeking.goldMistakeChance`.
            *   If only gold ore is found (no diamond), or no diamond ore is found at all, the goal does not activate for that scan, but `isPrimedToSeekDiamonds` remains true, allowing future attempts if the hamster/player moves.
        *   The goal stores the `targetOrePos` and an `isSeekingGold` flag. The hamster entity also stores `currentOreTarget`.
    *   **Behavior States & Animations (Managed by `HamsterSeekDiamondGoal` and `HamsterEntity.registerControllers`):**
        *   **State 1: Seeking (Moving to Ore):**
            *   Pathfinds to target ore at 70% speed.
            *   Animation: Loops `anim_hamster_seeking_diamond` (if velocity > 0).
            *   Particle Breadcrumb Trail: While moving, the goal spawns a trail of `ParticleTypes.MYCELIUM` particles along the future nodes of its calculated path, creating a clear visual guide for the player to follow.
            *   “Sniffing” Particles: Dust-like particles (`FALLING_DUST` colored by the block the hamster is standing on) are spawned from the `nose` bone via animation keyframes (`seeking_dust` effect) handled by `HamsterRenderer`.
            *   Sound: Plays random `HAMSTER_DIAMOND_SNIFF_SOUNDS` every ~2.5 seconds.
        *   **State 2: Wanting to Seek (Path Blocked/Waiting):**
            *   If path is blocked (e.g., by solid blocks or hazards like lava).
            *   Animation: Loops `anim_hamster_wants_to_seek_diamond` (if velocity is 0).
            *   Sound: Plays random `HAMSTER_DIAMOND_SNIFF_SOUNDS` every ~8 seconds.
            *   Periodically re-attempts pathfinding. If path clears, transitions to State 1.
        *   **State 3A: Celebration (Diamond Ore Reached):**
            *   `isPrimedToSeekDiamonds` is cleared. "Found ore cooldown" applied.
            *   `IS_CELEBRATING_DIAMOND` DataTracker set to `true`.
            *   Animation: Loops `anim_hamster_begging`.
            *   Sound (Managed by `HamsterEntity.tick()`):
                *   A random `DIAMOND_SPARKLE_SOUNDS` plays with a 10-tick delay at the ore's location.
                *   Random `HAMSTER_BEG_SOUNDS` play every ~1.5 seconds (30 ticks).
                *   Bounce sounds (`hamster_beg_bounce` keyframe) play via animation.
            *   Particles (Managed by `HamsterEntity.tick()` for `CELEBRATION_PARTICLE_DURATION_TICKS`):
                *   `ParticleTypes.TRIAL_SPAWNER_DETECTION_OMINOUS` on the hamster.
                *   `ParticleTypes.FIREWORKS` above the diamond ore block.
            *   Exited by player right-click interaction (clears `IS_CELEBRATING_DIAMOND`) or if the target ore block is broken.
        *   **State 3B: Disappointment (Gold Ore "Mistake" Reached):**
            *   `isPrimedToSeekDiamonds` is cleared. "Found ore cooldown" applied.
            *   `IS_SULKING` DataTracker set to `true`.
            *   The hamster attempts to look at its owner (if nearby) just before sulking.
            *   **Startled Jump:** The hamster performs a small jump up and backwards, with an accompanying bounce sound, at the moment of realization. This is handled by applying a direct velocity change in `HamsterSeekDiamondGoal` and a temporary gravity increase in `HamsterEntity.tick()`.
            *   **Message:** A humorous message is sent to the player's action bar. The first time this happens per player, a specific message is shown; on subsequent times, a random message (that doesn't repeat the last one) is chosen. This is managed via a hidden advancement and a persistent NBT tag on the player.
            *   Animation: Server triggers `anim_hamster_sulk` (3-second, non-looping). Animation controller then loops `anim_hamster_sulking` while `IS_SULKING` is true.
            *   Sound (Managed by `HamsterEntity.tick()` and `setSulking()`):
                *   `ModSounds.ALARM_ORCHESTRA_HIT` plays with a 10-tick delay.
                *   `ModSounds.HAMSTER_SHOCKED` plays with a 44-tick (2.2 seconds) delay.
            *   Particles (Managed by `HamsterEntity.tick()` for 600 ticks):
                *   `ParticleTypes.SMOKE` ("fail" particles) above the gold ore block.
                *   Black `ParticleTypes.ENTITY_EFFECT` on the hamster.
            *   Exited by player right-click interaction (clears `IS_SULKING`).
    *   **"One Ore Per Cooldown":**
        *   After successfully leading to an ore (diamond or gold), the specific hamster receives a `foundOreCooldownEndTick`.
        *   This prevents that hamster from starting the `HamsterSeekDiamondGoal` again until the cooldown expires.
        *   Configurable: `cooldowns.independentOreSeekCooldownTicks` and `featureToggles.enableIndependentOreSeekCooldown`.
    *   **Interruption & Resumption:**
        *   **Sitting/Combat:** Goal stops, `isPrimedToSeekDiamonds` remains true. Goal re-evaluates and can resume (targeting last ore or new scan) if priming is still valid after interruption ends.
        *   **Player Pickup (Shoulder Mount):** `isPrimedToSeekDiamonds` is cleared on the hamster. Re-priming depends on player's shoulder alert status upon next dismount.
        *   **Target Ore Broken:** Goal stops, `isPrimedToSeekDiamonds` is cleared.
    *   **Look Goal Interaction:** `HamsterLookAtEntityGoal` and `HamsterLookAroundGoal` are disabled when the hamster `isSulking()` or `isCelebratingDiamond()`.
*   **Advancements:**
    *   "Canine Aspirations?": Triggers via `ModCriteria.HAMSTER_LED_TO_DIAMOND` when a hamster enters the diamond celebration state.
*   Current Status: Implemented and working as intended. ✅


---

## 8. 📚 Fzzy Config Library-Usage for Config

*   **Purpose:** Provides an auto-generated TOML config file (`config/adorablehamsterpets/main.toml`) and an in-game UI via Mod Menu for player configuration, with built-in validation and synchronization capabilities.
*   **Implementation:**
    *   **`AhpConfig.java`:**
        *   A single root config class extending `me.fzzyhmstrs.fzzy_config.config.Config`.
        *   Uses `@Translatable.Name` and `@Translatable.Desc` annotations on the class and its fields to define the text that appears in the config GUI. This text is automatically converted into translation keys.
        *   Fields are organized into logical `ConfigGroup`s (e.g., `uiPreferences`, `hamsterSpawning`, `cooldowns`) for a clean and navigable UI.
        *   Numerical settings (like spawn rates, damage values, and cooldowns) use `ValidatedInt`, `ValidatedDouble`, or `ValidatedFloat` types to enforce min/max values and provide sliders in the UI.
        *   Boolean settings are simple `boolean` fields, which generate toggle switches.
        *   `@NonSync` annotation is used on fields that are purely client-side and should not be synchronized with the server (e.g., `enableItemTooltips`). This allows them to be modified by any client without requiring server permissions.
        *   `ConfigAction` fields are used to create clickable buttons in the config screen that can open URLs (like the GitHub issues page) or run client-side commands.
    *   **`AdorableHamsterPets.java`:** Initializes the config during `onInitialize` by accessing the singleton instance managed by Fzzy Config's `Configs` class and storing it in the static `AdorableHamsterPets.CONFIG` field.
    *   **`EnUsGenerator.java`:** A dedicated `FabricLanguageProvider` is used during data generation.
        *   It first reads all non-config translations from a manual `en_us_base.json` file.
        *   It then calls `ConfigApiJava.buildTranslations()` to automatically generate all translation keys for the config screen (titles, options, descriptions) based on the annotations in `AhpConfig.java`.
        *   It merges these two sources into the final `assets/adorablehamsterpets/lang/en_us.json` file that is shipped with the mod.
*   Current Status: Implemented and working as intended. ✅

---

## ➡️ 9. Current Development Status Summary

**Project Infrastructure & Workflow:**
*   ✅ Architectury Migration for Multi-Loader Support
*   ✅ GitFlow Branching Model Setup

**Core Mod Features:**
*   ✅ Core Items & Blocks
*   ✅ Sunflower Seed Harvesting
*   ✅ World Gen: Wild Green Bean Bush
*   ✅ World Gen: Wild Cucumber Bush
*   ✅ Food Item: Cheese (Also used for Shoulder Riding)
*   ✅ Custom Item Tooltips
*   ✅ Hint Book
*   ✅ Advancement Tree (Custom Tab & Initial Structure)
*   ✅ Use of Fzzy Config library (Configuration File & UI)

**Hamster Entity (`HamsterEntity.java`):**
*   ✅ Core Entity Definition & Attributes
*   ✅ Wild Spawning Logic
*   ✅ Biome-Specific Variant Spawning & Textures
*   ✅ Breeding Inheritance (Color & Overlay Logic)
*   ✅ Taming & Basic Interaction (Following, Manual Sit/Stay)
*   ✅ Feeding, Healing, and Breeding Mechanics
*   ✅ Repeat Food Refusal Logic
*   ✅ Melee Attack (Tamed - Defend Owner, Attack Designated)
*   ✅ Cheek Pouch Inventory (Access, Item Restrictions, Ejection)
*   ✅ Shoulder Riding Mechanics (Summoning, Dismounting, Data Persistence)
*   ✅ Buff Application: `STEAMED_GREEN_BEANS`
*   ✅ Auto-Feeding from Inventory
*   ✅ Creeper Detection (While on Shoulder)
*   ✅ Diamond Ore Detection (While on Shoulder)
*   ✅ Throwing Attack (From Shoulder, including KO state)
*   ✅ Easter Egg: "Sweet Potato" Name

**Hamster Visuals & Animations (GeckoLib):**
*   ✅ Base Model & Textures (`hamster.geo.json`, variant textures)
*   ✅ Core Animations (Idle, Walk, Run, Sit, Clean, Beg, Attack, Fly, Crash, KO, Wakeup, No)
*   ✅ Blinking Effect (Procedural)
*   ✅ Baby Scaling Logic (Model & Shadow)
*   ✅ Cheek Pouch Inflation Visuals
*   ✅ Pink Petal Overlay Application, Cycling & Shear Removal
*   ✅ Advanced Sleep Behavior Animations (Drifting Off, Settle Poses, Deep Sleep Poses, Wild Settle)
*   ✅ Animation State Machine for Advanced Sleep (Seeking Diamond, Wants to Seek Diamond)
*   ✅ Ore Seeking Animation State Machine

**Sounds:**
*   ✅ Custom Sound Event Registration & `sounds.json`
*   ✅ Shoulder Riding Mount & Dismount Sounds

**Future Enhancements & Ideas:**
*   ❌ High-Speed "Sprint" Animation
*   ❌ Cheese Production Method (Advanced)
*   ❌ "Snack of Yestermouth" Item
*   ❌ Enhanced Idle Animations
*   ❌ Additional Hamster Variant Overlays
*   ❌ Fresh Animations Compatibility (Shoulder Model)


---

## ➡️ 10. Technical Notes & Open Questions

*   **NeoForge Development Environment Testing:**
    *   The standard `runClient` Gradle task for NeoForge fails in the development environment. This is due to a persistent and unresolvable dependency conflict involving `KotlinForForge` (a dependency of `Fzzy Config`), which causes `IllegalAccessError` and `NoClassDefFoundError` crashes. This is a known issue also experienced by the `Fzzy Config` author.
    *   As a result, all testing and validation for the NeoForge version of the mod **must be conducted using a production JAR file** built via the `./gradlew build` command. This method has been proven to be a reliable validation strategy.

*   **Fabric 1.20.1 Development Environment - Village Crash:**
    *   **Issue:** The game crashes with an `InvalidInjectionException` related to `TypeAwareBuyForOneEmeraldFactory` when rendering a village or opening a villager trading GUI in the **Fabric 1.20.1 Development Environment** (`runClient`).
    *   **Cause:** This is a known regression in **Fabric API 0.92.0+**. While a fix was attempted in 0.92.4, it does not resolve the issue in the stricter development environment (though production JARs work fine).
    *   **Constraint:** We cannot downgrade Fabric API below 0.92.0 because **GeckoLib 4.7.1+** (required for 1.20.1’s `stopTriggeredAnimation`) hard-depends on Fabric API 0.92.0+.
    *   **Workaround:** Avoid villages while testing in the 1.20.1 `runClient` environment. If village testing is required, build the JAR and test in a production environment.
    *   **Status:** Reported to Fabric API GitHub. Waiting for a permanent upstream fix. ⚠️


---

## ➡️ 11. Future Enhancements & Ideas

This section outlines potential new features and improvements for future development.  Keep in mind, each of these will need to be fleshed out more before really diving much deeper into them. Do not dive into any of these features / ideas in Section 12 unless you specifically ask first.

### 11.1. F	zzyhmstrs wizard hat (inverse kinematics?)

*   Current Status: Not yet brainstormed ❌.

### 11.2. Cheese Production Method

*   **Concept:** Provide a more involved method for crafting `CHEESE` than the current direct milk-to-cheese recipe.
*   Research basic cheese-making steps for thematic inspiration.
*   Current Status: Not yet brainstormed ❌.

### 11.3. "Snack of Yestermouth" Item

*   **Concept:** Introduce a unique, humorously named item with a quirky effect / purpose.
*   **Technical Details:**
    *   Define a new item in `ModItems.java`.
    *   Create a texture for the item.
    *   Initial brainstorming (needs more careful examination): When more than one type of food item is left inside the hamster's cheek pouch inventory for a number of Minecraft days,  All of the stacks of food will decrement once and a new item will appear: the “Snack of Yestermouth.”  Basically as if the hamster’s stored food all sort of merged into the new item.  So if  Food is left in the hamster's cheek pouch for long enough, eventually nearly all of it will convert to the “Snack of Yestermouth” until there is no longer >1 type of food item remaining. The process would be very slow except if rotten flesh were present in the inventory which would dramatically speed it up (And of course the rotten flesh would get used up as well)
    *   Let's brainstorm creatively what on Earth this item could be used for. Currently I have no idea except maybe it creates a ton of bone meal in a composter? But let’s explore alternative ideas as well.  Maybe think of certain areas in minecraft that are a bit tedious and could use some assistance and maybe this item could somehow help with those things.
*   Current Status: Not yet brainstormed ❌.

### 11.4. Additional Hamster Variant Overlays

*   **Concept:** Increase visual diversity by adding more white overlay patterns for hamster variants.
*   **Technical Details:**
    *   Create new texture files for overlays (e.g., `overlay_white_socks.png`, `overlay_white_face_stripe.png`).
    *   Add new entries to the `HamsterVariant.java` enum, defining new combinations of base textures and these new overlay textures.
    *   Ensure biome-specific variant assignment logic (`HamsterEntity.determineVariantForBiome`) can select these new variants if appropriate for existing or new variant pools.
*   Current Status: Not yet brainstormed ❌.


---

# ➡️ Project Files

## AHP Provided Code

### 📂 `Repository Root/`
`ASSETS_LICENSE.txt`
```text
ASSETS LICENSE — ALL RIGHTS RESERVED

Copyright (c) 2025 Dawson Bodenhamer
www.ForTheKing.Design

This file applies ONLY to non-code assets in this repository. Non-code assets include, but are not limited to:
- Textures, sprites, and other artwork (block, item, entity, GUI, icons, etc.)
- Models and geometry
- Animations
- Sounds, music, and other audio
- Resource-pack and data assets such as blockstates, model definitions, sound definitions, and related JSON resources
- Language/localization files
- Patchouli book content, including book data and embedded images
- Any other media or asset files that are not program source code

All such assets are the exclusive property of the copyright holder.

Permission is NOT granted to copy, reproduce, modify, adapt, translate, distribute, publicly display,
publicly perform, sublicense, or sell any of these assets, in whole or in part, without prior written permission.

These assets are provided “AS IS”, without warranty of any kind, express or implied, including but not limited to
the warranties of merchantability, fitness for a particular purpose, and non-infringement. In no event shall the
authors or copyright holders be liable for any claim, damages, or other liability, whether in an action of contract,
tort, or otherwise, arising from, out of, or in connection with the assets or their use.

NOTE: Source code in this repository is licensed separately under the GNU Lesser General Public License v3.0
(or later). See the root LICENSE file for code licensing terms.
```

`LICENSE.txt` (Content omitted)

`build.gradle`
```groovy
plugins {
    id 'dev.architectury.loom' version '1.10-SNAPSHOT' apply false
    id 'architectury-plugin' version '3.4-SNAPSHOT'
    id 'com.gradleup.shadow' version '8.3.6' apply false
}

architectury {
    minecraft = project.minecraft_version
}

allprojects {
    apply plugin: "java"
    apply plugin: "architectury-plugin"

    group = rootProject.maven_group
    version = "${rootProject.mod_version}-${rootProject.minecraft_version}+${project.name}"
    base.archivesName = rootProject.archives_base_name
}

subprojects {
    apply plugin: 'dev.architectury.loom'
    apply plugin: 'maven-publish'

    java {
        withSourcesJar()
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    tasks.withType(JavaCompile).configureEach {
        it.options.release = 17
        it.options.encoding = "UTF-8"
    }

    repositories {
        maven { name = "TerraformersMC"; url = "https://maven.terraformersmc.com/" }
        maven { name = "FzzyMaven"; url = "https://maven.fzzyhmstrs.me/" }
        maven { name = "CurseMaven"; url = "https://cursemaven.com" }
        maven { name = "Modrinth"; url = "https://api.modrinth.com/maven" }
        maven { name = "GeckoLib"; url = 'https://dl.cloudsmith.io/public/geckolib3/geckolib/maven/' }
        maven { url = "https://thedarkcolour.github.io/KotlinForForge/" }
        maven { name = "Patchouli"; url = 'https://maven.blamejared.com' }
    }

    dependencies {
        minecraft "com.mojang:minecraft:$rootProject.minecraft_version"
        mappings loom.layered {
            it.mappings "net.fabricmc:yarn:${project.yarn_mappings}:v2"
        }
    }

    publishing {
        publications {
            mavenJava(MavenPublication) {
                artifactId = base.archivesName.get()
                from components.java
            }
        }
        repositories {
            // Add publishing repositories here
        }
    }
}
```

`gradle.properties`
```properties
# Gradle Properties
org.gradle.jvmargs=-Xmx2G

# Architectury Properties
minecraft_version=1.20.1
yarn_mappings=1.20.1+build.10
enabled_platforms=fabric,forge

# Loader Versions
fabric_loader_version=0.15.11
forge_version=1.20.1-47.4.3

# Mod Properties
# Semantic Versioning: MAJOR.MINOR.PATCH
# - PATCH: Bug fixes only. Backward-compatible.
# - MINOR: New features added. Backward-compatible.
# - MAJOR: Breaking changes. Not backward-compatible. For example, replacing hamster food mix with a different item. Players with existing worlds with hamster food mix in chests would find it gone after updating.
mod_version=3.4.3
maven_group=net.dawson.adorablehamsterpets
archives_base_name=adorablehamsterpets

# API Dependencies
fabric_api_version=0.92.6+1.20.1
architectury_api_version=9.2.14

# For Data Gen
fabric.datagen.modid=adorablehamsterpets

# Mod Dependencies
geckolib_version=4.8.2
modmenu_version=7.2.2
fzzy_config_version=0.7.3+1.20.1
jade_version_fabric=6106093
jade_version_forge =6271651

# Runtime Dependencies (for Fzzy Config)
flk_version=1.13.4+kotlin.2.2.0
kff_version=4.11.0
```

`settings.gradle`
```groovy
pluginManagement {
    repositories {
        maven { url "https://maven.fabricmc.net/" }
        maven { url "https://maven.architectury.dev/" }
        maven { url "https://files.minecraftforge.net/maven/" }
        gradlePluginPortal()
    }
}

rootProject.name = 'adorablehamsterpets'

include 'common'
include 'fabric'
include 'forge'
```

### 📂 `common/`
`build.gradle`
```groovy
architectury {
    common(rootProject.enabled_platforms.split(','))
}

dependencies {
    // Depend on Fabric Loader here to use the Fabric @Environment annotations
    modImplementation "net.fabricmc:fabric-loader:$rootProject.fabric_loader_version"

    // Architectury API
    modImplementation "dev.architectury:architectury:$rootProject.architectury_api_version"

    // Common Dependencies
    modImplementation "software.bernie.geckolib:geckolib-fabric-$rootProject.minecraft_version:$rootProject.geckolib_version"
    modImplementation "me.fzzyhmstrs:fzzy_config:${rootProject.fzzy_config_version}"
    modImplementation "curse.maven:jade-324717:${rootProject.jade_version_fabric}"
    modImplementation "vazkii.patchouli:Patchouli:1.20.1-84.1-FABRIC"
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/`
`ModRegistries.java`
```java
package net.dawson.adorablehamsterpets;

// (Imports omitted to save token count)

/**
 * Handles miscellaneous registrations that need to occur at specific lifecycle events.
 */
public class ModRegistries {

    /**
     * Registers items with the vanilla composter.
     * This is called directly during the common setup phase.
     */
    public static void registerCompostables() {
        ComposterBlock.ITEM_TO_LEVEL_INCREASE_CHANCE.put(ModItems.GREEN_BEANS.get(), 0.5f);
        ComposterBlock.ITEM_TO_LEVEL_INCREASE_CHANCE.put(ModItems.CUCUMBER.get(), 0.5f);
        ComposterBlock.ITEM_TO_LEVEL_INCREASE_CHANCE.put(ModItems.GREEN_BEAN_SEEDS.get(), 0.25f);
        ComposterBlock.ITEM_TO_LEVEL_INCREASE_CHANCE.put(ModItems.CUCUMBER_SEEDS.get(), 0.25f);
        ComposterBlock.ITEM_TO_LEVEL_INCREASE_CHANCE.put(ModItems.SUNFLOWER_SEEDS.get(), 0.25f);
        ComposterBlock.ITEM_TO_LEVEL_INCREASE_CHANCE.put(ModItems.HAMSTER_BEDDING.get(), 0.75f);
    }

    /**
     * Registers items with the vanilla dispenser.
     * This is called directly during the common setup phase.
     */
    public static void registerDispenserBehaviors() {
        DispenserBlock.registerBehavior(ModItems.HAMSTER_BEDDING.get(), new FallibleItemDispenserBehavior() {
            @Override
            protected ItemStack dispenseSilently(BlockPointer pointer, ItemStack stack) {
                // On 1.20.1, use getters for BlockPointer
                ServerWorld world = pointer.getWorld();
                Direction direction = pointer.getBlockState().get(DispenserBlock.FACING);
                BlockPos pos = pointer.getPos();

                // Find players in range to send packet and trigger advancement
                List<ServerPlayerEntity> nearbyPlayers = world.getPlayers(p -> p.squaredDistanceTo(Vec3d.ofCenter(pos)) < 64 * 64);

                // Send custom packet with the default OAK variant
                // On 1.20.1, use ModPackets.CHANNEL and the 1.20.1 Packet Record
                ModPackets.CHANNEL.sendToPlayers(
                        nearbyPlayers,
                        new ModPackets.SpawnBeddingParticlesS2CPacket(pos, direction, WoodVariant.OAK)
                );

                // Trigger advancement for each nearby player
                for (ServerPlayerEntity player : nearbyPlayers) {
                    ModCriteria.DISPENSED_HAMSTER_BEDDING.trigger(player);
                }

                // Play leaf sound on server
                SoundEvent rustleSound = ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_BED_LEAVES_RUSTLE_SOUNDS, world.random);
                if (rustleSound != null) {
                    world.playSound(null, pos, rustleSound, SoundCategory.BLOCKS, 0.15f, 1.2f);
                }

                stack.decrement(1);
                this.setSuccess(true);
                return stack;
            }
        });
    }
}
```

`AdorableHamsterPets.java`
```java
package net.dawson.adorablehamsterpets;

// (Imports omitted to save token count)

public class AdorableHamsterPets {
	public static final String MOD_ID = "adorablehamsterpets";
	public static final org.slf4j.Logger LOGGER = org.slf4j.LoggerFactory.getLogger(MOD_ID);

	public static AhpRootConfig ROOT_CONFIG;
	public static AhpConfig CONFIG;
	public static AhpWorldGenConfig WORLD_GEN_CONFIG;

	/**
	 * Initializes all DeferredRegister instances.
	 * This must be called during mod construction (e.g., the loader-specific entrypoint's constructor or onInitialize).
	 */
	public static void initRegistries() {
		ROOT_CONFIG = Configs.AHP_ROOT;
		CONFIG = Configs.AHP;
		WORLD_GEN_CONFIG = Configs.AHP_WORLDGEN;
		ModEntities.register();
		ModSounds.register();
		ModBlocks.register();
		ModItems.register();
		ModItemGroups.register();
		ModScreenHandlers.register();
		ModCriteria.register();
		ModBlockEntities.register();
		ModParticles.register();
	}

	/**
	 * Initializes common setup logic that needs to run after registries are populated.
	 * This is called from FMLCommonSetupEvent on Forge and onInitialize on Fabric.
	 */
	public static void initCommonSetup() {
		// We check if the data generation API is NOT loaded. If it is loaded, we are in a datagen environment
		// and should skip runtime-only logic to prevent crashes.
		if (System.getProperty("fabric-api.datagen") == null) {
			ModRegistries.registerCompostables();
			ModRegistries.registerDispenserBehaviors();
			ModEntitySpawns.parseConfig();
			ModWorldGeneration.parseConfig();
			ConfigDataCache.parseConfig();

			// --- Networking Registration ---
			// On 1.20.1, register all  packets on both sides using the safe common method.
			ModPackets.registerCommonPackets();

			// --- World Gen ---
			ModWorldGeneration.registerBiomeModifications();

			// --- Events ---
			AHPCommonEvents.init();
			PlayerEvent.PLAYER_JOIN.register(AdorableHamsterPets::onPlayerJoin);
			PlayerEvent.PLAYER_CLONE.register(AdorableHamsterPets::onPlayerClone);
			CommandRegistrationEvent.EVENT.register(ModCommands::register);
			LifecycleEvent.SETUP.register(AdorableHamsterPets::onSetup);
		}
	}

	/**
	 * Initializes entity attributes. This must be called after registries are initialized
	 * but before the main setup event, typically during mod construction.
	 */
	public static void initAttributes() {
		EntityAttributeRegistry.register(ModEntities.HAMSTER, HamsterEntity::createHamsterAttributes);
	}

	/**
	 * This method is called during the SETUP lifecycle event, after all registries are frozen.
	 * It's the safe place to register things that require fully-realized registry objects,
	 * like spawn placements.
	 */
	private static void onSetup() {
		// --- Spawn Restriction Registration ---
		ModSpawnPlacements.register(ModEntities.HAMSTER.get(), SpawnRestriction.Location.ON_GROUND,
				Heightmap.Type.MOTION_BLOCKING_NO_LEAVES,
				(type, world, reason, pos, random) -> (world.getBlockState(pos.down()).isIn(net.minecraft.registry.tag.BlockTags.ANIMALS_SPAWNABLE_ON) ||
						ModEntitySpawns.VALID_SPAWN_BLOCKS.contains(world.getBlockState(pos.down()).getBlock())));
	}

	/**
	 * An event handler that is called whenever a player joins the server.
	 * <p>
	 * This method is responsible for the one-time delivery of the Hamster Guide Book. It checks if the player
	 * has the {@code adorablehamsterpets:technical/has_received_initial_guidebook} advancement. If they do not,
	 * and if the {@code uiTweaks.enableAutoGuidebookDelivery} config option is enabled, it directly gives
	 * the player the book, plays effects, and then grants the advancement flag to prevent future deliveries.
	 *
	 * @param player The ServerPlayerEntity who has just joined the world.
	 */
	private static void onPlayerJoin(ServerPlayerEntity player) {
		if (Configs.AHP.enableAutoGuidebookDelivery) {
			PlayerAdvancementTracker advancementTracker = player.getAdvancementTracker();
			Identifier flagAdvId = Identifier.of(MOD_ID, "technical/has_received_initial_guidebook");
			Advancement flagAdvancement = player.server.getAdvancementLoader().get(flagAdvId);

			if (flagAdvancement != null) {
				AdvancementProgress flagProgress = advancementTracker.getProgress(flagAdvancement);
				if (!flagProgress.isDone()) {
					// --- 1. Create the Book ItemStack Directly ---
					ItemStack bookStack = new ItemStack(ModItems.HAMSTER_GUIDE_BOOK.get());

					// In 1.20.1, use NBT tags to set the Patchouli book ID
					NbtCompound nbt = bookStack.getOrCreateNbt();
					nbt.putString("patchouli:book", "adorablehamsterpets:hamster_tips_guide_book");

					// --- 2. Give the Item to the Player ---
					player.getInventory().offerOrDrop(bookStack);

					// --- 3. Grant the Flag Advancement ---
					for (String criterion : flagAdvancement.getCriteria().keySet()) {
						advancementTracker.grantCriterion(flagAdvancement, criterion);
					}
					LOGGER.info("Gave 'Hamster Tips' guide book to player {}.", player.getName().getString());
				}
			} else {
				LOGGER.warn("Could not find flag advancement: {}", flagAdvId);
			}
		}

		// Sync initial shoulder data
		((PlayerEntityAccessor) player).adorablehamsterpets$syncShoulderData();

		// Upgrade any old hamster tips guide books in the player's inventory
		replaceOldBooksInInventory(player.getInventory());
	}

	/**
	 * An event handler that is called when a player entity is "cloned," which is observed to
	 * fire reliably upon respawn after death.
	 * <p>
	 * NOTE: This event does not fire for dimension travel (e.g., Nether/End portals).
	 * In those cases, the same PlayerEntity instance is reused, preserving transient data like the
	 * mount order queue automatically.
	 * <p>
	 *
	 * @param oldPlayer The player entity instance before death.
	 * @param newPlayer The new player entity instance created upon respawn.
	 * @param wasDeath_UNRELIABLE A boolean flag that is not reliable on all platforms and is ignored.
	 */
	private static void onPlayerClone(ServerPlayerEntity oldPlayer, ServerPlayerEntity newPlayer, boolean wasDeath_UNRELIABLE) {
		PlayerEntityAccessor oldPlayerAccessor = (PlayerEntityAccessor) oldPlayer;
		PlayerEntityAccessor newPlayerAccessor = (PlayerEntityAccessor) newPlayer;

		// --- 1. Handle "Keep on Shoulder" Scenario ---
		if (Configs.AHP.keepHamstersOnShoulderOnDeath) {
			newPlayerAccessor.adorablehamsterpets$getMountOrderQueue().addAll(oldPlayerAccessor.adorablehamsterpets$getMountOrderQueue());
			for (ShoulderLocation location : ShoulderLocation.values()) {
				NbtCompound shoulderNbt = oldPlayerAccessor.getShoulderHamster(location);
				if (!shoulderNbt.isEmpty()) {
					newPlayerAccessor.setShoulderHamster(location, shoulderNbt);
					AdorableHamsterPets.LOGGER.debug("Player {} respawned with 'Keep on Shoulder' enabled. Transferring {} hamster to new entity.", newPlayer.getName().getString(), location);
				}
			}
			return; // Data transferred, nothing more to do.
		}

		// --- 2. Handle Spawning at Death Location (Default) ---
		ServerWorld world = oldPlayer.getServerWorld();
		BlockPos deathPos = oldPlayer.getBlockPos();
		Set<BlockPos> occupiedSpawnPositions = new HashSet<>();

		for (ShoulderLocation location : ShoulderLocation.values()) {
			NbtCompound shoulderNbt = oldPlayerAccessor.getShoulderHamster(location);
			if (shoulderNbt.isEmpty()) continue;

			// Modify NBT to set the knocked-out state before spawning
			NbtCompound modifiedNbt = setKnockedOutInNbt(shoulderNbt);
			HamsterEntity hamster = HamsterEntity.createFromNbt(world, oldPlayer, modifiedNbt);
			if (hamster == null) continue;

			// Find a unique, safe spawn position
			Optional<BlockPos> safePosOpt = hamster.findSafeSpawnPosition(deathPos, world, 5, occupiedSpawnPositions);

			BlockPos finalSpawnPos = safePosOpt.orElse(deathPos);
			occupiedSpawnPositions.add(finalSpawnPos); // Add chosen position to the set for the next hamster

			// Set initial position
			hamster.refreshPositionAndAngles(finalSpawnPos.getX() + 0.5, finalSpawnPos.getY(), finalSpawnPos.getZ() + 0.5, 0, 0);

			// Spawn the entity in the world
			world.spawnEntityAndPassengers(hamster);

			// Randomize the Yaw so they don't all face the exact same direction
			float randomYaw = world.random.nextFloat() * 360.0F;
			hamster.setBodyYaw(randomYaw);
			hamster.setHeadYaw(randomYaw);

			AdorableHamsterPets.LOGGER.debug("Player {} died. Spawning {} hamster at {} in KO state.", oldPlayer.getName().getString(), location, finalSpawnPos);
		}
		// By not transferring any data to newPlayer, they will respawn with empty shoulders.
	}

	/**
	 * A helper method that takes a hamster's NBT data, deserializes it, sets the
	 * knocked-out flag, and re-serializes it to a new NbtCompound.
	 *
	 * @param originalNbt The original NbtCompound from the player's shoulder data.
	 * @return A new NbtCompound with the KNOCKED_OUT_FLAG set.
	 */
	private static NbtCompound setKnockedOutInNbt(NbtCompound originalNbt) {
		return HamsterShoulderData.fromNbt(originalNbt).map(data -> {
			int newFlags = data.hamsterFlags() | HamsterEntity.KNOCKED_OUT_FLAG;
			HamsterShoulderData knockedOutData = new HamsterShoulderData(
					data.entityUuid(), data.variantId(), data.health(), data.inventoryNbt(),
					data.breedingAge(), data.throwCooldownEndTick(), data.greenBeanBuffData(),
					data.autoEatCooldownTicks(), data.customName(), data.pinkPetalType(),
					data.animationPersonalityId(), data.seekingBehaviorData(), data.wanderModeData(), newFlags
			);
			return knockedOutData.toNbt();
		}).orElse(originalNbt); // Fallback to original NBT if deserialization fails
	}

	/**
	 * Iterates through an inventory and replaces any outdated Hamster Guide Books
	 * with the new Patchouli-compatible version added in version 3.3.0.
	 *
	 * @param inventory The inventory to scan and upgrade.
	 */
    public static void replaceOldBooksInInventory(Inventory inventory) {
        if (inventory == null) return;

        // --- 1. Define the Patchouli NBT key and target book ID for 1.20.1---
        // Patchouli identifies a book via a root-level String NBT: "patchouli:book" -> "<namespace>:<book_id>"
        final String PATCHOULI_BOOK_TAG = "patchouli:book";
        final String TARGET_BOOK_ID = new Identifier(MOD_ID, "hamster_tips_guide_book").toString();

        // --- 2. Iterate through all slots in the provided inventory ---
        for (int i = 0; i < inventory.size(); i++) {
            ItemStack stack = inventory.getStack(i);

            // --- 3. Check if the item is an OLD guide book ---
            // It's an old book if it's the guide book item but lacks the Patchouli NBT tag.
            if (!stack.isEmpty() && stack.isOf(ModItems.HAMSTER_GUIDE_BOOK.get())) {
                NbtCompound nbt = stack.getNbt();
                boolean hasPatchouliBookTag = nbt != null && nbt.contains(PATCHOULI_BOOK_TAG, NbtElement.STRING_TYPE);

                if (!hasPatchouliBookTag) {
                    // --- 4. Create the new, upgraded book stack ---
                    ItemStack newBookStack = new ItemStack(ModItems.HAMSTER_GUIDE_BOOK.get(), stack.getCount());
                    newBookStack.getOrCreateNbt().putString(PATCHOULI_BOOK_TAG, TARGET_BOOK_ID);

                    // --- 5. Replace the old stack with the new one ---
                    inventory.setStack(i, newBookStack);
                    LOGGER.info("Upgraded an old Hamster Tips Guide Book to the new Patchouli version.");
                }
            }
        }
    }
}
```

`AdorableHamsterPetsClient.java`
```java
package net.dawson.adorablehamsterpets;

// (Imports omitted to save token count)

public class AdorableHamsterPetsClient {

    // --- Rendering State ---
    private static final Set<Integer> renderedHamsterIdsThisTick = new HashSet<>();
    private static final Set<Integer> renderedHamsterIdsLastTick = new HashSet<>();

    // --- Input & Dismount Logic ---
    private static long lastSneakPressTime = 0;
    private static boolean isWaitingForSecondSneakPress = false;
    private static boolean hadShoulderHamsterLastTick = false;
    private static int dismountDebounceTicks = 0;
    private static final int DISMOUNT_DEBOUNCE_DEFAULT = 5;

    // --- Announcement System ---
    private static final AnnouncementHudRenderer announcementHudRenderer = new AnnouncementHudRenderer();
    private static List<AnnouncementManager.PendingNotification> pendingNotifications = Collections.emptyList();
    private static int nextRefreshTicks = 6000; // 5 minutes

    /* ──────────────────────────────────────────────────────────────────────────────
     *                       1. Initialization & Registration
     * ────────────────────────────────────────────────────────────────────────────*/

    /**
     * Initializes general client-side features.
     * This includes RenderTypes, Config Events, Item Colors, Packet Receivers,
     * Screen Events, Tick Events, and Keybind Interactions.
     */
    public static void init() {
        // --- Block Render Types ---
        RenderTypeRegistry.register(RenderLayer.getCutout(),
                ModBlocks.GREEN_BEANS_CROP.get(),
                ModBlocks.CUCUMBER_CROP.get(),
                ModBlocks.SUNFLOWER_BLOCK.get(),
                ModBlocks.WILD_CUCUMBER_BUSH.get(),
                ModBlocks.WILD_GREEN_BEAN_BUSH.get(),
                ModBlocks.HAMSTER_BED.get());

        // --- Config Reload Listener ---
        ConfigApiJava.event().onUpdateClient((id, config) -> {
            if (id.equals(Identifier.of(AdorableHamsterPets.MOD_ID, "main"))) {
                ConfigDataCache.parseConfig();
                AdorableHamsterPets.LOGGER.info("Reloaded Adorable Hamster Pets item tag config on client following GUI update. *wink wink*");
            }
        });

        // --- Item Colors ---
        ColorHandlerRegistry.registerItemColors((stack, tintIndex) -> -1, ModItems.HAMSTER_SPAWN_EGG.get());

        // --- Networking Registration ---
        // On 1.20.1, register all  packets on both sides using the safe common method.
        ModPackets.registerCommonPackets();

        // --- Announcement System ---
        AHPClientScreenEvents.register();

        // --- Event Registrations ---
        ClientTickEvent.CLIENT_POST.register(AdorableHamsterPetsClient::onEndClientTick);
        ClientGuiEvent.RENDER_HUD.register((context, tickDelta) -> announcementHudRenderer.render(context, tickDelta));

        // --- Force-Mount Keybind Interaction ---
        InteractionEvent.INTERACT_ENTITY.register((player, entity, hand) -> {
            // Ensure we are on client and main hand to avoid double firing
            if (player.getWorld().isClient && hand == net.minecraft.util.Hand.MAIN_HAND && entity instanceof HamsterEntity hamster) {
                // Check if key is pressed AND config enabled
                if (Configs.AHP.enableShoulderMountKeybind && ModKeyBindings.FORCE_MOUNT_HAMSTER_KEY.isPressed()) {
                    // Only if it's tamed hamster and owned by player
                    if (hamster.isTamed() && hamster.isOwner(player)) {
                        // Send packet using the 1.20.1 NetworkChannel
                        ModPackets.CHANNEL.sendToServer(new ModPackets.RequestHamsterMountC2SPacket(hamster.getId()));
                        return EventResult.interruptTrue(); // Cancel default interaction to prevent sitting
                    }
                }
            }
            return EventResult.pass();
        });
    }

    /**
     * Registers the block entities. Separate because Forge needs to call it natively.
     */
    public static void initBlockEntityRenderers() {
        BlockEntityRendererRegistry.register(ModBlockEntities.HAMSTER_BED_BLOCK_ENTITY.get(), HamsterBedRenderer::new);
    }

    /**
     * Registers the screen factory. Separate because Forge needs to call it natively.
     */
    public static void initScreenHandlers() {
        MenuRegistry.registerScreenFactory(ModScreenHandlers.HAMSTER_INVENTORY_SCREEN_HANDLER.get(), HamsterInventoryScreen::new);
    }

    /**
     * Registers entity renderers. Called from a dedicated event handler.
     */
    public static void initEntityRenderers() {
        EntityRendererRegistry.register(ModEntities.HAMSTER, HamsterRenderer::new);
    }

    /* ──────────────────────────────────────────────────────────────────────────────
     *                       2. Event Listeners (Tick & Render)
     * ────────────────────────────────────────────────────────────────────────────*/

    /**
     * The main client-tick event handler.
     * Manages announcement animations, manifest refreshing, custom keybind logic (throwing/dismounting),
     * and render state cleanup to determine if entities are off-screen.
     *
     * @param client The Minecraft client instance.
     */
    private static void onEndClientTick(MinecraftClient client) {
        // --- 1. Announcement System Tick Logic ---
        boolean isGuiOpen = client.currentScreen != null;
        AnnouncementIconAnimator.INSTANCE.tick(isGuiOpen);

        // Sync Patchouli State (once per session after world load)
        if (client.world != null && !AnnouncementManager.INSTANCE.isPatchouliStateSynced()) {
            AnnouncementManager.INSTANCE.syncPatchouliReadState();
            // Once the sync is successful, also process any deferred read marks from the session.
            if (AnnouncementManager.INSTANCE.isPatchouliStateSynced()) {
                AnnouncementManager.INSTANCE.processDeferredReadMarks();
            }
        }

        if (client.world != null) {
            // Update the cached list of pending notifications once per tick.
            pendingNotifications = AnnouncementManager.INSTANCE.getPendingNotifications();
        }

        // Periodic Manifest Refresh
        if (--nextRefreshTicks <= 0) {
            nextRefreshTicks = 6000; // Reset timer
            AnnouncementManager.INSTANCE.refreshManifest(); // Fire and forget
            AdorableHamsterPets.LOGGER.debug("[AHP Client Tick] Triggered periodic manifest refresh.");
        }

        // --- 2. Input & Game Logic ---
        if (client.player == null || client.world == null) {
            renderedHamsterIdsThisTick.clear();
            renderedHamsterIdsLastTick.clear();
            return;
        }

        // Handle Throw Hamster Keybind
        if (ModKeyBindings.THROW_HAMSTER_KEY.wasPressed()) {
            final AhpConfig currentConfig = AdorableHamsterPets.CONFIG;
            if (!currentConfig.enableHamsterThrowing) {
                client.player.sendMessage(Text.translatable("message.adorablehamsterpets.throwing_disabled"), true);
            } else {
                boolean lookingAtReachableBlock = client.crosshairTarget != null && client.crosshairTarget.getType() == HitResult.Type.BLOCK;
                boolean hasShoulderHamsterClient = ((PlayerEntityAccessor) client.player).hasAnyShoulderHamster();

                if (!lookingAtReachableBlock && hasShoulderHamsterClient) {
                    // Send a typed packet for 1.20.1
                    ModPackets.CHANNEL.sendToServer(new ModPackets.ThrowHamsterC2SPacket());
                }
            }
        }

        // --- 3. Render State Tracking ---
        // Determines which hamsters stopped rendering this tick (went off-screen)
        Set<Integer> stoppedRendering = new HashSet<>(renderedHamsterIdsLastTick);
        stoppedRendering.removeAll(renderedHamsterIdsThisTick);

        for (Integer entityId : stoppedRendering) {
            // Send the render state update packet
            // Using ByteBuf because Architectury 1.20.1 helper logic for update packet
            PacketByteBuf buf = new PacketByteBuf(Unpooled.buffer());
            buf.writeInt(entityId);
            buf.writeBoolean(false); // isRendering = false
            // Send a typed packet for 1.20.1
            ModPackets.CHANNEL.sendToServer(new ModPackets.UpdateRenderStateC2SPacket(entityId, false));
        }

        renderedHamsterIdsLastTick.clear();
        renderedHamsterIdsLastTick.addAll(renderedHamsterIdsThisTick);
        renderedHamsterIdsThisTick.clear();

        // --- 4. Dismount Logic ---
        handleDismountKeyPress(client);
    }

    /* ──────────────────────────────────────────────────────────────────────────────
     *                            3. Logic Helpers
     * ────────────────────────────────────────────────────────────────────────────*/

    /**
     * Handles the client-side logic for dismounting a shoulder hamster.
     * <p>
     * This method is called every client tick. It checks the user's configuration to determine
     * which key to listen for (vanilla sneak or a custom keybind) and what press behavior
     * is required (single press or double-tap).
     *
     * @param client The MinecraftClient instance.
     */
    private static void handleDismountKeyPress(MinecraftClient client) {
        if (client.player == null || client.world == null) return;

        // --- 1. Shoulder state ---
        boolean hasShoulderHamster;
        try {
            hasShoulderHamster = ((PlayerEntityAccessor) client.player).hasAnyShoulderHamster();
        } catch (RuntimeException e) {
            // If the player entity's data tracker is corrupted (missing entries due to mod conflicts),
            // assume no hamster is present to prevent a crash.
            hasShoulderHamster = false;
        }

        // Detect the exact tick we JUST mounted (transition: false -> true)
        if (hasShoulderHamster && !hadShoulderHamsterLastTick) {
            // Drain any queued presses on BOTH possible bindings
            KeyBinding vanillaSneak = client.options.sneakKey;
            KeyBinding customDismount = ModKeyBindings.DISMOUNT_HAMSTER_KEY;

            if (vanillaSneak != null) {
                vanillaSneak.setPressed(false);
                while (vanillaSneak.wasPressed()) {}
            }
            if (customDismount != null) {
                customDismount.setPressed(false);
                while (customDismount.wasPressed()) {}
            }

            // Start a short debounce to ignore any immediate post-mount noise.
            dismountDebounceTicks = DISMOUNT_DEBOUNCE_DEFAULT;

            // Reset any double-tap state on fresh mount.
            isWaitingForSecondSneakPress = false;
        }

        // Remember shoulder state for next tick
        hadShoulderHamsterLastTick = hasShoulderHamster;

        // If no hamster, bail
        if (!hasShoulderHamster) {
            isWaitingForSecondSneakPress = false;
            return;
        }

        // Handle debounce
        if (dismountDebounceTicks > 0) {
            dismountDebounceTicks--;
            return;
        }

        final AhpConfig config = AdorableHamsterPets.CONFIG;

        // --- 2. Choose Key ---
        KeyBinding keyToListenFor;
        if (Configs.AHP.dismountTriggerType == DismountTriggerType.CUSTOM_KEYBIND) {
            keyToListenFor = ModKeyBindings.DISMOUNT_HAMSTER_KEY;
        } else { // SNEAK_KEY
            keyToListenFor = client.options.sneakKey;
        }

        // --- 3. Detect Press ---
        boolean wasKeyPressed = keyToListenFor != null && keyToListenFor.wasPressed();

        if (wasKeyPressed) {
            // --- 4. Apply Press Type Logic ---
            if (config.dismountPressType.get() == DismountPressType.SINGLE_PRESS) {
                // Single press always triggers the dismount
                // Send a typed packet for 1.20.1
                ModPackets.CHANNEL.sendToServer(new ModPackets.DismountHamsterC2SPacket());
            } else { // DOUBLE_TAP
                long currentTime = System.currentTimeMillis();
                long delayMillis = config.doubleTapDelayTicks.get() * 50L;

                if (isWaitingForSecondSneakPress && (currentTime - lastSneakPressTime) <= delayMillis) {
                    // Second press was within the delay window, trigger dismount
                    // Send a typed packet for 1.20.1
                    ModPackets.CHANNEL.sendToServer(new ModPackets.DismountHamsterC2SPacket());
                    isWaitingForSecondSneakPress = false; // Reset the double-tap state
                } else {
                    // First press
                    isWaitingForSecondSneakPress = true;
                    lastSneakPressTime = currentTime;
                }
            }
        }

        // --- 5. Timeout for Double Tap ---
        if (isWaitingForSecondSneakPress) {
            long currentTime = System.currentTimeMillis();
            long delayMillis = config.doubleTapDelayTicks.get() * 50L;
            if ((currentTime - lastSneakPressTime) > delayMillis) {
                isWaitingForSecondSneakPress = false;
            }
        }
    }

    /* ──────────────────────────────────────────────────────────────────────────────
     *                       4. Network Packet Handlers
     * ────────────────────────────────────────────────────────────────────────────*/

    /**
     * Handles the SyncShoulderData packet on the client.
     */
    public static void handleSyncShoulderData(int entityId, net.minecraft.nbt.NbtCompound data) {
        MinecraftClient client = MinecraftClient.getInstance();
        if (client.world != null) {
            net.minecraft.entity.Entity entity = client.world.getEntityById(entityId);
            if (entity instanceof net.dawson.adorablehamsterpets.accessor.PlayerEntityAccessor accessor) {
                accessor.adorablehamsterpets$setRawShoulderData(data);
            }
        }
    }

    /**
     * Handles the {@link ModPackets.SpawnBeddingParticlesS2CPacket} packet.
     * Spawns a burst of "floaty" leaf particles at the specified location.
     * Used by dispensers and the Hamster Bedding item.
     *
     * @param packet The packet data containing position, direction, and wood variant.
     */
    public static void handleSpawnBeddingParticles(ModPackets.SpawnBeddingParticlesS2CPacket packet) {
        MinecraftClient client = MinecraftClient.getInstance();
        if (client.world == null) return;

        BlockPos spawnPos = packet.pos().offset(packet.direction());
        Vec3d particleCenter = Vec3d.ofCenter(spawnPos);

        // Get the particle type. In 1.20.1, use DefaultParticleType instead of SimpleParticleType.
        DefaultParticleType particleType = ModParticles.getForVariant(packet.variant());

        for (int i = 0; i < 30; i++) {
            double offsetX = client.world.random.nextGaussian() * 1.2;
            double offsetY = client.world.random.nextGaussian() * 1.2;
            double offsetZ = client.world.random.nextGaussian() * 1.2;
            // Spawn the dynamic particle type and use the vy flag to trigger floaty physics
            client.world.addParticle(particleType,
                    particleCenter.x + offsetX, particleCenter.y + offsetY, particleCenter.z + offsetZ,
                    0, HamsterBeddingParticle.BEDDING_ITEM_FLAG, 0);
        }
    }

    /**
     * Handles the {@link ModPackets.PlayGuidebookEffectsS2CPacket} packet.
     * Plays sound effects, particles, and an action bar message when the guidebook
     * is retrieved via the config menu.
     */
    public static void handlePlayGuidebookEffects() {
        MinecraftClient client = MinecraftClient.getInstance();
        if (client == null) return;

        // Close config screen to un-pause game
        client.setScreen(null);

        PlayerEntity player = client.player;
        ClientWorld world = client.world;
        if (player == null || world == null) return;

        // Feedback
        player.sendMessage(Text.translatable("message.adorablehamsterpets.guidebook_rediscovered").formatted(Formatting.GOLD), true);
        world.playSound(player.getX(), player.getY(), player.getZ(), SoundEvents.BLOCK_ENCHANTMENT_TABLE_USE, SoundCategory.PLAYERS, 0.5f, 1.2f, false);
        world.playSound(player.getX(), player.getY(), player.getZ(), SoundEvents.ITEM_BOOK_PAGE_TURN, SoundCategory.PLAYERS, 0.7f, 1.5f, false);

        // Particles
        for (int i = 0; i < 50; i++) {
            world.addParticle(ParticleTypes.ENCHANT,
                    player.getParticleX(0.6), player.getRandomBodyY(), player.getParticleZ(0.6),
                    (world.random.nextDouble() - 0.5) * 0.5,
                    (world.random.nextDouble() - 0.5) * 0.5,
                    (world.random.nextDouble() - 0.5) * 0.5);
        }
        for (int i = 0; i < 20; i++) {
            world.addParticle(ParticleTypes.HAPPY_VILLAGER,
                    player.getParticleX(1.0), player.getRandomBodyY(), player.getParticleZ(1.0),
                    (world.random.nextDouble() - 0.5) * 0.5,
                    (world.random.nextDouble() - 0.5) * 0.5,
                    (world.random.nextDouble() - 0.5) * 0.5);
        }
    }

    /**
     * Handles the {@link ModPackets.PlayDistantSoundS2CPacket} packet.
     * Plays a sound at a specific location on the client, bypassing vanilla's distance attenuation checks
     * often imposed by ServerPlayerEntity#playSound, allowing "distant" sounds to be heard.
     *
     * @param packet The packet data containing sound ID, volume, and pitch.
     */
    public static void handlePlayDistantSound(ModPackets.PlayDistantSoundS2CPacket packet) {
        MinecraftClient client = MinecraftClient.getInstance();
        if (client.world == null || client.player == null) return;

        // Resolve the sound identifier to a SoundEvent (1.20.1 syntax)
        SoundEvent sound = SoundEvent.of(packet.soundId());

        // Play the sound at the PLAYER'S location to ensure audibility
        client.world.playSound(
                client.player.getX(),
                client.player.getY(),
                client.player.getZ(),
                sound,
                SoundCategory.NEUTRAL,
                packet.volume(),
                packet.pitch(),
                false // distanceDelay
        );
    }

    /* ──────────────────────────────────────────────────────────────────────────────
     *                       5. Trackers & Accessors
     * ────────────────────────────────────────────────────────────────────────────*/

    /**
     * Called by the renderer to track which entities are currently visible.
     * Used for optimizing network traffic related to rendering state.
     * @param entityId The ID of the rendered entity.
     */
    public static void onHamsterRendered(int entityId) {
        renderedHamsterIdsThisTick.add(entityId);
    }

    /**
     * Public getter for other client classes (like the HUD renderer and Widget)
     * to access the cached list of pending notifications.
     * @return The current list of pending notifications.
     */
    public static List<AnnouncementManager.PendingNotification> getPendingNotifications() {
        return pendingNotifications;
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/config/`
`AhpConfig.java`
All `@Translatable.Name` and `@Translatable.Desc` strings in this class are copied into `en_us.json` during the data generation process. That generated file is `.gitignore`d and is not included in this tech spec to avoid redundancy.
```java
package net.dawson.adorablehamsterpets.config;

// (Imports omitted to save token count)

@Translation(prefix = "adorablehamsterpets.main") // TODO: Remove @Translation annotation in Fzzy Config 0.7.4+ (See EnUsGenerator.java)
@Translatable.Name("Main Settings")
@Translatable.Desc("The command center for rodent-based chaos. Tweak physics, nerf cheese, and generally play god with small furry creatures.")

public class AhpConfig extends Config {

    public AhpConfig() {
        super(Identifier.of(AdorableHamsterPets.MOD_ID, "main"));

        // --- Two-Way Binding for Announcement Icon Toggles ---
        // This block ensures the master "Enable Announcements" toggle stays synchronized
        // with the individual "Enable HUD Icon" and "Enable GUI Widget Icon" toggles.

        // --- 1. Initial State Synchronization ---
        // On config load, set the master toggle's state based on the children.
        // If either the HUD icon OR the widget icon is enabled, the master toggle should show "ON".
        enableNotificationIcons.setAndUpdate(enableHudIcon.get() || enableWidgetIcon.get());

        // --- 2. Master -> Children Update Listener ---
        // When the master "Enable Announcements" toggle is changed by the user in the GUI...
        enableNotificationIcons.listenToEntry(ignored -> {
            // Re-entrancy guard: Prevents an infinite loop where listeners trigger each other.
            if (updatingAnnouncementToggles) return;
            updatingAnnouncementToggles = true;
            try {
                boolean masterValue = enableNotificationIcons.get();
                // Push the master state down to both individual toggles.
                enableHudIcon.setAndUpdate(masterValue);
                enableWidgetIcon.setAndUpdate(masterValue);
            } finally {
                updatingAnnouncementToggles = false;
            }
        });

        // --- 3. Children -> Master Update Listener ---
        // A single listener to handle changes from either of the individual toggles.
        var childListener = (java.util.function.Consumer<?>) ignored -> {
            if (updatingAnnouncementToggles) return;
            // Recalculate what the master toggle's state *should* be.
            boolean newMasterState = enableHudIcon.get() || enableWidgetIcon.get();
            // Only update the master if its current state is out of sync.
            if (enableNotificationIcons.get() != newMasterState) {
                enableNotificationIcons.setAndUpdate(newMasterState);
            }
        };

        // Attach the listener to both individual toggles.
        enableHudIcon.listenToEntry(e -> childListener.accept(null));
        enableWidgetIcon.listenToEntry(e -> childListener.accept(null));
    }

    // --- Help & Other Distractions ---
    @Translatable.Name("Help & Other Distractions")
    @Translatable.Desc("Buttons for when you’re lost, bored, or met a bug that’s not just existential hamster angst.")
    public ConfigGroup helpAndResources = new ConfigGroup("helpAndResources", false);

    @NonSync
    @Translatable.Name("I Lost My Book!")
    public ConfigAction giveGuideBook = new ConfigAction.Builder()
            .title(Text.translatable("config.adorablehamsterpets.main.helpAndResources.giveGuideBook"))
            .desc(Text.translatable("config.adorablehamsterpets.main.helpAndResources.giveGuideBook.desc"))
            .decoration(TextureIds.INSTANCE.getDECO_BOOK())
            .build(() -> {
                // On 1.20.1, use the ModPackets channel and the 1.20.1 inner packet record
                ModPackets.CHANNEL.sendToServer(new ModPackets.RequestGuidebookC2SPacket());
            });

    @NonSync
    @Translatable.Name("Report a Bug")
    public ConfigAction reportBug = new ConfigAction.Builder()
            .title(Text.translatable("config.adorablehamsterpets.main.helpAndResources.reportBug"))
            .desc(Text.translatable("config.adorablehamsterpets.main.helpAndResources.reportBug.desc"))
            .decoration(TextureIds.INSTANCE.getDECO_LINK())
            .build(new ClickEvent(ClickEvent.Action.OPEN_URL,
                    "https://github.com/DawsonBodenhamer/AdorableHamsterPets-Public/issues"));

    @NonSync
    @Translatable.Name("Join Discord")
    public ConfigAction joinDiscord = new ConfigAction.Builder()
            .title(Text.translatable("config.adorablehamsterpets.main.helpAndResources.joinDiscord"))
            .desc(Text.translatable("config.adorablehamsterpets.main.helpAndResources.joinDiscord.desc"))
            .decoration(TextureIds.INSTANCE.getDECO_BUTTON_CLICK())
            .build(new ClickEvent(ClickEvent.Action.OPEN_URL,
                    "https://discord.gg/w54mk5bqdf"));

    @NonSync
    @ConfigGroup.Pop
    @Translatable.Name("Visit My Website")
    public ConfigAction visitWebsite = new ConfigAction.Builder()
            .title(Text.translatable("config.adorablehamsterpets.main.helpAndResources.visitWebsite"))
            .desc(Text.translatable("config.adorablehamsterpets.main.helpAndResources.visitWebsite.desc"))
            .decoration(TextureIds.INSTANCE.getDECO_LINK())
            .build(new ClickEvent(ClickEvent.Action.OPEN_URL,
                    "https://www.fortheking.design"));

    // --- UI & Quality of Life ---
    @Translatable.Name("UI & Quality of Life")
    @Translatable.Desc("Because Sanity is Overrated")
    public ConfigGroup uiPreferences = new ConfigGroup("uiPreferences", true);

    @NonSync
    @Translatable.Name("Auto Guidebook Delivery")
    @Translatable.Desc("Hand-delivers the sacred texts on first login. Read it— or don’t. I'm not your conscience.")
    public boolean enableAutoGuidebookDelivery = true;

    @NonSync
    @Translatable.Name("Mod Item Tooltips")
    @Translatable.Desc("Helpful whispers on what the heck that cucumber is for.")
    public boolean enableItemTooltips = true;

    @NonSync
    @Translatable.Name("Shoulder Dismount Messages")
    @Translatable.Desc("Little status mumbles when your co-pilot disembarks.")
    public boolean enableShoulderDismountMessages = true;

    @NonSync
    @ConfigGroup.Pop
    @Translatable.Name("Jade Hamster Debug Info")
    @Translatable.Desc("More stats than anyone asked for. Defaults to off— mercifully.")
    public boolean enableJadeHamsterDebugInfo = false;

    // --- Announcements & Update Notes ---
    @Translatable.Name("Announcements & Update Notes")
    @Translatable.Desc("Tweak the little bell icon that appears when I have something important to tell you. Or turn if off if you hate fun.")
    public ConfigGroup announcements = new ConfigGroup("announcements", true);

    @NonSync
    @Translatable.Name("Enable Announcements")
    @Translatable.Desc("The master switch for all announcement notifications. Turning this off is the same as clicking 'Disable All' in the announcement screen. Announcements can still be viewed in the §f§lHamster Tips§r guide book.")
    public ValidatedBoolean enableNotificationIcons = new ValidatedBoolean(true); // plain boolean; with special functionality wired it up in the constructor

    // Re-entrancy guard so the listeners don’t bounce events back and forth forever.
    private boolean updatingAnnouncementToggles = false;

    @NonSync
    @Translatable.Name("Mark All as Read")
    public ConfigAction markAllAsRead = new ConfigAction.Builder()
            .title(Text.translatable("config.adorablehamsterpets.main.announcements.markAllAsRead"))
            .desc(Text.translatable("config.adorablehamsterpets.main.announcements.markAllAsRead.desc"))
            .decoration(TextureIds.INSTANCE.getADD())
            .build(() -> {
                // Custom runnable 'pressAction'
                AnnouncementManager.INSTANCE.markAllAsRead();
                if (MinecraftClient.getInstance().player != null) {
                    MinecraftClient.getInstance().player.sendMessage(
                            Text.translatable("message.adorablehamsterpets.announcements_marked_read").formatted(Formatting.GREEN),
                            false
                    );
                }
            });

    @NonSync
    @Translatable.Name("Announcement History")
    public ConfigAction resetAllAnnouncementDismissals = new ConfigAction.Builder()
            .title(Text.translatable("config.adorablehamsterpets.main.announcements.resetAllAnnouncementDismissals"))
            .desc(Text.translatable("config.adorablehamsterpets.main.announcements.resetAllAnnouncementDismissals.desc"))
            .decoration(TextureIds.INSTANCE.getRESTORE())
            .build(() -> {
                // Custom runnable 'pressAction'
                AnnouncementManager.INSTANCE.resetClientState();
                if (MinecraftClient.getInstance().player != null) {
                    MinecraftClient.getInstance().player.sendMessage(
                            Text.translatable("message.adorablehamsterpets.announcements_reset").formatted(Formatting.GREEN),
                            false
                    );
                }
            });

    @NonSync
    @Translatable.Name("Snooze Timer (Days)")
    @Translatable.Desc("For when you see the update notification and think, 'That's a problem for future me.' Future you will be so proud. This is where you select many days to hide the 'Update Available' notification when you click 'Remind Me Later'.")
    public ValidatedInt snoozeUpdateReminderDays = new ValidatedInt(5, 14, 1);

    @NonSync
    @Translatable.Name("HUD Icon Settings")
    @Translatable.Desc("Options for the little bell with hamster ears that just hangs out in the corner of your screen when notifications are pending.")
    public ConfigGroup hudIconSettings = new ConfigGroup("hudIconSettings", true);

    @NonSync
    @Translatable.Name("Enable HUD Icon")
    @Translatable.Desc("Decide if the bell haunts you full-time on the HUD or only ambushes you when you're trying to organize your inventory. If disabled, you will only see notifications when you open an inventory.")
    public ValidatedBoolean enableHudIcon = new ValidatedBoolean(true);

    private final ValidatedField<Boolean> isHudIconEnabled = enableHudIcon.map(b -> b, b -> b);

    @NonSync
    @Translatable.Name("HUD Icon Position Preset")
    @Translatable.Desc("Banish the bell to a corner of your choosing. It's your screen. Establish dominance.")
    public ValidatedCondition<IconPositionPreset> hudIconPositionPreset =
            new ValidatedEnum<>(IconPositionPreset.TOP_LEFT)
                    .toCondition(
                            isHudIconEnabled,
                            Text.translatable("config.adorablehamsterpets.condition.hud_icon_enabled"),
                            () -> IconPositionPreset.TOP_LEFT
                    );

    @NonSync
    @Translatable.Name("HUD Icon Offset X")
    @Translatable.Desc("Shove the icon horizontally. For when 'top-left' isn't specific enough for your discerning taste.")
    public ValidatedCondition<Integer> hudIconOffsetX =
            new ValidatedInt(10, 500, -500)
                    .toCondition(
                            isHudIconEnabled,
                            Text.translatable("config.adorablehamsterpets.condition.hud_icon_enabled"),
                            () -> 10
                    );

    @NonSync
    @Translatable.Name("HUD Icon Offset Y")
    @Translatable.Desc("Adjust the vertical placement. Does it block your view? Is it not blocking your view enough? The power is yours.")
    public ValidatedCondition<Integer> hudIconOffsetY =
            new ValidatedInt(10, 500, -500)
                    .toCondition(
                            isHudIconEnabled,
                            Text.translatable("config.adorablehamsterpets.condition.hud_icon_enabled"),
                            () -> 10
                    );

    @NonSync
    @ConfigGroup.Pop
    @Translatable.Name("HUD Icon Scale")
    @Translatable.Desc("Make it bigger. Make it smaller. Make it an affront to good taste. I'm not your art director.")
    public ValidatedCondition<Float> hudIconScale =
            new ValidatedFloat(1.0f, 3.0f, 0.5f)
                    .toCondition(
                            isHudIconEnabled,
                            Text.translatable("config.adorablehamsterpets.condition.hud_icon_enabled"),
                            () -> 1.0f
                    );

    @NonSync
    @Translatable.Name("Widget Icon Settings")
    @Translatable.Desc("Configure the bell with hamster ears that haunts the corners of your inventory screens.")
    public ConfigGroup widgetIconSettings = new ConfigGroup("widgetIconSettings", true);

    @NonSync
    @Translatable.Name("Enable GUI Widget Icon")
    @Translatable.Desc("Decide if the bell icon should ambush you while you're sorting your inventory. If disabled, it will only bother you on the main menu or the game HUD if you have those enabled. Your screen, your rules.")
    public ValidatedBoolean enableWidgetIcon = new ValidatedBoolean(true);

    private final ValidatedField<Boolean> isWidgetIconEnabled = enableWidgetIcon.map(b -> b, b -> b);

    /**
     * A Plain-Old-Java-Object (POJO) to encapsulate the X and Y offset settings
     * for the announcement icon widget. This is wrapped by ValidatedAny to create
     * a pop-up "mini-config" screen.
     * <p>
     * NOTE FOR FUTURE SELF:
     * Without @Translation, each instance would look up separate, instance-specific
     * lang keys (based on the field path), or fall back to the annotation text.
     * <p>
     * Adding @Translation with a shared prefix forces BOTH instances to use the same
     * language keys:
     *   adorablehamsterpets.main.widgetIconOffsets.offsetX(.desc)
     *   adorablehamsterpets.main.widgetIconOffsets.offsetY(.desc)
     * This keeps the lang file DRY and guarantees consistent labels/tooltips across
     * all WidgetIconOffsets popups.
     */
    @Translation(prefix = "adorablehamsterpets.main.widgetIconOffsets")
    public static class WidgetIconOffsets {
        @NonSync
        @Translatable.Name("Offset X")
        @Translatable.Desc("Shove it sideways (in pixels). Increase the number to move it right, decrease to move left.")
        public ValidatedInt offsetX = new ValidatedInt(0, 500, -500);

        @NonSync
        @Translatable.Name("Offset Y")
        @Translatable.Desc("Shove it vertically (in pixels). Increase the number to move it down, decrease to move up.")
        public ValidatedInt offsetY = new ValidatedInt(0, 500, -500);
    }

    @NonSync
    @Translatable.Name("Survival Inventory")
    @Translatable.Desc("Control the icon's placement for standard GUIs. Because nothing says 'immersion' like a perfectly aligned notification bell. Position is relative to the GUI's top-right corner.")
    public ValidatedCondition<WidgetIconOffsets> survivalWidgetIconSettings =
            new ValidatedAny<>(new WidgetIconOffsets())
                    .toCondition(
                            isWidgetIconEnabled,
                            Text.translatable("config.adorablehamsterpets.condition.widget_icon_enabled"),
                            WidgetIconOffsets::new
                    );

    @NonSync
    @ConfigGroup.Pop
    @ConfigGroup.Pop
    @Translatable.Name("Creative Inventory")
    @Translatable.Desc("Control the icon's placement for the creative mode GUI. Because nothing says 'immersion' like a perfectly aligned notification bell. Position is relative to the GUI's top-right corner.")
    public ValidatedCondition<WidgetIconOffsets> creativeWidgetIconSettings =
            new ValidatedAny<>(new WidgetIconOffsets())
                    .toCondition(
                            isWidgetIconEnabled,
                            Text.translatable("config.adorablehamsterpets.condition.widget_icon_enabled"),
                            WidgetIconOffsets::new
                    );


    // --- Falling Leaf Settings ---
    @Translatable.Name("Falling Leaf Settings")
    @Translatable.Desc("Here's where you tweak the behavior of the floaty leaf particles spawned from Hamster Bedding. Didn't know you could spawn particles from Hamster Bedding? Try to keep up.")
    public ConfigGroup particleEffects = new ConfigGroup("particleEffects", true);

    @NonSync
    @Translatable.Name("Dynamic Drift")
    @Translatable.Desc("Should the gentle, drift of Hamster Bedding leaf particles slowly change direction over time? If true, it's a slow, majestic rotation. (It takes a bout 3 minutes to make a full 360 degree rotation). If false, you get to pick a static wind direction below.")
    public ValidatedBoolean enableDynamicDriftAngle = new ValidatedBoolean(true);

    // Helper field to gate the static angle slider. This is true when the dynamic toggle is OFF.
    private final ValidatedField<Boolean> isDynamicDriftDisabled =
            enableDynamicDriftAngle.map(value -> !value, value -> !value);

    @NonSync
    @ConfigGroup.Pop
    @Translatable.Name("Static Drift Angle")
    @Translatable.Desc("Set a fixed direction for the universal leaf drift (0-360 degrees). 0/360 is East, 90 is South, 180 is West, 270 is North, I think. Or just slide it until it looks cool. Whatever. Only works if 'Dynamic Drift' is off.")
    public ValidatedCondition<Integer> staticDriftAngle =
            new ValidatedInt(0, 360, 0)
                    .toCondition(
                            isDynamicDriftDisabled,
                            Text.translatable("config.adorablehamsterpets.condition.dynamic_drift_off"),
                            () -> 0
                    );

    // --- Core Feature Toggles ---
    @Translatable.Name("Core Feature Toggles")
    @Translatable.Desc("Fundamental hamster hijinks— fiddle at your own risk.")
    public ConfigGroup core = new ConfigGroup("core", true);

    @Translatable.Name("Enable Hamster Throwing")
    @Translatable.Desc("Do we yeet the hamster? ('G' by default).")
    public boolean enableHamsterThrowing = true;

    @Translatable.Name("Enable Wander Mode")
    @Translatable.Desc("For when you need some personal space. Allows tamed hamsters to be linked to a Hamster Bed, letting them wander freely within a set radius instead of clinging to you like melted duct-tape. You're welcome.")
    public ValidatedBoolean enableWanderMode = new ValidatedBoolean(true);

    @Translatable.Name("Require Food Mix to Unlock Cheeks")
    @Translatable.Desc("Gate cheek-pouch storage behind gourmet cuisine, because drama.")
    public boolean requireFoodMixToUnlockCheeks = true;

    @Translatable.Name("Use 'Hampter' as Default Name")
    @Translatable.Desc("Changes the default entity name from 'Hamster' to 'Hampter'. Note: This has no visible effect in vanilla Minecraft, as mobs don't show nameplates by default. It's primarily for use with mods like Auto Leveling that display entity names.")
    public boolean useHampterName = false;

    @Translatable.Name("Mob Interactions")
    @Translatable.Desc("Configure how hamsters interact with (or terrify) other creatures.")
    public ConfigGroup mobInteractions = new ConfigGroup("mobInteractions", true);

    @Translatable.Name("Frighten Ravagers")
    @Translatable.Desc("Should Ravagers, the hulking beasts of destruction, flee in terror from a tiny ball of fluff? Yes. Yes, they should.")
    public boolean enableRavagerFlee = true;

    @ConfigGroup.Pop
    @ConfigGroup.Pop
    @Translatable.Name("Frighten Spiders")
    @Translatable.Desc("Turns your hamster into a mobile arachnid-repellent unit. Highly effective.")
    public boolean enableSpiderFlee = true;

    // --- Core Cooldown Settings ---
    @Translatable.Name("Core Cooldown Settings")
    @Translatable.Desc("Mandatory hamster union breaks between heroic stunts.")
    public ConfigGroup cooldowns = new ConfigGroup("cooldowns", true);

    @Translatable.Name("Cleaning Frequency")
    @Translatable.Desc("How often a sitting hamster gets the sudden urge to clean. It's a 1-in-X chance per tick, so lower numbers mean a higher chance for cleaning. For example, 1200 means on average, it'll clean about once a minute. 300 ≈ every 15 secs, and 5000 ≈ every 4 mins. Congratulations— now you know enough to be dangerous.")
    public ValidatedInt cleaningChanceDenominator = new ValidatedInt(1200, 5000, 300);

    @Translatable.Name("Throw Cooldown")
    @Translatable.Desc("Time-out after using your living projectile. (20 ticks = 1 s)")
    public ValidatedInt hamsterThrowCooldown = new ValidatedInt(2400, 20 * 60 * 10, 20);

    @Translatable.Name("Green Bean Buff Cooldown")
    @Translatable.Desc("When the sugar rush ends, force a breather. (20 ticks = 1 s)")
    public ValidatedInt steamedGreenBeansBuffCooldown = new ValidatedInt(6000, 20 * 60 * 10, 20);

    @Translatable.Name("Diamond Seeking Cooldown")
    @Translatable.Desc("Force a cool-down after striking it rich. Off by default, since this can't happen again anyway without another mount/dismount on the shoulder.")
    public boolean enableIndependentDiamondSeekCooldown = false;

    @Translatable.Name("Diamond Seeking Cooldown")
    @Translatable.Desc("Cooldown before your hamster can go on another treasure hunt. (20 ticks = 1 s)")
    public ValidatedInt independentOreSeekCooldownTicks = new ValidatedInt(2400, 6000, 20);

    @Translatable.Name("Diamond Thievery Cooldown")
    @Translatable.Desc("Mandatory time-out after a successful heist to prevent serial kleptomania. (20 ticks = 1s). WARNING: Increasing this cooldown can dramatically change the diamond stealing mechanic, since that AI goal sometimes re-runs multiple times in a row when the hamster has trouble pathfinding to the item that it wants to steal. So instead of increasing this, you should probably just stop dropping your diamonds on the ground everywhere, butter fingers.")
    public ValidatedInt stealCooldownTicks = new ValidatedInt(100, 6000, 20);

    @ConfigGroup.Pop
    @Translatable.Name("Breeding Cooldown")
    @Translatable.Desc("Hamsters need their space. (20 ticks = 1 s)")
    public ValidatedInt breedingCooldownTicks = new ValidatedInt(6000, 24000, 600);

    // --- Core Item Tag Overrides ---
    @Translatable.Name("Core Item Tag Overrides")
    @Translatable.Desc("For the advanced user who looks at a perfectly functional system and thinks, 'I can make this weirder.' Edit these lists to change what items your hamsters consider food, bait, treasure, and all other interactions. Use item IDs (e.g., 'minecraft:diamond') or tags (e.g., '#minecraft:fishes'). Mess it up? That's a you problem.")
    public ConfigGroup itemTags = new ConfigGroup("itemTags", true);

    @Translatable.Name("Taming Baits")
    @Translatable.Desc("The official list of bribes for convincing wild fluffballs to join your cause. By default, it's just sliced cucumbers. Feel free to add 'minecraft:nether_star' if you enjoy making poor life choices. Compatible with Cultural Delights by default!")
    public List<String> tamingFoods = new ArrayList<>(List.of("adorablehamsterpets:sliced_cucumber", "culturaldelights:cut_cucumber"));

    @Translatable.Name("Standard Diet")
    @Translatable.Desc("The hamster's everyday menu. These items will heal them or, if they're at full health, might give them... ideas about starting a family. Don't make it weird.")
    public List<String> standardFoods = new ArrayList<>(List.of(
            "adorablehamsterpets:hamster_food_mix", "adorablehamsterpets:sunflower_seeds", "adorablehamsterpets:green_beans",
            "adorablehamsterpets:cucumber", "adorablehamsterpets:green_bean_seeds", "adorablehamsterpets:cucumber_seeds",
            "minecraft:apple", "minecraft:carrot", "minecraft:melon_slice", "minecraft:sweet_berries",
            "minecraft:beetroot", "minecraft:wheat", "minecraft:wheat_seeds",

            // Farmer's Delight
            "farmersdelight:cabbage_leaf", "farmersdelight:cabbage_seeds",
            "farmersdelight:tomato_seeds", "farmersdelight:cooked_rice",
            "farmersdelight:pumpkin_slice",

            // Cultural Delights
            "culturaldelights:cut_cucumber", "culturaldelights:cucumber_seeds", "culturaldelights:corn_kernels"
    ));

    @Translatable.Name("High-Value Heistables")
    @Translatable.Desc("The list of items a hamster might try to... 'borrow' if you leave them on the ground. A chase will ensue. You have been warned.")
    public List<String> stealableItems = new ArrayList<>(List.of("minecraft:diamond"));

    @Translatable.Name("Performance-Enhancers")
    @Translatable.Desc("The list of questionable substances that grant your hamster temporary superpowers. By default, it's just steamed green beans.")
    public List<String> buffFoods = new ArrayList<>(List.of("adorablehamsterpets:steamed_green_beans"));

    @Translatable.Name("Lure Items")
    @Translatable.Desc("The specific items that convince a tamed hamster your shoulder is the best seat in the house. Also acts as a bribe to lure them into their linked bed. Defaults to cheese, because of course it does.")
    public List<String> lureItems = new ArrayList<>(List.of("adorablehamsterpets:cheese"));

    @Translatable.Name("Rodent Repellent")
    @Translatable.Desc("The list of specific items that, when used on a Hamster Bed, will set 'Wander Mode Settings > Allow Sleeping in Bed' to false. For when you need your hamster to stay awake and wander around for... reasons. This can be reversed by using a lure item (cheese by default) on the bed. Sneaking before right-clicking with this item will unlink the bed entirely.")
    public List<String> bedAvoidanceFoods = new ArrayList<>(List.of("minecraft:rotten_flesh"));

    @Translatable.Name("Cheek Pouch Keys")
    @Translatable.Desc("The one-time offering required to earn a hamster's ultimate trust, unlocking their cheek inventory. Make it something special. Or don't. See if I care.")
    public List<String> pouchUnlockFoods = new ArrayList<>(List.of("adorablehamsterpets:hamster_food_mix"));

    @Translatable.Name("Picky Eater Solutions")
    @Translatable.Desc("Items on this list are so delicious, your hamster will never refuse them, even if you feed it to them twice. For the truly spoiled rodent.")
    public List<String> repeatableFoods = new ArrayList<>(List.of("adorablehamsterpets:hamster_food_mix", "adorablehamsterpets:steamed_green_beans"));

    @Translatable.Name("Passively Munchable Snacks")
    @Translatable.Desc("The specific items a hamster will eat directly from its cheek pouch to heal itself when injured. Keep it exclusive, or let them feast on enchanted apples. Your call.")
    public List<String> autoHealFoods = new ArrayList<>(List.of("adorablehamsterpets:hamster_food_mix"));

    @Translatable.Name("Cheek Pouch Smuggling List")
    @Translatable.Desc("Fine-tune exactly what your hamster is (and isn't) allowed to carry. The 'Allowed' list acts as a high-priority override to the 'Disallowed' lists and general rules.")
    public ConfigGroup pouchRestrictions = new ConfigGroup("pouchRestrictions", true);

    @Translatable.Name("Allowed Items")
    @Translatable.Desc("A specific list of items and tags that are allowed in the hamster's cheek pouch. You can add things to this list to bypass the default 'no tools or big blocks' rule, since this overrides the 'disallowed' settings.")
    public List<String> pouchAllowedItems = new ArrayList<>(List.of(
            "minecraft:torch", "minecraft:soul_torch", "minecraft:redstone_torch",
            "minecraft:repeater", "minecraft:comparator", "minecraft:lever",
            "#minecraft:buttons", "#minecraft:rails",
            "#minecraft:pressure_plates"
    ));

    @Translatable.Name("Pouch Disallowed Items")
    @Translatable.Desc("A list of specific item IDs that are NEVER allowed in the cheek pouch, unless they are on the 'Allowed' list above. Mostly stuff that's too big, too pointy, or just plain illogical. Lol.")
    public List<String> pouchDisallowedItems = new ArrayList<>(List.of(
            "minecraft:bow", "minecraft:crossbow", "minecraft:trident", "minecraft:fishing_rod",
            "minecraft:shield", "minecraft:elytra", "minecraft:turtle_helmet", "minecraft:carved_pumpkin",
            "minecraft:player_head", "minecraft:zombie_head", "minecraft:skeleton_skull", "minecraft:wither_skeleton_skull", "minecraft:creeper_head", "minecraft:dragon_head", "minecraft:piglin_head",
            "minecraft:minecart", "minecraft:chest_minecart", "minecraft:furnace_minecart", "minecraft:tnt_minecart", "minecraft:hopper_minecart", "minecraft:command_block_minecart",
            "minecraft:saddle", "minecraft:bucket", "minecraft:water_bucket", "minecraft:lava_bucket", "minecraft:milk_bucket", "minecraft:powder_snow_bucket",
            "minecraft:axolotl_bucket", "minecraft:tadpole_bucket", "minecraft:cod_bucket", "minecraft:pufferfish_bucket", "minecraft:salmon_bucket", "minecraft:tropical_fish_bucket",
            "minecraft:item_frame", "minecraft:glow_item_frame", "minecraft:painting", "minecraft:armor_stand",
            "minecraft:end_crystal", "minecraft:spyglass", "minecraft:nether_star", "minecraft:dragon_egg", "minecraft:bundle",
            "adorablehamsterpets:hamster_guide_book"
    ));

    @ConfigGroup.Pop
    @ConfigGroup.Pop
    @Translatable.Name("Pouch Disallowed Tags")
    @Translatable.Desc("A list of item tags that are NEVER allowed in the cheek pouch, unless they are on the 'Allowed' list above. A broad-spectrum approach to preventing your hamster from swallowing an entire sword.")
    public List<String> pouchDisallowedTags = new ArrayList<>(List.of(
            "#minecraft:axes", "#minecraft:hoes", "#minecraft:pickaxes", "#minecraft:shovels", "#minecraft:swords",
            "#minecraft:trimmable_armor", "#minecraft:beds", "#minecraft:banners", "#minecraft:doors",
            "#minecraft:boats"
    ));

    // --- Core Hamster Attributes ---
    @Translatable.Name("Core Hamster Attributes")
    @Translatable.Desc("All the knobs and dials that make your hamster the majestic (or chaotic) creature it is.")
    public ConfigGroup hamsterAttributes = new ConfigGroup("hamsterAttributes", true);

    @Translatable.Name("Max Health (Wild)")
    @Translatable.Desc("How much abuse a wild hamster can take before it gives up the ghost. Vanilla animals are around 8-10. Set it to 200 (100 hearts) if you enjoy a challenge, or 1 if you're a monster.")
    public ValidatedDouble wildMaxHealth = new ValidatedDouble(8.0, 200.0, 1.0);

    @Translatable.Name("Max Health (Tamed)")
    @Translatable.Desc("How beefy your tamed fuzzball is. Defaults to double its wild health, because love makes you stronger. Or something. Vanilla wolves have 20 (10 hearts).")
    public ValidatedDouble tamedMaxHealth = new ValidatedDouble(16.0, 200.0, 1.0);

    @Translatable.Name("Taming Chance")
    @Translatable.Desc("Convince a hamster to love you. Taming difficulty (1 in X chance). Higher = more cucumbers sacrificed to fuzzy freeloaders.")
    public ValidatedInt tamingChanceDenominator = new ValidatedInt(3, 20, 1);

    @Translatable.Name("Melee Damage")
    @Translatable.Desc("Tamed hamster melee damage. Squeak-first, ask questions later.")
    public ValidatedDouble meleeDamage = new ValidatedDouble(2.0, 40.0, 0.0);

    @ConfigGroup.Pop
    @Translatable.Name("Throw Damage")
    @Translatable.Desc("Damage dealt by thrown hamster. Surprisingly effective against Creepers. How convenient.")
    public ValidatedDouble hamsterThrowDamage = new ValidatedDouble(20.0, 40.0, 0.0);

    // --- Bed & Wander Mode Settings ---
    @Translatable.Name("Bed & Wander Mode Settings")
    @Translatable.Desc("For when 'following you into lava' is no longer a desirable trait. Tweak the settings for your hamster's newfound, bed-based independence.")
    public ConfigGroup wanderMode = new ConfigGroup("wanderMode", true);

    @Translatable.Name("Avoid Unlinked Beds")
    @Translatable.Desc("Should hamsters treat other hamsters' beds as sacred ground? If true, they'll try to politely path around them, but they will only try a few alternate paths before their tiny rodent-patience runs out. If false, they'll trample wherever they please.")
    public boolean avoidUnlinkedBeds = true;

    @Translatable.Name("Default Wander Distance")
    @Translatable.Desc("The initial wander distance set when a hamster is first linked to a bed. It defaults to medium, because that is the universally accepted starting point for all life choices.")
    public ValidatedEnum<WanderDistance> defaultWanderDistance = new ValidatedEnum<>(WanderDistance.MEDIUM);

    @Translatable.Name("Distance: Near")
    @Translatable.Desc("The radius (in blocks) for the 'Near' wander distance setting. For the clingy hamster who wants freedom, but not too much.")
    public ValidatedInt wanderDistanceNear = new ValidatedInt(8, 64, 1);

    @Translatable.Name("Distance: Medium")
    @Translatable.Desc("The radius (in blocks) for the 'Medium' wander distance setting. A respectable distance. Not too close, not too far. Perfectly balanced, as all things should be.")
    public ValidatedInt wanderDistanceMedium = new ValidatedInt(16, 64, 1);

    @Translatable.Name("Distance: Far")
    @Translatable.Desc("The radius (in blocks) for the 'Far' wander distance setting. For the adventurous hamster who might send you a postcard someday. Maybe.")
    public ValidatedInt wanderDistanceFar = new ValidatedInt(32, 64, 1);

    @Translatable.Name("Bed Break Notification")
    @Translatable.Desc("Get an action bar message when your hamster's bed is broken. Here's where you can turn it off if you prefer... complete immersion.")
    public boolean enableBedBreakMessage = true;

    @Translatable.Name("Allow Sleeping in Bed")
    @Translatable.Desc("The global override for whether hamsters can sleep in their beds. If enabled, all hamsters in wander mode will seek out their bed to sleep at specific times, regardless of individual bed settings. If disabled, they'll just pass out when sitting, like your old uncle at family gatherings.")
    public ValidatedBoolean allowSleepInBed = new ValidatedBoolean(true);

    // Helper field to gate all other sleep settings
    private final ValidatedField<Boolean> isSleepInBedAllowed = allowSleepInBed.map(b -> b, b -> b);

    @Translatable.Name("Circadian Chaos")
    @Translatable.Desc("Tired of your hamsters adhering to the rigid tyranny of the day/night cycle? Enable this for a more... unpredictable napping schedule. When enabled, this will override the 'Sleep During the Day' setting.")
    public ValidatedCondition<Boolean> circadianChaos = new ValidatedBoolean(false)
            .toCondition(
                    isSleepInBedAllowed,
                    Text.translatable("config.adorablehamsterpets.condition.sleep_in_bed_allowed"),
                    () -> false
            );

    // Helper field to gate the min and max time settings
    private final ValidatedField<Boolean> isCircadianChaosEnabled = circadianChaos.map(b -> b, b -> b);

    @Translatable.Name("Min Nap Interval")
    @Translatable.Desc("The shortest possible time (in seconds) a hamster will stay awake or asleep in bed before considering a change. Defaults to 5 minutes— for the truly narcoleptic rodent. A random duration between the min and max is chosen each time, so move them further apart for more... unpredictable behavior.")
    public ValidatedCondition<Integer> minNapInBedIntervalSeconds  = new ValidatedInt(300, 7000, 5)
            .toCondition(
                    () -> allowSleepInBed.get() && circadianChaos.get(),
                    Text.translatable("config.adorablehamsterpets.condition.circadian_chaos_on"),
                    () -> 300
            );

    @Translatable.Name("Max Nap Interval")
    @Translatable.Desc("The longest amount of time (in seconds) a hamster can possibly stay awake or asleep in bed before it gets bored and switches things up. Defaults to 10 minutes.")
    public ValidatedCondition<Integer> maxNapInBedIntervalSeconds = new ValidatedInt(600, 7200, 10)
            .toCondition(
                    () -> allowSleepInBed.get() && circadianChaos.get(),
                    Text.translatable("config.adorablehamsterpets.condition.circadian_chaos_on"),
                    () -> 900
            );

    @Translatable.Name("Sleep During the Day")
    @Translatable.Desc("If false, wandering hamsters will sleep in their beds during the night. If true, they'll adopt a more nocturnal, goth-adjacent lifestyle and sleep in the daytime.")
    public ValidatedCondition<Boolean> sleepDuringDay = new ValidatedBoolean(true)
            .toCondition(
                    () -> allowSleepInBed.get() && !circadianChaos.get(),
                    Text.translatable("config.adorablehamsterpets.condition.circadian_chaos_overrides"),
                    () -> true
            );

    @ConfigGroup.Pop
    @Translatable.Name("Manual Wake-Up Duration")
    @Translatable.Desc("The mandatory grumpiness period if you rudely awaken a hamster from its bed before it was ready. It won't go back to sleep until this timer runs out. (20 ticks = 1 second)")
    public ValidatedCondition<Integer> bedWakeUpCooldown = new ValidatedInt(300, 1200, 20)
            .toCondition(
                    isSleepInBedAllowed,
                    Text.translatable("config.adorablehamsterpets.condition.sleep_in_bed_allowed"),
                    () -> 300
            );

    // --- Shoulder Hamster Settings ---
    @Translatable.Name("Shoulder Hamster Settings")
    @Translatable.Desc("Settings for your fuzzy parrot of doom.")
    public ConfigGroup shoulder = new ConfigGroup("shoulder", true);

    @Translatable.Name("Core Settings")
    @Translatable.Desc("Just the basic stuff. You know, detecting creepers, sniffing diamonds. Just average Minecraft stuff really. No big deal. Why are you clapping and squealing? Stop that. You look silly.")
    public ConfigGroup shoulderCore = new ConfigGroup("shoulderCore", true);

    @Translatable.Name("Retain Shoulder Mounts")
    @Translatable.Desc("If true, any hamsters on your shoulder will remain there when you respawn. If false (default), they will remain at your death location, passed out from the sheer shock of seeing you die. They may need a quick pat to wake them up when you return.")
    public boolean keepHamstersOnShoulderOnDeath = false;

    @Translatable.Name("Consume Lure Item")
    @Translatable.Desc("Should luring a hamster to your shoulder consume the item (e.g., cheese)? Turn this off if you believe your charm alone should be enough. The item will still be required, just not eaten.")
    public boolean consumeLureItem = true;

    @Translatable.Name("Enable Force-Mount Keybind")
    @Translatable.Desc("Tired of wasting perfectly good cheese? Enable this to use a dedicated keybind (unbound by default). Hold down this key while right-clicking your hamster to hoist them onto your shoulder, no questions asked. Uses a separate key you must set in Settings > Controls > Key Binds.")
    public boolean enableShoulderMountKeybind = false;

    @NonSync
    @Translatable.Name("Enable Creeper Detection")
    @Translatable.Desc("May save your inventory. Or your ears.")
    public boolean enableShoulderCreeperDetection = true;

    @NonSync
    @Translatable.Name("Creeper Detection Radius")
    @Translatable.Desc("Adjust paranoia levels. (Distance in blocks)")
    public ValidatedDouble shoulderCreeperDetectionRadius = new ValidatedDouble(16.0, 16.0, 1.0);

    @NonSync
    @Translatable.Name("Enable Diamond Detection")
    @Translatable.Desc("Because who doesn’t enjoy unsolicited financial advice from a rodent?")
    public boolean enableShoulderDiamondDetection = true;

    @NonSync
    @ConfigGroup.Pop
    @Translatable.Name("Diamond Detection Radius")
    @Translatable.Desc("How close (in blocks) you need to be before the squeak says \"bling.\"")
    public ValidatedDouble shoulderDiamondDetectionRadius = new ValidatedDouble(10.0, 20.0, 5.0);

    @Translatable.Name("Dismount Settings")
    @Translatable.Desc("Here's where you decide how to get the little rascals off your shoulders. Warning: they can be clingy.")
    public ConfigGroup shoulderDismount = new ConfigGroup("shoulderDismount", true);

    @NonSync
    @Translatable.Name("Dismount Order")
    @Translatable.Desc("Determines the sequence for dismounting hamsters with a key press. LIFO (Last-In, First-Out) dismounts the most recently added hamster. FIFO (First-In, First-Out) dismounts the oldest one.")
    public ValidatedEnum<DismountOrder> dismountOrder = new ValidatedEnum<>(DismountOrder.LIFO);

    @NonSync
    @Translatable.Name("Dismount Button")
    @Translatable.Desc("Choose what action dismounts the hamster. 'SNEAK_KEY' uses your sneak key, obviously. 'CUSTOM_KEYBIND' uses a separate key you must set in Controls > Key Binds.")
    public DismountTriggerType dismountTriggerType = DismountTriggerType.SNEAK_KEY;

    @NonSync
    @Translatable.Name("Button‑Press Behavior")
    @Translatable.Desc("Choose whether a single press or a quick double‑tap dismounts the hamster.")
    public ValidatedEnum<DismountPressType> dismountPressType =
            new ValidatedEnum<>(DismountPressType.SINGLE_PRESS);

    private final ValidatedField<Boolean> isDoubleTap =
            dismountPressType.map(
                    pt -> pt == DismountPressType.DOUBLE_TAP,
                    b -> b ? DismountPressType.DOUBLE_TAP : DismountPressType.SINGLE_PRESS
            );

    @NonSync
    @ConfigGroup.Pop
    @Translatable.Name("Double-Tap Delay")
    @Translatable.Desc("Max time between sneak key presses to count as a double-tap. (20 ticks = 1 second)")
    public ValidatedCondition<Integer> doubleTapDelayTicks =
            new ValidatedInt(10, 40, 5)
                    .toCondition(
                            isDoubleTap,
                            Text.translatable("config.adorablehamsterpets.condition.double_tap"),
                            () -> 10
                    );

    @NonSync
    @Translatable.Name("Animation Settings")
    @Translatable.Desc("Control how lively your shoulder-mounted companions are. I mean, I don't like to toot my own horn or anything, but this is pretty great. Now please excuse me while I bask in my humility.")
    public ConfigGroup shoulderAnimations = new ConfigGroup("shoulderAnimations", true);

    @NonSync
    @Translatable.Name("Enable Dynamic Animations")
    @Translatable.Desc("If true, hamsters on your shoulder will randomly cycle through standing, sitting, and laying down while on the shoulder. If false, they will remain in a single state defined below.")
    public ValidatedBoolean enableDynamicShoulderAnimations = new ValidatedBoolean(true);

    private final ValidatedField<Boolean> dynamicShoulderDisabled =
            enableDynamicShoulderAnimations.map(
                    value -> !value,
                    value -> !value
            );

    @NonSync
    @Translatable.Name("Forced Animation State")
    @Translatable.Desc("If dynamic animations are disabled, choose the single state shoulder pets should remain in. Sometimes this setting can have a delay before kicking in, but if it doesn't seem to be working at all, try switching the 'Forced State' from one option to another. Usually this just makes it \"work.\" I'm not sure why lol")
    public ValidatedCondition<ForcedShoulderState> forcedShoulderState =
            new ValidatedEnum<>(ForcedShoulderState.ALWAYS_STAND)
                    .toCondition(
                            // use the inverted validated field as the gating condition
                            dynamicShoulderDisabled,
                            // message shown when the condition fails
                            Text.translatable("config.adorablehamsterpets.condition.dynamic_shoulder_off"),
                            // fallback when the condition fails
                            () -> ForcedShoulderState.ALWAYS_STAND
                    );

    @NonSync
    @Translatable.Name("Force Lay Down on Walk")
    @Translatable.Desc("False by default. If true, shoulder hamsters will be forced into their 'laying down' animation when you move, as if trying not to fall off. If false, they will continue their normal animation cycle.")
    public boolean forceLayDownOnWalk = false;

    @NonSync
    @Translatable.Name("Force Lay Down on Sprint")
    @Translatable.Desc("If true, shoulder hamsters will be forced into their 'laying down' animation while you sprint, as if holding on for dear life. If false, they will continue their normal animation cycle.")
    public boolean forceLayDownOnSprint = true;

    @NonSync
    @Translatable.Name("Min Animation State Duration")
    @Translatable.Desc("The minimum time (in seconds) a shoulder hamster will stay in any one animation state (standing, sitting, or laying down). A random duration between the min and max is chosen for each transition.")
    public ValidatedInt shoulderMinStateSeconds = new ValidatedInt(20, 280, 5);

    @NonSync
    @ConfigGroup.Pop
    @Translatable.Name("Max Animation State Duration")
    @Translatable.Desc("The maximum time (in seconds) a shoulder hamster will stay in any one animation state (standing, sitting, or laying down). A random duration between the min and max is chosen for each transition.")
    public ValidatedInt shoulderMaxStateSeconds = new ValidatedInt(45, 300, 6);

    @NonSync
    @Translatable.Name("Audio Settings")
    @Translatable.Desc("For when the squeaks become... a bit much.")
    public ConfigGroup shoulderAudio = new ConfigGroup("shoulderAudio", true);

    @NonSync
    @Translatable.Name("Silence Idle Sounds")
    @Translatable.Desc("Mutes the ambient squeaks from shoulder-mounted hamsters. The bounce and alert sounds will still play.")
    public boolean silenceShoulderIdleSounds = false;

    @NonSync
    @ConfigGroup.Pop
    @ConfigGroup.Pop
    @Translatable.Name("Mute 1st-Person Physics SFX")
    @Translatable.Desc("Mutes the hamster landing/bounce sound effect from the physics simulation when you are in first-person view.")
    public boolean silencePhysicsSoundsInFirstPerson = false;

    // --- Hamster Yeet Settings ---
    @Translatable.Name("Hamster Yeet Settings")
    @Translatable.Desc("For when you need a furry, surprisingly aerodynamic solution.")
    public ConfigGroup yeetSettings = new ConfigGroup("yeetSettings", true);

    @Translatable.Name("Throw Velocity")
    @Translatable.Desc("The base throw speed of your furry projectile.")
    public ValidatedDouble hamsterThrowVelocity = new ValidatedDouble(1.5, 5.0, 0.1);

    @ConfigGroup.Pop
    @Translatable.Name("Throw Velocity (Buffed)")
    @Translatable.Desc("The throw speed of your furry projectile when under the influence of Steamed Green Beans. Goes from 'yeet' to 'yote'.")
    public ValidatedDouble hamsterThrowVelocityBuffed = new ValidatedDouble(2.5, 5.0, 0.1);

    // --- Tamed Sleep Settings ---
    @Translatable.Name("Tamed Sleep Settings")
    @Translatable.Desc("Even digital rodents need beauty sleep— adjust according to your patience levels.")
    public ConfigGroup tamedSleepSettings = new ConfigGroup("tamedSleepSettings", true);

    @Translatable.Name("Threat Radius")
    @Translatable.Desc("How close (in blocks) a hostile mob can get before a hamster wakes up from it's power nap.")
    public ValidatedInt tamedSleepThreatDetectionRadiusBlocks = new ValidatedInt(8, 32, 1);

    @Translatable.Name("Require Daytime?")
    @Translatable.Desc("Choose when your sitting hamster will succumb to drowsiness. 'True' means your sitting hamster will only doze off during the day— 'false' means it can doze off anytime. This setting does not affect the behavior of a hamster when sleeping in a bed.")
    public boolean requireDaytimeForTamedSleep = true;

    @Translatable.Name("Min Sit Time Before Drowsy (Secs)")
    @Translatable.Desc("Minimum seconds before a sitting hamster gets sleepy.")
    public ValidatedInt tamedQuiescentSitMinSeconds = new ValidatedInt(120, 300, 1);

    @ConfigGroup.Pop
    @Translatable.Name("Max Sit Time Before Drowsy (Secs)")
    @Translatable.Desc("Maximum seconds before the inevitable deep snooze.")
    public ValidatedInt tamedQuiescentSitMaxSeconds = new ValidatedInt(180, 600, 2);

    // --- Food Healing Settings ---
    @Translatable.Name("Food Healing Settings")
    @Translatable.Desc("Nutrition— isn't it wonderful. Tweaks to snacks.")
    public ConfigGroup foodHealing = new ConfigGroup("foodHealing", true);

    @Translatable.Name("Food Mix")
    @Translatable.Desc("Healing amount from Hamster Food Mix. The good stuff.")
    public ValidatedFloat hamsterFoodMixHealing = new ValidatedFloat(4.0f, 10.0f, 0.0f);

    @ConfigGroup.Pop
    @Translatable.Name("Standard Food")
    @Translatable.Desc("Healing from basic seeds/crops. Better than nothing… probably.")
    public ValidatedFloat standardFoodHealing = new ValidatedFloat(2.0f, 5.0f, 0.0f);

    // --- Cheese Food Settings ---
    @Translatable.Name("Cheese Settings")
    @Translatable.Desc("Cheese... the gooey wonder. Some people think it's overpowered. I disagree. Obviously.")
    public ConfigGroup cheeseHealing = new ConfigGroup("cheeseHealing", true);

    @Translatable.Name("Cheese Nutrition")
    @Translatable.Desc("How many little hunger shanks the cheese restores. Vanilla cooked steak is 8. I know you're thinking of moving it to 20, you monster.")
    public ValidatedInt cheeseNutrition = new ValidatedInt(8, 20, 0);

    @ConfigGroup.Pop
    @Translatable.Name("Cheese Saturation")
    @Translatable.Desc("How long the hunger effect lasts. Cooked steak is 0.8. Don't get too crazy. Or do. I'm not your conscience.")
    public ValidatedFloat cheeseSaturation = new ValidatedFloat(0.8f, 2.0f, 0.0f);

    // --- Green Bean Buff Settings ---
    @Translatable.Name("Green Bean Buff Settings")
    @Translatable.Desc("Nutrition, but make it dramatic. Tweaks to caffeine-bean highs.")
    public ConfigGroup greenBeanBuffs = new ConfigGroup("greenBeanBuffs", true);

    @Translatable.Name("Duration")
    @Translatable.Desc("Steamed beans: power that fades faster than your attention span. (20 ticks = 1 second)")
    public ValidatedInt greenBeanBuffDuration = new ValidatedInt(3600, 20 * 60 * 10, 20);

    @Translatable.Name("Speed Level")
    @Translatable.Desc("Because someone has to go fast.")
    public ValidatedInt greenBeanBuffAmplifierSpeed = new ValidatedInt(1, 4, 0);

    @Translatable.Name("Strength Level")
    @Translatable.Desc("Slightly mightier nibbles.")
    public ValidatedInt greenBeanBuffAmplifierStrength = new ValidatedInt(1, 4, 0);

    @Translatable.Name("Absorption Level")
    @Translatable.Desc("Extra fluff padding for those daring dives.")
    public ValidatedInt greenBeanBuffAmplifierAbsorption = new ValidatedInt(1, 4, 0);

    @ConfigGroup.Pop
    @Translatable.Name("Regen Level")
    @Translatable.Desc("Heals minor paper-cuts (and fragile egos).")
    public ValidatedInt greenBeanBuffAmplifierRegen = new ValidatedInt(0, 4, 0);

    // --- Independent Diamond Seeking Settings ---
    @Translatable.Name("Independent Diamond Seeking Settings")
    @Translatable.Desc("Unleash free-range prospectors. What could go wrong?")
    public ConfigGroup independentDiamondSeeking = new ConfigGroup("independentDiamondSeeking", true);

    @Translatable.Name("Enable Independent Diamond Seeking")
    @Translatable.Desc("Permit hamsters to embark on solo get-rich-quick schemes?")
    public boolean enableIndependentDiamondSeeking = true;

    @Translatable.Name("Diamond Seek Scan Radius")
    @Translatable.Desc("How far (in blocks) a hamster scans once it’s decided to play prospector.")
    public ValidatedInt diamondSeekRadius = new ValidatedInt(10, 20, 5);

    @ConfigGroup.Pop
    @Translatable.Name("Gold 'Mistake' Chance")
    @Translatable.Desc("The probability (0.0 to 1.0) that a hamster will seek gold instead of diamond, if both are available. At 0.5, it's a coin toss. At 1.0, it's guaranteed hamster sulking.")
    public ValidatedFloat goldMistakeChance = new ValidatedFloat(0.33f, 1.0f, 0.0f);

    // --- Diamond Stealing Behavior Settings---
    @Translatable.Name("Diamond Stealing Behavior Settings")
    @Translatable.Desc("For when your hamster develops a taste for the finer things in life. Can be configured so they steal any item— even from other mods, but they only steal diamonds by default.")
    public ConfigGroup diamondStealing = new ConfigGroup("diamondStealing", true);

    @Translatable.Name("Enable Diamond Stealing")
    @Translatable.Desc("Permits hamsters to engage in spontaneous, high-stakes games of keep-away with your valuables. A chase ensues. Obviously.")
    public boolean enableDiamondStealing = true;

    @Translatable.Name("Pounce Chance")
    @Translatable.Desc("Probability (0.1 to 1.0) a hamster will succumb to temptation. High by default. You shouldn't leave your diamonds lying around anyway.")
    public ValidatedFloat diamondPounceChance = new ValidatedFloat(0.75f, 1.0f, 0.1f);

    @Translatable.Name("Minimum Flee Distance")
    @Translatable.Desc("The hamster's personal space bubble (in blocks).")
    public ValidatedInt minFleeDistance = new ValidatedInt(5, 20, 1);

    @Translatable.Name("Maximum Flee Distance")
    @Translatable.Desc("The maximum distance (in blocks) before the hamster gets bored and stops running to taunt you.")
    public ValidatedInt maxFleeDistance = new ValidatedInt(20, 40, 5);

    @Translatable.Name("Minimum Steal Duration")
    @Translatable.Desc("The shortest amount of time (in seconds) the hamster will entertain this little game before getting bored and dropping your stuff.")
    public ValidatedInt minStealDurationSeconds = new ValidatedInt(5, 240, 1);

    @ConfigGroup.Pop
    @Translatable.Name("Maximum Steal Duration")
    @Translatable.Desc("The longest (in seconds) your cardio session can last before the hamster's attention span gives out.")
    public ValidatedInt maxStealDurationSeconds = new ValidatedInt(15, 300, 5);
}
```

`AhpRootConfig.java`
All `@Translatable.Name` and `@Translatable.Desc` strings in this class are copied into `en_us.json` during the data generation process. That generated file is `.gitignore`d and is not included in this tech spec to avoid redundancy.
```java
package net.dawson.adorablehamsterpets.config;

// (Imports omitted to save token count)

/**
 * Root-level configuration used purely as the entry point for this mod's
 * settings.  The @RootConfig annotation causes this config’s name and
 * description to be shown on the landing page, and the other configs in
 * the same namespace will be listed below it.
 */
@Translation(prefix = "adorablehamsterpets.root") // TODO: Remove @Translation annotation in Fzzy Config 0.7.4+ (See EnUsGenerator.java)
@Translatable.Name("Main Menu")
@Translatable.Desc("Here's where your hamster experimentation begins. Don't forget to touch grass.")
@RootConfig
public class AhpRootConfig extends Config {
    public AhpRootConfig() {
        // Identifier path “root” gives the file name (root.toml) and the
        // translation key config.adorablehamsterpets.root
        super(Identifier.of(AdorableHamsterPets.MOD_ID, "root"));
    }
}
```

`AhpWorldGenConfig.java`
All `@Translatable.Name` and `@Translatable.Desc` strings in this class are copied into `en_us.json` during the data generation process. That generated file is `.gitignore`d and is not included in this tech spec to avoid redundancy.
```java
package net.dawson.adorablehamsterpets.config;

// (Imports omitted to save token count)

@Translation(prefix = "adorablehamsterpets.worldgen") // TODO: Remove @Translation annotation in Fzzy Config 0.7.4+ (See EnUsGenerator.java)
@Translatable.Name("World Gen Settings")
@Translatable.Desc("Control the rodent population density and where their food grows. Changes here usually require a restart, or at least a deep breath. Note: If you join a server, its world gen settings will override yours.")
public class AhpWorldGenConfig extends Config {

    public AhpWorldGenConfig() {
        super(Identifier.of(AdorableHamsterPets.MOD_ID, "worldgen"));
    }

    @Override
    @NotNull
    public SaveType saveType() {
        return SaveType.SEPARATE;
    }

    // --- Hamster Spawn Settings ---
    @Translatable.Name("Hamster Spawn Settings")
    @Translatable.Desc("How Many, Where, and How Often?  Note: Some of these settings require re-logging into your world to take effect.")
    public ConfigGroup hamsterSpawning = new ConfigGroup("hamsterSpawning", false);

    @Translatable.Name("Spawn Weight")
    @Translatable.Desc("Adjusts hamster spawn frequency. Higher = more chaos. 1 = blissful silence.")
    public ValidatedInt spawnWeight = new ValidatedInt(30, 100, 1);

    @Translatable.Name("Max Group Size")
    @Translatable.Desc("Maximum hamsters per spawn group. Because sometimes one just isn't cute enough.")
    public ValidatedInt maxGroupSize = new ValidatedInt(1, 10, 1);

    @Translatable.Name("Vanilla Biome Tags")
    @Translatable.Desc("A list of biome tags where hamsters can spawn. Format: 'mod_id:tag_name'. For example, 'minecraft:is_forest'.")
    public List<String> spawnBiomeTags = new ArrayList<>(List.of(
            "minecraft:is_beach",
            "minecraft:is_badlands",
            "minecraft:is_savanna",
            "minecraft:is_jungle",
            "minecraft:is_forest",
            "minecraft:is_taiga",
            "minecraft:is_mountain"
    ));

    @Translatable.Name("Convention Biome Tags")
    @Translatable.Desc("A list of 'c:' convention biome tags where hamsters can spawn. Used for broad mod compatibility. By default, this includes most overworld tags as a 'catch-all', and the filtering for different hamster variants in each biome is hard coded.")
    public List<String> spawnBiomeConventionTags = new ArrayList<>(List.of(
            "c:is_cold",
            "c:is_hot",
            "c:is_temperate",
            "c:is_dry",
            "c:is_wet",
            "c:is_dense_vegetation",
            "c:is_sparse_vegetation"
    ));

    @Translatable.Name("Include Specific Biomes")
    @Translatable.Desc("A list of specific biome IDs to ALWAYS allow spawns in, even if they don't match the tags above. Format: 'mod_id:biome_name'. For example, 'minecraft:plains'.")
    public List<String> includeBiomes = new ArrayList<>(List.of(
            // Specific Biomes from old isKeyInSpawnList
            "minecraft:snowy_plains", "minecraft:snowy_taiga", "minecraft:snowy_slopes",
            "minecraft:frozen_peaks", "minecraft:jagged_peaks", "minecraft:grove",
            "minecraft:frozen_river", "minecraft:snowy_beach", "minecraft:frozen_ocean",
            "minecraft:deep_frozen_ocean", "minecraft:ice_spikes", "minecraft:cherry_grove",
            "minecraft:lush_caves", "minecraft:dripstone_caves", "minecraft:deep_dark",
            "minecraft:swamp", "minecraft:mangrove_swamp", "minecraft:desert",
            "minecraft:plains", "minecraft:sunflower_plains", "minecraft:meadow",
            "minecraft:old_growth_birch_forest", "minecraft:windswept_hills",
            "minecraft:windswept_gravelly_hills", "minecraft:windswept_forest",
            "minecraft:windswept_savanna", "minecraft:stony_peaks", "minecraft:sparse_jungle",
            "minecraft:bamboo_jungle", "minecraft:stony_shore", "minecraft:mushroom_fields",
            "minecraft:deep_dark", "minecraft:forest", "minecraft:birch_forest", "minecraft:dark_forest",
            "minecraft:taiga", "minecraft:old_growth_pine_taiga", "minecraft:old_growth_spruce_taiga",
            "minecraft:savanna", "minecraft:savanna_plateau", "minecraft:badlands",
            "minecraft:eroded_badlands", "minecraft:wooded_badlands", "minecraft:beach",

            "terralith:desert_canyon", "terralith:cave/andesite_caves", "terralith:cave/crystal_caves", "terralith:cave/deep_caves", "terralith:cave/desert_caves", "terralith:cave/diorite_caves", "terralith:cave/frostfire_caves", "terralith:cave/fungal_caves", "terralith:cave/granite_caves", "terralith:cave/ice_caves", "terralith:cave/infested_caves", "terralith:cave/mantle_caves", "terralith:cave/thermal_caves", "terralith:cave/tuff_caves", "terralith:cave/underground_jungle",
            "terralith:alpha_islands_winter", "terralith:alpha_islands", "terralith:alpine_grove", "terralith:alpine_highlands", "terralith:amethyst_canyon", "terralith:amethyst_rainforest", "terralith:ancient_sands", "terralith:arid_highlands", "terralith:ashen_savanna",
            "terralith:basalt_cliffs", "terralith:birch_taiga", "terralith:blooming_plateau", "terralith:blooming_valley", "terralith:brushland", "terralith:bryce_canyon", "terralith:caldera", "terralith:cloud_forest", "terralith:cold_shrubland",
            "terralith:desert_oasis", "terralith:desert_spires", "terralith:emerald_peaks", "terralith:forested_highlands", "terralith:fractured_savanna", "terralith:frozen_cliffs", "terralith:glacial_chasm", "terralith:granite_cliffs",
            "terralith:gravel_beach", "terralith:gravel_desert", "terralith:haze_mountain", "terralith:highlands", "terralith:hot_shrubland", "terralith:ice_marsh", "terralith:jungle_mountains",
            "terralith:lavender_forest", "terralith:lavender_valley", "terralith:lush_desert", "terralith:lush_valley", "terralith:mirage_isles", "terralith:moonlight_grove", "terralith:moonlight_valley", "terralith:mountain_steppe",
            "terralith:orchid_swamp", "terralith:painted_mountains", "terralith:red_oasis", "terralith:rocky_jungle", "terralith:rocky_mountains", "terralith:rocky_shrubland",
            "terralith:sakura_grove", "terralith:sakura_valley", "terralith:sandstone_valley", "terralith:savanna_badlands", "terralith:savanna_slopes", "terralith:scarlet_mountains",
            "terralith:shield_clearing", "terralith:shield", "terralith:shrubland", "terralith:siberian_grove", "terralith:siberian_taiga",
            "terralith:skylands_autumn", "terralith:skylands_spring", "terralith:skylands_summer", "terralith:skylands_winter", "terralith:skylands",
            "terralith:snowy_badlands", "terralith:snowy_cherry_grove", "terralith:snowy_maple_forest", "terralith:snowy_shield",
            "terralith:steppe", "terralith:stony_spires", "terralith:temperate_highlands", "terralith:tropical_jungle", "terralith:valley_clearing",
            "terralith:volcanic_crater", "terralith:volcanic_peaks", "terralith:warm_river", "terralith:warped_mesa", "terralith:white_cliffs", "terralith:white_mesa",
            "terralith:windswept_spires", "terralith:wintry_forest", "terralith:wintry_lowlands", "terralith:yellowstone", "terralith:yosemite_cliffs", "terralith:yosemite_lowlands",

            "biomesoplenty:wasteland", "biomesoplenty:wasteland_steppe",
            "biomesoplenty:mediterranean_forest", "biomesoplenty:mystic_grove", "biomesoplenty:orchard", "biomesoplenty:pumpkin_patch",
            "biomesoplenty:redwood_forest", "biomesoplenty:seasonal_forest", "biomesoplenty:woodland",
            "biomesoplenty:floodplain", "biomesoplenty:fungal_jungle", "biomesoplenty:rainforest", "biomesoplenty:rocky_rainforest",

            "byg:lush_stacks", "byg:orchard", "byg:frosted_coniferous_forest", "byg:allium_fields", "byg:amaranth_fields", "byg:rose_fields",
            "byg:temperate_grove", "byg:coconino_meadow", "byg:skyris_vale", "byg:prairie", "byg:autumnal_valley", "byg:cardinal_tundra", "byg:firecracker_shrubland",
            "byg:allium_shrubland", "byg:amaranth_grassland", "byg:araucaria_savanna", "byg:aspen_boreal", "byg:atacama_outback", "byg:baobab_savanna",
            "byg:basalt_barrera", "byg:bayou", "byg:black_forest", "byg:canadian_shield", "byg:cika_woods", "byg:coniferous_forest",
            "byg:crimson_tundra", "byg:cypress_swamplands", "byg:dacite_ridges", "byg:dacite_shore", "byg:dead_sea", "byg:ebony_woods",
            "byg:enchanted_tangle", "byg:eroded_borealis", "byg:firecracker_chaparral", "byg:forgotten_forest", "byg:fragment_jungle",
            "byg:frosted_taiga", "byg:howling_peaks", "byg:ironwood_gour", "byg:jacaranda_jungle", "byg:maple_taiga", "byg:mojave_desert",
            "byg:overgrowth_woodlands", "byg:pumpkin_valley", "byg:rainbow_beach", "byg:red_rock_valley", "byg:redwood_thicket",
            "byg:rugged_badlands", "byg:sakura_grove", "byg:shattered_glacier", "byg:sierra_badlands", "byg:skyrise_vale",
            "byg:tropical_rainforest", "byg:weeping_witch_forest", "byg:white_mangrove_marshes", "byg:windswept_desert", "byg:zelkova_forest"
    ));

    @Translatable.Name("Exclude Specific Biomes")
    @Translatable.Desc("A list of specific biome IDs to NEVER allow spawns in, even if they match a tag. This overrides all other settings. Format: 'mod_id:biome_name'. For example, 'minecraft:plains'.")
    public List<String> excludeBiomes = new ArrayList<>(List.of("mod_id:biome_name"));

    @Translatable.Name("Variant Spawning by Biome")
    @Translatable.Desc("For the aspiring digital zoologist. This is where you control exactly which hamster colors appear in which biomes. The system checks each color group below in order, from top to bottom (rarest to most common). The first base color that a biome qualifies for is the one that will spawn there. 'Why no settings for orange hamsters?' Because orange is the default fallback if no other rules match.")
    public ConfigGroup variantSpawning = new ConfigGroup("variantSpawning", false);

    @Translatable.Name("Priority 1: Blue Variants")
    @Translatable.Desc("The icy ones. Checked before all other colors. If a biome matches these rules, it will get blue hamsters, even if it also matches rules for other colors below.")
    public ConfigGroup blueVariant = new ConfigGroup("blueVariant", true);
    @Translatable.Name("Included Biomes")
    public List<String> blueBiomes = new ArrayList<>(List.of(
            "terralith:glacial_chasm", "terralith:mirage_isles", "terralith:moonlight_valley", "biomesoplenty:enchanted_garden"
    ));
    @Translatable.Name("Included Tags")
    public List<String> blueTags = new ArrayList<>(List.of(
            "c:is_icy"
    ));
    @Translatable.Name("Excluded Biomes")
    public List<String> blueExclusionBiomes = new ArrayList<>(List.of(
            "namespace:id"
    ));
    @ConfigGroup.Pop
    @Translatable.Name("Excluded Tags")
    public List<String> blueExclusionTags = new ArrayList<>(List.of(
            "c:tag_name"
    ));

    @Translatable.Name("Priority 2: Lavender Variants")
    @Translatable.Desc("The magical ones. Checked after Blue, but before all others.")
    public ConfigGroup lavenderVariant = new ConfigGroup("lavenderVariant", true);
    @Translatable.Name("Included Biomes")
    public List<String> lavenderBiomes = new ArrayList<>(List.of(
            "minecraft:cherry_grove", "terralith:sakura_valley", "biomesoplenty:fungi_forest", "biomesoplenty:mystic_grove"
    ));
    @Translatable.Name("Included Tags")
    public List<String> lavenderTags = new ArrayList<>(List.of(
            "c:is_magical", "c:is_mushroom", "terralith:mystical"
    ));
    @Translatable.Name("Excluded Biomes")
    public List<String> lavenderExclusionBiomes = new ArrayList<>(List.of(
            "namespace:id"
    ));
    @ConfigGroup.Pop
    @Translatable.Name("Excluded Tags")
    public List<String> lavenderExclusionTags = new ArrayList<>(List.of(
            "c:tag_name"
    ));

    @Translatable.Name("Priority 3: White Variants")
    @Translatable.Desc("The snowy ones. Checked after Blue and Lavender.")
    public ConfigGroup whiteVariant = new ConfigGroup("whiteVariant", true);
    @Translatable.Name("Included Biomes")
    public List<String> whiteBiomes = new ArrayList<>(List.of(
            "terralith:snowy_maple_forest", "terralith:wintry_forest", "terralith:alpine_grove", "terralith:siberian_grove"
    ));
    @Translatable.Name("Included Tags")
    public List<String> whiteTags = new ArrayList<>(List.of(
            "c:is_cold", "c:is_snowy"
    ));
    @Translatable.Name("Excluded Biomes")
    public List<String> whiteExclusionBiomes = new ArrayList<>(List.of(
            "minecraft:deep_frozen_ocean", "minecraft:frozen_ocean", "minecraft:stony_shore", "minecraft:windswept_forest",
            "minecraft:windswept_gravelly_hills", "minecraft:windswept_hills", "minecraft:taiga",
            "minecraft:old_growth_pine_taiga", "minecraft:old_growth_spruce_taiga"
    ));
    @ConfigGroup.Pop
    @Translatable.Name("Excluded Tags")
    public List<String> whiteExclusionTags = new ArrayList<>(List.of(
            "c:tag_name"
    ));

    @Translatable.Name("Priority 4: Gray Variants") // Includes both light and dark gray
    @Translatable.Desc("The rocky ones. For mountains, cliffs, and other places you're likely to twist an ankle.")
    public ConfigGroup grayVariant = new ConfigGroup("grayVariant", true);
    @Translatable.Name("Included Biomes")
    public List<String> grayBiomes = new ArrayList<>(List.of(
            "minecraft:stony_shore", "terralith:stony_spires"
    ));
    @Translatable.Name("Included Tags")
    public List<String> grayTags = new ArrayList<>(List.of(
            "c:is_mountain", "c:is_sparse_vegetation", "terralith:cliffs"
    ));
    @Translatable.Name("Excluded Biomes")
    public List<String> grayExclusionBiomes = new ArrayList<>(List.of(
            "namespace:id"
    ));
    @ConfigGroup.Pop
    @Translatable.Name("Excluded Tags")
    public List<String> grayExclusionTags = new ArrayList<>(List.of(
            "minecraft:is_badlands", "minecraft:is_jungle", "minecraft:is_savanna"
    ));

    @Translatable.Name("Priority 5: Black Variants")
    @Translatable.Desc("The damp ones. Found in swamps, caves, and other places that are probably bad for your sinuses.")
    public ConfigGroup blackVariant = new ConfigGroup("blackVariant", true);
    @Translatable.Name("Included Biomes")
    public List<String> blackBiomes = new ArrayList<>(List.of(
            "minecraft:deep_dark"
    ));
    @Translatable.Name("Included Tags")
    public List<String> blackTags = new ArrayList<>(List.of(
            "c:is_wet", "c:is_cave"
    ));
    @Translatable.Name("Excluded Biomes")
    public List<String> blackExclusionBiomes = new ArrayList<>(List.of(
            "minecraft:dripstone_caves", "minecraft:lush_caves"
    ));
    @ConfigGroup.Pop
    @Translatable.Name("Excluded Tags")
    public List<String> blackExclusionTags = new ArrayList<>(List.of(
            "minecraft:is_jungle", "minecraft:is_beach"
    ));

    @Translatable.Name("Priority 6: Cream Variants")
    @Translatable.Desc("The sandy ones. For deserts, beaches, and birch forests. Don't ask why birch forests. They just like them.")
    public ConfigGroup creamVariant = new ConfigGroup("creamVariant", true);
    @Translatable.Name("Included Biomes")
    public List<String> creamBiomes = new ArrayList<>(List.of(
            "minecraft:old_growth_birch_forest", "minecraft:birch_forest", "terralith:ancient_sands",
            "terralith:sandstone_valley", "biomesoplenty:wasteland"
    ));
    @Translatable.Name("Included Tags")
    public List<String> creamTags = new ArrayList<>(List.of(
            "c:is_sandy"
    ));
    @Translatable.Name("Excluded Biomes")
    public List<String> creamExclusionBiomes = new ArrayList<>(List.of(
            "terralith:gravel_beach"
    ));
    @ConfigGroup.Pop
    @Translatable.Name("Excluded Tags")
    public List<String> creamExclusionTags = new ArrayList<>(List.of(
            "minecraft:is_badlands"
    ));

    @Translatable.Name("Priority 7: Chocolate Variants")
    @Translatable.Desc("The forest dwellers. If it's a generic forest and doesn't fit any of the fancy categories above, you'll probably find these guys.")
    public ConfigGroup chocolateVariant = new ConfigGroup("chocolateVariant", true);

    @Translatable.Name("Included Biomes")
    public List<String> chocolateBiomes = new ArrayList<>(List.of(
            "terralith:cloud_forest", "biomesoplenty:redwood_forest"
    ));
    @Translatable.Name("Included Tags")
    public List<String> chocolateTags = new ArrayList<>(List.of(
            "c:is_forest", "c:is_dense_vegetation"
    ));
    @Translatable.Name("Excluded Biomes")
    public List<String> chocolateExclusionBiomes = new ArrayList<>(List.of(
            "namespace:id"
    ));

    @ConfigGroup.Pop
    @ConfigGroup.Pop
    @ConfigGroup.Pop
    @Translatable.Name("Excluded Tags")
    public List<String> chocolateExclusionTags = new ArrayList<>(List.of(
            "c:tag_name"
    ));

    // --- Worldgen: Bush & Sunflower Stuff ---
    @Translatable.Name("Worldgen: Bush & Sunflower Stuff")
    @Translatable.Desc("For The Aspiring Landscape Artist. Note: Most of these settings require re-logging into your world to take effect, and it's unlikely you will see changes in chunks that have already been generated.")
    public ConfigGroup worldGenMisc = new ConfigGroup("worldGenMisc", false);

    @Translatable.Name("Wild Bush Regrowth Modifier")
    @Translatable.Desc("Higher = slower, lower = faster. Makes perfect sense.")
    public ValidatedDouble wildBushRegrowthModifier = new ValidatedDouble(1.0, 5.0, 0.1);

    // --- Sunflower Settings ---
    @Translatable.Name("Sunflower Settings")
    @Translatable.Desc("Custom sunflowers, because the vanilla ones just weren’t fabulous enough. Only changes fresh chunks.")
    public ConfigGroup sunflowerSettings = new ConfigGroup("sunflowerSettings", true);

    @Translatable.Name("Seed Regrowth Speed")
    @Translatable.Desc("Higher = slower, lower = faster. Photosynthesis is hard, okay?")
    public ValidatedDouble sunflowerRegrowthModifier = new ValidatedDouble(1.0, 5.0, 0.1);

    @Translatable.Name("Convention Biome Tags")
    @Translatable.Desc("A list of biome tags where these custom Sunflowers can replace vanilla ones. The 'c:is_plains' tag provides wide compatibility with modded biomes.")
    public List<String> sunflowerBiomeTags = new ArrayList<>(List.of(
            "c:is_plains",
            "c:is_temperate",
            "c:is_hot",
            "c:is_dry"
    ));

    @ConfigGroup.Pop
    @Translatable.Name("Specific Biomes")
    @Translatable.Desc("Specific biome IDs where these sunflowers can replace the vanilla ones. Format: 'mod_id:biome_name'. They’re picky.")
    public List<String> sunflowerBiomes = new ArrayList<>(List.of("minecraft:sunflower_plains"));

    // --- Cucumber Bush Settings ---
    @Translatable.Name("Cucumber Bush Settings")
    @Translatable.Desc("Wild cucumbers, for when you need emergency salads in the savanna. Only changes fresh chunks.")
    public ConfigGroup cucumberBushSettings = new ConfigGroup("cucumberBushSettings", true);

    @Translatable.Name("Cucumber Bush Rarity")
    @Translatable.Desc("1 in X chunks. Lower numbers means cucumbers take over the planet.")
    public ValidatedInt wildCucumberBushRarity = new ValidatedInt(24, 100, 1);

    @Translatable.Name("Vanilla Biome Tags")
    @Translatable.Desc("Biome tags where cucumbers feel at home. Format: 'mod_id:tag_name', for example: 'minecraft:is_jungle'.")
    public List<String> cucumberBushTags = new ArrayList<>(List.of("minecraft:is_jungle"));

    @Translatable.Name("Convention Biome Tags")
    @Translatable.Desc("Convention tags for maximum mod-pack harmony. Format: 'c:tag_name', for example: 'c:is_temperate'.")
    public List<String> cucumberBushConventionTags = new ArrayList<>(List.of(
            "c:is_temperate",
            "c:is_hot",
            "c:is_dry"
    ));

    @Translatable.Name("Specific Biomes")
    @Translatable.Desc("Specific biome IDs where cucumbers can sprout. Format: 'mod_id:biome_name', for example: 'minecraft:savanna'.")
    public List<String> cucumberBushBiomes = new ArrayList<>(List.of(
            "minecraft:plains",
            "minecraft:sunflower_plains",
            "minecraft:savanna",
            "minecraft:savanna_plateau",
            "minecraft:forest",
            "minecraft:birch_forest",
            "minecraft:meadow",
            "minecraft:wooded_badlands",
            "minecraft:jungle",
            "minecraft:sparse_jungle",
            "minecraft:bamboo_jungle"
    ));

    @ConfigGroup.Pop
    @Translatable.Name("Specific Exclusions")
    @Translatable.Desc("Biomes where cucumbers are absolutely NOT allowed. Overrides everything else. Format: 'mod_id:biome_name', for example: 'minecraft:ocean'.")
    public List<String> cucumberBushExclusions = new ArrayList<>(List.of(
            "minecraft:swamp",
            "minecraft:mangrove_swamp",
            "minecraft:mushroom_fields",
            "minecraft:ocean",
            "minecraft:deep_ocean",
            "minecraft:warm_ocean",
            "minecraft:stony_peaks"
    ));

    // --- Green Bean Bush Settings ---
    @Translatable.Name("Green Bean Bush Settings")
    @Translatable.Desc("Legumes with attitude. Tuned for that perfect mid-game caffeine hit. Only changes fresh chunks.")
    public ConfigGroup greenBeanBushSettings = new ConfigGroup("greenBeanBushSettings", true);

    @Translatable.Name("Green Bean Bush Rarity")
    @Translatable.Desc("1 in X chunks. Lower = beanpocalypse. For those of you in the back, it means they'll spam everywhere.")
    public ValidatedInt wildGreenBeanBushRarity = new ValidatedInt(24, 100, 1);

    @Translatable.Name("Vanilla Biome Tags")
    @Translatable.Desc("Biome tags for bean growth. Empty by default—choose wisely. Format: 'mod_id:tag_name', for example: 'minecraft:is_jungle'.")
    public List<String> greenBeanBushTags = new ArrayList<>(List.of("mod_id:biome_name"));

    @Translatable.Name("Convention Biome Tags")
    @Translatable.Desc("Convention tags for mod-friendly bean spam. Format: 'c:tag_name', for example: 'c:is_wet'.")
    public List<String> greenBeanBushConventionTags = new ArrayList<>(List.of(
            "c:is_wet",
            "c:is_temperate"
    ));

    @Translatable.Name("Specific Biomes")
    @Translatable.Desc("Specific biomes where beans sprout like gossip in chat. Format: 'mod_id:biome_name', for example: 'minecraft:swamp'.")
    public List<String> greenBeanBushBiomes = new ArrayList<>(List.of(
            "minecraft:swamp",
            "minecraft:mangrove_swamp",
            "minecraft:lush_caves",
            "minecraft:flower_forest"
    ));

    @ConfigGroup.Pop
    @ConfigGroup.Pop
    @Translatable.Name("Specific Exclusions")
    @Translatable.Desc("Absolutely no beans here, thank you very much. Overrides all other settings. Format: 'mod_id:biome_name', for example: 'minecraft:beach'.")
    public List<String> greenBeanBushExclusions = new ArrayList<>(List.of(
            "minecraft:beach",
            "minecraft:birch_forest",
            "minecraft:cherry_grove",
            "minecraft:dark_forest",
            "minecraft:deep_ocean",
            "minecraft:dripstone_caves",
            "minecraft:forest",
            "minecraft:meadow",
            "minecraft:ocean",
            "minecraft:old_growth_birch_forest",
            "minecraft:plains",
            "minecraft:river",
            "minecraft:sunflower_plains"
    ));
}
```

`ConfigDataCache.java`
```java
package net.dawson.adorablehamsterpets.config;

// (Imports omitted to save token count)

/**
 * A static cache for data parsed from the mod's configuration files.
 * <p>
 * This class loads user-defined lists of items and biomes from AhpConfig.java
 * into high-performance {@code Set} collections on startup. It provides static
 * checker methods (e.g., {@code isStandardFood()}, {@code isBlueBiome()}) for fast,
 * O(1) lookups during gameplay, avoiding repeated config parsing.
 */
public class ConfigDataCache {

    // --- Cached Sets for Item Performance ---
    private static final Set<Item> tamingItems = new HashSet<>();
    private static final Set<TagKey<Item>> tamingTags = new HashSet<>();
    private static final Set<Item> standardFoodItems = new HashSet<>();
    private static final Set<TagKey<Item>> standardFoodTags = new HashSet<>();
    private static final Set<Item> stealableItems = new HashSet<>();
    private static final Set<TagKey<Item>> stealableTags = new HashSet<>();
    private static final Set<Item> buffFoodItems = new HashSet<>();
    private static final Set<TagKey<Item>> buffFoodTags = new HashSet<>();
    private static final Set<Item> lureItems = new HashSet<>();
    private static final Set<TagKey<Item>> lureItemTags = new HashSet<>();
    private static final Set<Item> bedAvoidanceFoodItems = new HashSet<>();
    private static final Set<TagKey<Item>> bedAvoidanceFoodTags = new HashSet<>();
    private static final Set<Item> pouchUnlockItems = new HashSet<>();
    private static final Set<TagKey<Item>> pouchUnlockTags = new HashSet<>();
    private static final Set<Item> repeatableFoodItems = new HashSet<>();
    private static final Set<TagKey<Item>> repeatableFoodTags = new HashSet<>();
    private static final Set<Item> pouchAllowedItems = new HashSet<>();
    private static final Set<Item> autoHealFoodItems = new HashSet<>();
    private static final Set<TagKey<Item>> autoHealFoodTags = new HashSet<>();
    private static final Set<TagKey<Item>> pouchAllowedTags = new HashSet<>();
    private static final Set<Item> pouchDisallowedItems = new HashSet<>();
    private static final Set<TagKey<Item>> pouchDisallowedTags = new HashSet<>();

    // --- Cached Sets for Biome Variant Performance ---
    private static final Set<Identifier> blueBiomeIds = new HashSet<>();
    private static final Set<TagKey<Biome>> blueBiomeTags = new HashSet<>();
    private static final Set<Identifier> blueExclusionBiomeIds = new HashSet<>();
    private static final Set<TagKey<Biome>> blueExclusionBiomeTags = new HashSet<>();
    private static final Set<Identifier> lavenderBiomeIds = new HashSet<>();
    private static final Set<TagKey<Biome>> lavenderBiomeTags = new HashSet<>();
    private static final Set<Identifier> lavenderExclusionBiomeIds = new HashSet<>();
    private static final Set<TagKey<Biome>> lavenderExclusionBiomeTags = new HashSet<>();
    private static final Set<Identifier> whiteBiomeIds = new HashSet<>();
    private static final Set<TagKey<Biome>> whiteBiomeTags = new HashSet<>();
    private static final Set<Identifier> whiteExclusionBiomeIds = new HashSet<>();
    private static final Set<TagKey<Biome>> whiteExclusionBiomeTags = new HashSet<>();
    private static final Set<Identifier> grayBiomeIds = new HashSet<>();
    private static final Set<TagKey<Biome>> grayBiomeTags = new HashSet<>();
    private static final Set<Identifier> grayExclusionBiomeIds = new HashSet<>();
    private static final Set<TagKey<Biome>> grayExclusionBiomeTags = new HashSet<>();
    private static final Set<Identifier> blackBiomeIds = new HashSet<>();
    private static final Set<TagKey<Biome>> blackBiomeTags = new HashSet<>();
    private static final Set<Identifier> blackExclusionBiomeIds = new HashSet<>();
    private static final Set<TagKey<Biome>> blackExclusionBiomeTags = new HashSet<>();
    private static final Set<Identifier> creamBiomeIds = new HashSet<>();
    private static final Set<TagKey<Biome>> creamBiomeTags = new HashSet<>();
    private static final Set<Identifier> creamExclusionBiomeIds = new HashSet<>();
    private static final Set<TagKey<Biome>> creamExclusionBiomeTags = new HashSet<>();
    private static final Set<Identifier> chocolateBiomeIds = new HashSet<>();
    private static final Set<TagKey<Biome>> chocolateBiomeTags = new HashSet<>();
    private static final Set<Identifier> chocolateExclusionBiomeIds = new HashSet<>();
    private static final Set<TagKey<Biome>> chocolateExclusionBiomeTags = new HashSet<>();


    /**
     * Parses all item and biome tag lists from the config file.
     * This should be called once on startup and on config reload.
     */
    public static void parseConfig() {
        clearAllItemSets();
        clearAllBiomeSets();

        // --- Parse Item Lists ---
        parseItemList(Configs.AHP.tamingFoods, tamingItems, tamingTags, "tamingFoods");
        parseItemList(Configs.AHP.standardFoods, standardFoodItems, standardFoodTags, "standardFoods");
        parseItemList(Configs.AHP.stealableItems, stealableItems, stealableTags, "stealableItems");
        parseItemList(Configs.AHP.buffFoods, buffFoodItems, buffFoodTags, "buffFoods");
        parseItemList(Configs.AHP.lureItems, lureItems, lureItemTags, "lureItems");
        parseItemList(Configs.AHP.bedAvoidanceFoods, bedAvoidanceFoodItems, bedAvoidanceFoodTags, "bedAvoidanceFoods");
        parseItemList(Configs.AHP.pouchUnlockFoods, pouchUnlockItems, pouchUnlockTags, "pouchUnlockFoods");
        parseItemList(Configs.AHP.repeatableFoods, repeatableFoodItems, repeatableFoodTags, "repeatableFoods");
        parseItemList(Configs.AHP.pouchAllowedItems, pouchAllowedItems, pouchAllowedTags, "pouchAllowedItems");
        parseItemList(Configs.AHP.pouchDisallowedItems, pouchDisallowedItems, pouchDisallowedTags, "pouchDisallowedItems");
        parseItemList(Configs.AHP.pouchDisallowedTags, pouchDisallowedItems, pouchDisallowedTags, "pouchDisallowedTags");
        parseItemList(Configs.AHP.autoHealFoods, autoHealFoodItems, autoHealFoodTags, "autoHealFoods");

        // --- Parse Biome Lists ---
        parseBiomeIdList(Configs.AHP_WORLDGEN.blueBiomes, blueBiomeIds, "blueBiomes");
        parseBiomeTagList(Configs.AHP_WORLDGEN.blueTags, blueBiomeTags, "blueTags");
        parseBiomeIdList(Configs.AHP_WORLDGEN.blueExclusionBiomes, blueExclusionBiomeIds, "blueExclusionBiomes");
        parseBiomeTagList(Configs.AHP_WORLDGEN.blueExclusionTags, blueExclusionBiomeTags, "blueExclusionTags");

        parseBiomeIdList(Configs.AHP_WORLDGEN.lavenderBiomes, lavenderBiomeIds, "lavenderBiomes");
        parseBiomeTagList(Configs.AHP_WORLDGEN.lavenderTags, lavenderBiomeTags, "lavenderTags");
        parseBiomeIdList(Configs.AHP_WORLDGEN.lavenderExclusionBiomes, lavenderExclusionBiomeIds, "lavenderExclusionBiomes");
        parseBiomeTagList(Configs.AHP_WORLDGEN.lavenderExclusionTags, lavenderExclusionBiomeTags, "lavenderExclusionTags");

        parseBiomeIdList(Configs.AHP_WORLDGEN.whiteBiomes, whiteBiomeIds, "whiteBiomes");
        parseBiomeTagList(Configs.AHP_WORLDGEN.whiteTags, whiteBiomeTags, "whiteTags");
        parseBiomeIdList(Configs.AHP_WORLDGEN.whiteExclusionBiomes, whiteExclusionBiomeIds, "whiteExclusionBiomes");
        parseBiomeTagList(Configs.AHP_WORLDGEN.whiteExclusionTags, whiteExclusionBiomeTags, "whiteExclusionTags");

        parseBiomeIdList(Configs.AHP_WORLDGEN.grayBiomes, grayBiomeIds, "grayBiomes");
        parseBiomeTagList(Configs.AHP_WORLDGEN.grayTags, grayBiomeTags, "grayTags");
        parseBiomeIdList(Configs.AHP_WORLDGEN.grayExclusionBiomes, grayExclusionBiomeIds, "grayExclusionBiomes");
        parseBiomeTagList(Configs.AHP_WORLDGEN.grayExclusionTags, grayExclusionBiomeTags, "grayExclusionTags");

        parseBiomeIdList(Configs.AHP_WORLDGEN.blackBiomes, blackBiomeIds, "blackBiomes");
        parseBiomeTagList(Configs.AHP_WORLDGEN.blackTags, blackBiomeTags, "blackTags");
        parseBiomeIdList(Configs.AHP_WORLDGEN.blackExclusionBiomes, blackExclusionBiomeIds, "blackExclusionBiomes");
        parseBiomeTagList(Configs.AHP_WORLDGEN.blackExclusionTags, blackExclusionBiomeTags, "blackExclusionTags");

        parseBiomeIdList(Configs.AHP_WORLDGEN.creamBiomes, creamBiomeIds, "creamBiomes");
        parseBiomeTagList(Configs.AHP_WORLDGEN.creamTags, creamBiomeTags, "creamTags");
        parseBiomeIdList(Configs.AHP_WORLDGEN.creamExclusionBiomes, creamExclusionBiomeIds, "creamExclusionBiomes");
        parseBiomeTagList(Configs.AHP_WORLDGEN.creamExclusionTags, creamExclusionBiomeTags, "creamExclusionTags");

        parseBiomeIdList(Configs.AHP_WORLDGEN.chocolateBiomes, chocolateBiomeIds, "chocolateBiomes");
        parseBiomeTagList(Configs.AHP_WORLDGEN.chocolateTags, chocolateBiomeTags, "chocolateTags");
        parseBiomeIdList(Configs.AHP_WORLDGEN.chocolateExclusionBiomes, chocolateExclusionBiomeIds, "chocolateExclusionBiomes");
        parseBiomeTagList(Configs.AHP_WORLDGEN.chocolateExclusionTags, chocolateExclusionBiomeTags, "chocolateExclusionTags");

        AdorableHamsterPets.LOGGER.info("Parsed all item and biome tag overrides from config.");
    }

    // --- Public Item Checker Methods ---
    public static boolean isTamingFood(ItemStack stack) { return matchesItem(stack, tamingItems, tamingTags); }
    public static boolean isStandardFood(ItemStack stack) { return matchesItem(stack, standardFoodItems, standardFoodTags); }
    public static boolean isStealableItem(ItemStack stack) { return matchesItem(stack, stealableItems, stealableTags); }
    public static boolean isBuffFood(ItemStack stack) { return matchesItem(stack, buffFoodItems, buffFoodTags); }
    public static boolean isLureItem(ItemStack stack) { return matchesItem(stack, lureItems, lureItemTags); }
    public static boolean isBedAvoidanceFood(ItemStack stack) {return matchesItem(stack, bedAvoidanceFoodItems, bedAvoidanceFoodTags);}
    public static boolean isPouchUnlockFood(ItemStack stack) { return matchesItem(stack, pouchUnlockItems, pouchUnlockTags); }
    public static boolean isRepeatableFood(ItemStack stack) { return matchesItem(stack, repeatableFoodItems, repeatableFoodTags); }
    public static boolean isAutoHealFood(ItemStack stack) { return matchesItem(stack, autoHealFoodItems, autoHealFoodTags); }
    public static boolean isPouchAllowed(ItemStack stack) { return matchesItem(stack, pouchAllowedItems, pouchAllowedTags); }
    public static boolean isPouchDisallowed(ItemStack stack) { return matchesItem(stack, pouchDisallowedItems, pouchDisallowedTags); }

    // --- Public Biome Checker Methods ---
    public static boolean isBlueBiome(RegistryEntry<Biome> biomeEntry) { return matchesBiome(biomeEntry, blueBiomeIds, blueBiomeTags, blueExclusionBiomeIds, blueExclusionBiomeTags); }
    public static boolean isLavenderBiome(RegistryEntry<Biome> biomeEntry) { return matchesBiome(biomeEntry, lavenderBiomeIds, lavenderBiomeTags, lavenderExclusionBiomeIds, lavenderExclusionBiomeTags); }
    public static boolean isWhiteBiome(RegistryEntry<Biome> biomeEntry) { return matchesBiome(biomeEntry, whiteBiomeIds, whiteBiomeTags, whiteExclusionBiomeIds, whiteExclusionBiomeTags); }
    public static boolean isGrayBiome(RegistryEntry<Biome> biomeEntry) { return matchesBiome(biomeEntry, grayBiomeIds, grayBiomeTags, grayExclusionBiomeIds, grayExclusionBiomeTags); }
    public static boolean isBlackBiome(RegistryEntry<Biome> biomeEntry) { return matchesBiome(biomeEntry, blackBiomeIds, blackBiomeTags, blackExclusionBiomeIds, blackExclusionBiomeTags); }
    public static boolean isCreamBiome(RegistryEntry<Biome> biomeEntry) { return matchesBiome(biomeEntry, creamBiomeIds, creamBiomeTags, creamExclusionBiomeIds, creamExclusionBiomeTags); }
    public static boolean isChocolateBiome(RegistryEntry<Biome> biomeEntry) { return matchesBiome(biomeEntry, chocolateBiomeIds, chocolateBiomeTags, chocolateExclusionBiomeIds, chocolateExclusionBiomeTags); }

    // --- Private Helper Methods ---
    private static void parseItemList(List<String> configList, Set<Item> itemSet, Set<TagKey<Item>> tagSet, String listName) {
        for (String entry : configList) {
            if (entry.startsWith("#")) {
                try {
                    Identifier tagId = new Identifier(entry.substring(1));
                    tagSet.add(TagKey.of(Registries.ITEM.getKey(), tagId));
                } catch (Exception e) {
                    AdorableHamsterPets.LOGGER.warn("[ItemTagManager] Invalid item tag identifier in '{}' config list: '{}'", listName, entry);
                }
            } else {
                try {
                    Identifier itemId = new Identifier(entry);
                    Registries.ITEM.getOrEmpty(itemId).ifPresent(itemSet::add);
                } catch (Exception e) {
                    AdorableHamsterPets.LOGGER.warn("[ItemTagManager] Invalid item identifier in '{}' config list: '{}'", listName, entry);
                }
            }
        }
    }

    private static void parseBiomeIdList(List<String> configList, Set<Identifier> idSet, String listName) {
        for (String entry : configList) {
            try {
                // On 1.20.1, use 'new Identifier(entry)'
                idSet.add(new Identifier(entry));
            } catch (Exception e) {
                AdorableHamsterPets.LOGGER.warn("[BiomeTagManager] Invalid biome identifier in '{}' config list: '{}'", listName, entry);
            }
        }
    }

    private static void parseBiomeTagList(List<String> configList, Set<TagKey<Biome>> tagSet, String listName) {
        for (String entry : configList) {
            String tagName = entry.startsWith("#") ? entry.substring(1) : entry;
            try {
                // On 1.20.1, use 'new Identifier(tagName)'
                tagSet.add(TagKey.of(RegistryKeys.BIOME, new Identifier(tagName)));
            } catch (Exception e) {
                AdorableHamsterPets.LOGGER.warn("[BiomeTagManager] Invalid biome tag in '{}' config list: '{}'", listName, entry);
            }
        }
    }

    private static boolean matchesItem(ItemStack stack, Set<Item> itemSet, Set<TagKey<Item>> tagSet) {
        if (stack.isEmpty()) return false;
        if (itemSet.contains(stack.getItem())) return true;
        for (TagKey<Item> tag : tagSet) {
            if (stack.isIn(tag)) return true;
        }
        return false;
    }

    private static boolean matchesBiome(RegistryEntry<Biome> biomeEntry, Set<Identifier> ids, Set<TagKey<Biome>> tags, Set<Identifier> exclusionIds, Set<TagKey<Biome>> exclusionTags) {
        Identifier biomeId = biomeEntry.getKey().map(RegistryKey::getValue).orElse(null);
        if (biomeId == null) return false;

        // --- Exclusion Check (Highest Priority) ---
        if (exclusionIds.contains(biomeId)) return false;
        for (TagKey<Biome> tag : exclusionTags) {
            if (biomeEntry.isIn(tag)) return false;
        }

        // --- Inclusion Check ---
        if (ids.contains(biomeId)) return true;
        for (TagKey<Biome> tag : tags) {
            if (biomeEntry.isIn(tag)) return true;
        }

        return false;
    }

    private static void clearAllItemSets() {
        tamingItems.clear();
        tamingTags.clear();
        standardFoodItems.clear();
        standardFoodTags.clear();
        stealableItems.clear();
        stealableTags.clear();
        buffFoodItems.clear();
        buffFoodTags.clear();
        lureItems.clear();
        lureItemTags.clear();
        bedAvoidanceFoodItems.clear();
        bedAvoidanceFoodTags.clear();
        pouchUnlockItems.clear();
        pouchUnlockTags.clear();
        repeatableFoodItems.clear();
        repeatableFoodTags.clear();
        autoHealFoodItems.clear();
        autoHealFoodTags.clear();
        pouchAllowedItems.clear();
        pouchAllowedTags.clear();
        pouchDisallowedItems.clear();
        pouchDisallowedTags.clear();
    }

    private static void clearAllBiomeSets() {
        blueBiomeIds.clear();
        blueBiomeTags.clear();
        blueExclusionBiomeIds.clear();
        blueExclusionBiomeTags.clear();
        lavenderBiomeIds.clear();
        lavenderBiomeTags.clear();
        lavenderExclusionBiomeIds.clear();
        lavenderExclusionBiomeTags.clear();
        whiteBiomeIds.clear();
        whiteBiomeTags.clear();
        whiteExclusionBiomeIds.clear();
        whiteExclusionBiomeTags.clear();
        grayBiomeIds.clear();
        grayBiomeTags.clear();
        grayExclusionBiomeIds.clear();
        grayExclusionBiomeTags.clear();
        blackBiomeIds.clear();
        blackBiomeTags.clear();
        blackExclusionBiomeIds.clear();
        blackExclusionBiomeTags.clear();
        creamBiomeIds.clear();
        creamBiomeTags.clear();
        creamExclusionBiomeIds.clear();
        creamExclusionBiomeTags.clear();
        chocolateBiomeIds.clear();
        chocolateBiomeTags.clear();
        chocolateExclusionBiomeIds.clear();
        chocolateExclusionBiomeTags.clear();
    }
}
```

`Configs.java`
```java
package net.dawson.adorablehamsterpets.config;

// (Imports omitted to save token count)

/**
 * Static holder for the single Adorable Hamster Pets config.
 * Touching {@code Configs.AHP} guarantees the config is registered,
 * loaded from file, and its sync/GUI channels are ready.
 */
public final class Configs {

    /** Global, sync-enabled, GUI-enabled config instance. */
    public static final AhpRootConfig AHP_ROOT = ConfigApiJava.registerAndLoadConfig(AhpRootConfig::new);
    public static final AhpConfig AHP = ConfigApiJava.registerAndLoadConfig(AhpConfig::new);
    public static final AhpWorldGenConfig AHP_WORLDGEN = ConfigApiJava.registerAndLoadConfig(AhpWorldGenConfig::new);

    private Configs() {} // prevent instantiation
}
```

`DismountOrder.java`
```java
package net.dawson.adorablehamsterpets.config;

// (Imports omitted to save token count)

public enum DismountOrder implements EnumTranslatable {
    LIFO, // Last-In, First-Out
    FIFO; // First-In, First-Out

    @NotNull
    @Override
    public String prefix() {
        return "config.adorablehamsterpets.enum.dismount_order";
    }
}
```

`DismountPressType.java`
```java
package net.dawson.adorablehamsterpets.config;

// (Imports omitted to save token count)

public enum DismountPressType implements EnumTranslatable {
    SINGLE_PRESS,
    DOUBLE_TAP;

    @NotNull
    @Override
    public String prefix() {
        return "config.adorablehamsterpets.enum.dismount_press_type";
    }
}
```

`DismountTriggerType.java`
```java
package net.dawson.adorablehamsterpets.config;

// (Imports omitted to save token count)

public enum DismountTriggerType implements EnumTranslatable {
    SNEAK_KEY,
    CUSTOM_KEYBIND;

    @NotNull
    @Override
    public String prefix() {
        return "config.adorablehamsterpets.enum.dismount_trigger_type";
    }
}
```

`ForcedShoulderState.java`
```java
package net.dawson.adorablehamsterpets.config;

// (Imports omitted to save token count)

public enum ForcedShoulderState implements EnumTranslatable {
    ALWAYS_STAND,
    ALWAYS_SIT,
    ALWAYS_LAY_DOWN;

    @NotNull
    @Override
    public String prefix() {
        return "config.adorablehamsterpets.enum.forced_shoulder_state";
    }
}
```

`IconPositionPreset.java`
```java
package net.dawson.adorablehamsterpets.config;

// (Imports omitted to save token count)

public enum IconPositionPreset implements EnumTranslatable {
    TOP_LEFT,
    TOP_RIGHT,
    BOTTOM_LEFT,
    BOTTOM_RIGHT;

    @NotNull
    @Override
    public String prefix() {
        // This prefix is combined with the enum name (lowercase) to create the key.
        // Example: config.adorablehamsterpets.enum.icon_position.top_left
        return "config.adorablehamsterpets.enum.icon_position";
    }
}
```

`WanderDistance.java`
```java
package net.dawson.adorablehamsterpets.config;

// (Imports omitted to save token count)

public enum WanderDistance implements StringIdentifiable, EnumTranslatable {
    NEAR("Near"),
    MEDIUM("Medium"),
    FAR("Far");

    public static final Codec<WanderDistance> CODEC = StringIdentifiable.createCodec(WanderDistance::values);
    private final String name;

    WanderDistance(String name) {
        this.name = name;
    }

    @Override
    public String asString() {
        return this.name;
    }

    @NotNull
    @Override
    public String prefix() {
        return "config.adorablehamsterpets.enum.wander_distance";
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/block/`
`ModBlocks.java`
```java
package net.dawson.adorablehamsterpets.block;

// (Imports omitted to save token count)

public class ModBlocks {

    // --- 1. Create a DeferredRegister for Blocks ---
    public static final DeferredRegister<Block> BLOCKS = DeferredRegister.create(AdorableHamsterPets.MOD_ID, RegistryKeys.BLOCK);

    // --- 2. Change Block fields to RegistrySuppliers ---
    public static final RegistrySupplier<Block> GREEN_BEANS_CROP = registerBlock("green_beans_crop",
            () -> new GreenBeansCropBlock(AbstractBlock.Settings.copy(Blocks.WHEAT).sounds(BlockSoundGroup.CROP).nonOpaque().noCollision()));

    public static final RegistrySupplier<Block> CUCUMBER_CROP = registerBlock("cucumber_crop",
            () -> new CucumberCropBlock(AbstractBlock.Settings.copy(Blocks.WHEAT).sounds(BlockSoundGroup.CROP).nonOpaque().noCollision()));

    public static final RegistrySupplier<Block> WILD_GREEN_BEAN_BUSH = registerBlock("wild_green_bean_bush",
            () -> new WildGreenBeanBushBlock(AbstractBlock.Settings.copy(Blocks.SWEET_BERRY_BUSH)
                    .nonOpaque()
                    .noCollision()
                    .ticksRandomly()
                    .sounds(BlockSoundGroup.SWEET_BERRY_BUSH)));

    public static final RegistrySupplier<Block> WILD_CUCUMBER_BUSH = registerBlock("wild_cucumber_bush",
            () -> new WildCucumberBushBlock(AbstractBlock.Settings.copy(Blocks.SWEET_BERRY_BUSH)
                    .nonOpaque()
                    .noCollision()
                    .ticksRandomly()
                    .sounds(BlockSoundGroup.SWEET_BERRY_BUSH)));

    public static final RegistrySupplier<Block> SUNFLOWER_BLOCK = registerBlock("sunflower_block",
            () -> new SunflowerBlock(AbstractBlock.Settings.copy(Blocks.SUNFLOWER).nonOpaque()));

    public static final RegistrySupplier<Block> HAMSTER_BED = registerBlock("hamster_bed",
            // On 1.20.1. copy the settings of oak planks to avoid "Cannot resolve symbol 'NoteBlockInstrument" error
            () -> new HamsterBedBlock(AbstractBlock.Settings.copy(Blocks.OAK_PLANKS)
                    .mapColor(MapColor.OAK_TAN)
                    .strength(0.5F)
                    .nonOpaque()));

    // --- 3. Private Helper Method for Block Registration ---
    private static RegistrySupplier<Block> registerBlock(String name, Supplier<Block> blockSupplier) {
        return BLOCKS.register(name, blockSupplier);
    }

    // --- 4. Main Registration Call ---
    public static void register() {
        BLOCKS.register();
    }
}
```

`ModBlockEntities.java`
```java
package net.dawson.adorablehamsterpets.block;

// (Imports omitted to save token count)

public class ModBlockEntities {
    public static final DeferredRegister<BlockEntityType<?>> BLOCK_ENTITIES =
            DeferredRegister.create(AdorableHamsterPets.MOD_ID, RegistryKeys.BLOCK_ENTITY_TYPE);

    public static final RegistrySupplier<BlockEntityType<HamsterBedBlockEntity>> HAMSTER_BED_BLOCK_ENTITY =
            BLOCK_ENTITIES.register("hamster_bed_be", () ->
                    BlockEntityType.Builder.create(HamsterBedBlockEntity::new, ModBlocks.HAMSTER_BED.get()).build(null));

    public static void register() {
        BLOCK_ENTITIES.register();
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/block/client/`
`HamsterBedItemRenderer.java`
```java
package net.dawson.adorablehamsterpets.block.client;

// (Imports omitted to save token count)

public class HamsterBedItemRenderer extends GeoItemRenderer<HamsterBedItem> {
    public HamsterBedItemRenderer() {
        super(new HamsterBedItemModel());
    }

    @Override
    public RenderLayer getRenderType(HamsterBedItem animatable, Identifier texture, @org.jetbrains.annotations.Nullable VertexConsumerProvider bufferSource, float partialTick) {
        return RenderLayer.getEntityCutout(getTextureLocation(animatable));
    }

    @Override
    public Identifier getTextureLocation(HamsterBedItem animatable) {
        WoodVariant variant = animatable.getVariant();
        return Identifier.of(AdorableHamsterPets.MOD_ID, "textures/block/hamster_bed_" + variant.asString() + ".png");
    }
}
```

`HamsterBedModel.java`
```java
package net.dawson.adorablehamsterpets.block.client;

// (Imports omitted to save token count)

@SuppressWarnings({"removal"})
public class HamsterBedModel extends GeoModel<HamsterBedBlockEntity> {

    @Override
    public Identifier getModelResource(HamsterBedBlockEntity animatable) {
        return new Identifier(AdorableHamsterPets.MOD_ID, "geo/hamster_bed.geo.json");
    }

    @Override
    public Identifier getTextureResource(HamsterBedBlockEntity animatable) {
        // In 1.20.1, access the state directly from the block entity
        WoodVariant variant = animatable.getCachedState().get(HamsterBedBlock.WOOD_VARIANT);
        return new Identifier(AdorableHamsterPets.MOD_ID, "textures/block/hamster_bed_" + variant.asString() + ".png");
    }

    @Override
    public Identifier getAnimationResource(HamsterBedBlockEntity animatable) {
        return Identifier.of(AdorableHamsterPets.MOD_ID, "animations/anim_hamster_bed.animation.json");
    }
}
```

`HamsterBedRenderer.java`
```java
package net.dawson.adorablehamsterpets.block.client;

// (Imports omitted to save token count)

public class HamsterBedRenderer extends GeoBlockRenderer<HamsterBedBlockEntity> {
    public HamsterBedRenderer(BlockEntityRendererFactory.Context context) {
        super(new HamsterBedModel());
    }

    @Override
    public RenderLayer getRenderType(HamsterBedBlockEntity animatable, Identifier texture, VertexConsumerProvider bufferSource, float partialTick) {
        return RenderLayer.getEntityCutout(getTextureLocation(animatable));
    }

    // On 1.20.1, use preRender to apply the upside-down rotation logic. This avoids the method signature clash in the 'render' method on 1.20.1.
    @Override
    public void preRender(MatrixStack poseStack, HamsterBedBlockEntity animatable, BakedGeoModel model, VertexConsumerProvider bufferSource, VertexConsumer buffer, boolean isReRender, float partialTick, int packedLight, int packedOverlay, float red, float green, float blue, float alpha) {
        BlockState blockState = animatable.getCachedState();
        boolean isUpsideDown = blockState.contains(HamsterBedBlock.UPSIDE_DOWN) && blockState.get(HamsterBedBlock.UPSIDE_DOWN);

        if (isUpsideDown) {
            poseStack.push(); // Push for rotation
            // Translate to the center of the block to rotate around it
            poseStack.translate(0.5, 0.5, 0.5);
            // Rotate 180 degrees around the X-axis
            poseStack.multiply(RotationAxis.POSITIVE_X.rotationDegrees(180));
            // Translate back
            poseStack.translate(-0.5, -0.5, -0.5);
        }

        super.preRender(poseStack, animatable, model, bufferSource, buffer, isReRender, partialTick, packedLight, packedOverlay, red, green, blue, alpha);
    }

    @Override
    public void postRender(MatrixStack poseStack, HamsterBedBlockEntity animatable, BakedGeoModel model, VertexConsumerProvider bufferSource, VertexConsumer buffer, boolean isReRender, float partialTick, int packedLight, int packedOverlay, float red, float green, float blue, float alpha) {
        super.postRender(poseStack, animatable, model, bufferSource, buffer, isReRender, partialTick, packedLight, packedOverlay, red, green, blue, alpha);

        BlockState blockState = animatable.getCachedState();
        boolean isUpsideDown = blockState.contains(HamsterBedBlock.UPSIDE_DOWN) && blockState.get(HamsterBedBlock.UPSIDE_DOWN);

        if (isUpsideDown) {
            poseStack.pop(); // Pop to restore state
        }
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/block/custom/`
`CucumberCropBlock.java`
```java
package net.dawson.adorablehamsterpets.block.custom;

// (Imports omitted to save token count)

public class CucumberCropBlock extends CropBlock {
    public static final int MAX_AGE = 3;
    public static final IntProperty AGE = IntProperty.of("age", 0, 3);


    public CucumberCropBlock(Settings settings) {
        super(settings);
    }


    @Override
    protected ItemConvertible getSeedsItem() {
        return ModItems.CUCUMBER_SEEDS.get();
    }

    @Override
    protected IntProperty getAgeProperty() {
        return AGE;
    }

    @Override
    public int getMaxAge() {
        return MAX_AGE;
    }

    @Override
    protected void appendProperties(StateManager.Builder<Block, BlockState> builder) {
        builder.add(AGE);
    }
}
```

`GreenBeansCropBlock.java`
```java
package net.dawson.adorablehamsterpets.block.custom;

// (Imports omitted to save token count)

public class GreenBeansCropBlock extends CropBlock {
    // --- CORRECTED: Set MAX_AGE to 3 ---
    public static final int MAX_AGE = 3;
    // --- CORRECTED: Set IntProperty range to 0-3 ---
    public static final IntProperty AGE = IntProperty.of("age", 0, 3);


    public GreenBeansCropBlock(Settings settings) {
        super(settings);
    }


    @Override
    protected ItemConvertible getSeedsItem() {
        return ModItems.GREEN_BEAN_SEEDS.get();
    }

    @Override
    protected IntProperty getAgeProperty() {
        return AGE;
    }

    @Override
    public int getMaxAge() {
        // --- CORRECTED: Return the updated MAX_AGE ---
        return MAX_AGE;
    }

    @Override
    protected void appendProperties(StateManager.Builder<Block, BlockState> builder) {
        builder.add(AGE);
    }
}
```

`HamsterBedBlock.java`
```java
package net.dawson.adorablehamsterpets.block.custom;

// (Imports omitted to save token count)

public class HamsterBedBlock extends BlockWithEntity implements BlockEntityProvider {
    public static final BooleanProperty OCCUPIED = BooleanProperty.of("occupied");
    public static final BooleanProperty UPSIDE_DOWN = BooleanProperty.of("upside_down");
    public static final DirectionProperty ORIENTATION = DirectionProperty.of("orientation", dir -> dir.getAxis().isHorizontal());
    public static final EnumProperty<WoodVariant> WOOD_VARIANT = EnumProperty.of("wood_variant", WoodVariant.class);

    // --- VoxelShape Definitions ---
    private static final VoxelShape SHAPE_NORMAL = Stream.of(
            Block.createCuboidShape(1, 0, 1, 15, 1, 15), // Floor
            Block.createCuboidShape(1, 0, 1, 15, 3, 2),   // North Wall
            Block.createCuboidShape(1, 0, 14, 15, 3, 15), // South Wall
            Block.createCuboidShape(1, 0, 2, 2, 3, 14),   // West Wall
            Block.createCuboidShape(14, 0, 2, 15, 3, 14)  // East Wall
    ).reduce(VoxelShapes::union).get();

    private static final VoxelShape SHAPE_UPSIDE_DOWN = Stream.of(
            Block.createCuboidShape(1, 15, 1, 15, 16, 15), // Flipped Floor (now ceiling)
            Block.createCuboidShape(1, 13, 1, 15, 16, 2),   // Flipped North Wall
            Block.createCuboidShape(1, 13, 14, 15, 16, 15), // Flipped South Wall
            Block.createCuboidShape(1, 13, 2, 2, 16, 14),   // Flipped West Wall
            Block.createCuboidShape(14, 13, 2, 15, 16, 14)  // Flipped East Wall
    ).reduce(VoxelShapes::union).get();

    @Override
    public VoxelShape getOutlineShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context) {
        return state.get(UPSIDE_DOWN) ? SHAPE_UPSIDE_DOWN : SHAPE_NORMAL;
    }

    @Override
    public VoxelShape getCollisionShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context) {
        return state.get(UPSIDE_DOWN) ? SHAPE_UPSIDE_DOWN : SHAPE_NORMAL;
    }

    public HamsterBedBlock(Settings settings) {
        super(settings);
        setDefaultState(getStateManager().getDefaultState()
                .with(OCCUPIED, false)
                .with(UPSIDE_DOWN, false)
                .with(ORIENTATION, Direction.NORTH)
                .with(WOOD_VARIANT, WoodVariant.OAK));
    }

    @Nullable
    @Override
    public BlockEntity createBlockEntity(BlockPos pos, BlockState state) {
        return new HamsterBedBlockEntity(pos, state);
    }

    protected void appendProperties(StateManager.Builder<Block, BlockState> builder) {
        builder.add(OCCUPIED, UPSIDE_DOWN, ORIENTATION, WOOD_VARIANT);
    }

    // Pick a random but deterministic orientation when the block is placed
    @Override
    public BlockState getPlacementState(ItemPlacementContext ctx) {
        boolean isUpsideDown = ctx.getSide() == Direction.DOWN;
        // 1.20.1 NBT Logic for WoodVariant
        WoodVariant variant = WoodVariant.OAK; // Default
        ItemStack stack = ctx.getStack();
        if (stack.hasNbt() && stack.getNbt().contains(ModNbtKeys.WOOD_VARIANT)) {
            try {
                variant = WoodVariant.valueOf(stack.getNbt().getString(ModNbtKeys.WOOD_VARIANT));
            } catch (IllegalArgumentException ignored) {}
        }

        BlockPos pos = ctx.getBlockPos();
        // Derive a pseudo‑random but deterministic orientation from the block position
        long s = pos.asLong() ^ 0x9E3779B97F4A7C15L; // Noise so lines/grids don’t align
        s ^= (s >>> 30);  s *= 0xBF58476D1CE4E5B9L;
        s ^= (s >>> 27);  s *= 0x94D049BB133111EBL;
        s ^= (s >>> 31);

        int idx = (int)(s & 3L); // 0..3 → N/E/S/W
        Direction direction = Direction.fromHorizontal(idx);

        return getDefaultState()
                .with(OCCUPIED, false)
                .with(UPSIDE_DOWN, isUpsideDown)
                .with(ORIENTATION, direction)
                .with(WOOD_VARIANT, variant);
    }

    @Override
    public BlockRenderType getRenderType(BlockState state) {
        return BlockRenderType.ENTITYBLOCK_ANIMATED;
    }

    @Override
    public void onPlaced(World world, BlockPos pos, BlockState state, @Nullable LivingEntity placer, ItemStack itemStack) {
        super.onPlaced(world, pos, state, placer, itemStack);
        if (!world.isClient) {
            BlockEntity be = world.getBlockEntity(pos);
            if (be instanceof HamsterBedBlockEntity bedEntity) {
                // If placed upside down, disable sleeping for this specific bed and trigger advancement
                if (state.get(UPSIDE_DOWN)) {
                    bedEntity.setAllowSleep(false);
                    if (placer instanceof ServerPlayerEntity serverPlayer) {
                        ModCriteria.HAMSTER_BED_PLACED_UPSIDE_DOWN.trigger(serverPlayer);
                    }
                }

                // 1.20.1 NBT Logic
                if (itemStack.hasNbt()) {
                    NbtCompound nbt = itemStack.getNbt();

                    if (nbt.contains(ModNbtKeys.LINKED_HAMSTER_UUID)) {
                        UUID hamsterUuid = nbt.getUuid(ModNbtKeys.LINKED_HAMSTER_UUID);

                        // Name extraction
                        Text hamsterName = null;
                        if (nbt.contains(ModNbtKeys.LINKED_HAMSTER_NAME)) {
                            hamsterName = Text.Serializer.fromJson(nbt.getString(ModNbtKeys.LINKED_HAMSTER_NAME));
                        }

                        // Wander Distance extraction
                        WanderDistance wanderDistance = Configs.AHP.defaultWanderDistance.get();
                        if (nbt.contains(ModNbtKeys.WANDER_DISTANCE)) {
                            try {
                                wanderDistance = WanderDistance.valueOf(nbt.getString(ModNbtKeys.WANDER_DISTANCE));
                            } catch (IllegalArgumentException ignored) {}
                        }

                        bedEntity.setLinkedHamster(hamsterUuid, hamsterName != null ? hamsterName : Text.literal("Hamster"), wanderDistance);

                        // Find and update hamster
                        Entity entity = ((ServerWorld) world).getEntity(hamsterUuid);
                        if (entity instanceof HamsterEntity hamster) {
                            hamster.setLinkedBedPos(Optional.of(GlobalPos.create(world.getRegistryKey(), pos)));
                            hamster.setWanderModeActive(true);
                        }
                    }
                }
            }

            if (be instanceof HamsterBedBlockEntity bedEntity) {
                bedEntity.triggerAnim("hamster_bed_controller", "anim_bed_being_placed");
            }
        }
    }

    @Override
    public ActionResult onUse(BlockState state, World world, BlockPos pos, PlayerEntity player, Hand hand, BlockHitResult hit) {
        if (world.isClient) {
            // --- 1. Trigger hand swing ---
            // In 1.20.1, use the 'hand' passed to the method
            ItemStack heldStack = player.getStackInHand(hand);
            boolean isLureItem = ConfigDataCache.isLureItem(heldStack);
            boolean isAvoidanceItem = ConfigDataCache.isBedAvoidanceFood(heldStack);
            return (isLureItem || isAvoidanceItem) ? ActionResult.SUCCESS : ActionResult.CONSUME;
        }

        BlockEntity be = world.getBlockEntity(pos);
        if (be instanceof HamsterBedBlockEntity bedEntity) {

            // --- 2. Trigger Animation, Particles, and Sound on any interaction ---
            if (state.get(OCCUPIED)) {
                bedEntity.triggerAnim("hamster_bed_controller", "anim_bed_interact_occupied");
            } else {
                bedEntity.triggerAnim("hamster_bed_controller", "anim_bed_interact_unoccupied");
            }

            // Spawn Particles with wood variant
            ((ServerWorld)world).spawnParticles(ModParticles.getForVariant(state.get(WOOD_VARIANT)),
                    pos.getX() + 0.5, pos.getY() + 0.2, pos.getZ() + 0.5,
                    30, 0.1, 0.1, 0.1, 0.0);

            SoundEvent rustleSound = ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_BED_LEAVES_RUSTLE_SOUNDS, world.getRandom());
            if (rustleSound != null) {
                world.playSound(null, pos, rustleSound, SoundCategory.BLOCKS, 0.2f, 1.8f);
            }

            // In 1.20.1, use the 'hand' passed to the method
            ItemStack heldStack = player.getStackInHand(hand);

            // --- 3. Unlinking Logic (Sneak + Bed Avoidance Item) ---
            if (player.isSneaking() && ConfigDataCache.isBedAvoidanceFood(heldStack)) {
                bedEntity.unlinkHamster(player);
                return ActionResult.SUCCESS;
            }

            // --- 4. Bed Avoidance Food Interaction ---
            if (ConfigDataCache.isBedAvoidanceFood(heldStack)) {
                // Wake up hamster if bed is occupied
                if (state.get(OCCUPIED)) {
                    bedEntity.getLinkedHamsterUuid().ifPresent(uuid -> {
                        Entity entity = ((ServerWorld) world).getEntity(uuid);
                        if (entity instanceof HamsterEntity hamster && hamster.isSleeping()) {
                            hamster.wakeUpFromBed(true); // Categorize as manual wake-up
                        }
                    });
                }

                // --- 5. Apply repellent effect ---
                bedEntity.applyRepellentEffect();
                player.sendMessage(Text.translatable("message.adorablehamsterpets.bed_repellent_applied").formatted(Formatting.RED), true);
                world.playSound(null, pos, SoundEvents.BLOCK_HONEY_BLOCK_SLIDE, SoundCategory.BLOCKS, 1.2f, 0.8f);
                ((ServerWorld)world).spawnParticles(ParticleTypes.SMOKE, pos.getX() + 0.5, pos.getY() + 0.7, pos.getZ() + 0.5, 15, 0.4, 0.3, 0.4, 0.01);
                if (!player.getAbilities().creativeMode) {
                    heldStack.decrement(1);
                }
                return ActionResult.SUCCESS;
            }

            // --- 6. Lure Item Interaction ---
            if (ConfigDataCache.isLureItem(heldStack)) {
                if (state.get(UPSIDE_DOWN)) {
                    player.sendMessage(Text.translatable("message.adorablehamsterpets.bed_upside_down_lure_fail").formatted(Formatting.RED), true);
                    world.playSound(null, pos, SoundEvents.BLOCK_DISPENSER_FAIL, SoundCategory.BLOCKS, 0.5f, 1.5f);
                    return ActionResult.SUCCESS;
                }

                boolean wasRepellentActive = !bedEntity.isSleepingAllowed();
                if (wasRepellentActive) {
                    bedEntity.setAllowSleep(true);
                }

                boolean lureWasSuccessful = bedEntity.lureHamsterToBed(player, heldStack);

                if (wasRepellentActive) {
                    player.sendMessage(Text.translatable("message.adorablehamsterpets.bed_repellent_removed").formatted(Formatting.GREEN), true);
                } else if (lureWasSuccessful) {
                    bedEntity.getLinkedHamsterName().ifPresent(name ->
                            player.sendMessage(Text.translatable("message.adorablehamsterpets.lure_to_bed_success", name), true)
                    );
                }

                if (!player.getAbilities().creativeMode && Configs.AHP.consumeLureItem) {
                    heldStack.decrement(1);
                }
                return ActionResult.SUCCESS;
            }

            // --- 7. Sneak Action: Cycle Wander Distance ---
            if (player.isSneaking()) {
                bedEntity.cycleWanderDistance(player);
                return ActionResult.SUCCESS;
            }

            // --- 8. Default Action: Toggle Wander Mode ---
            bedEntity.toggleWanderMode(player);
            return ActionResult.SUCCESS;
        }

        return ActionResult.FAIL;
    }

    @Override
    public void onStateReplaced(BlockState state, World world, BlockPos pos, BlockState newState, boolean moved) {
        if (!state.isOf(newState.getBlock())) {
            if (!world.isClient()) {
                // Play Leaf Rustling sound, spawn particles with wood variant
                SoundEvent rustleSound = ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_BED_LEAVES_RUSTLE_SOUNDS, world.getRandom());
                if (rustleSound != null) {
                    world.playSound(null, pos, rustleSound, SoundCategory.BLOCKS, 0.3f, 1.5f);
                }
                ((ServerWorld)world).spawnParticles(ModParticles.getForVariant(state.get(WOOD_VARIANT)),
                        pos.getX() + 0.5, pos.getY() + 0.2, pos.getZ() + 0.5,
                        30, 0.1, 0.1, 0.1, 0.0);

                BlockEntity blockEntity = world.getBlockEntity(pos);
                if (blockEntity instanceof HamsterBedBlockEntity bedEntity) {
                    ServerWorld serverWorld = (ServerWorld) world;
                    bedEntity.getLinkedHamsterUuid().ifPresent(uuid -> {
                        Entity entity = serverWorld.getEntity(uuid);
                        if (entity instanceof HamsterEntity hamster) {
                            hamster.setWanderModeActive(false);
                            hamster.setLinkedBedPos(Optional.empty());
                            if (hamster.isSleeping()) {
                                hamster.wakeUpFromBed(true); // Manual wake-up
                            }
                            if (hamster.getOwner() instanceof PlayerEntity owner) {
                                if (Configs.AHP.enableBedBreakMessage) {
                                    owner.sendMessage(Text.translatable("message.adorablehamsterpets.bed_broken").formatted(Formatting.RED), true);
                                }
                            }
                        }
                    });
                }
            }
        }
        super.onStateReplaced(state, world, pos, newState, moved);
    }

    @Nullable
    @Override
    public <T extends BlockEntity> BlockEntityTicker<T> getTicker(World world, BlockState state, BlockEntityType<T> type) {
        if (world.isClient()) {
            return checkType(type, ModBlockEntities.HAMSTER_BED_BLOCK_ENTITY.get(), (world1, pos, state1, be) -> {
                if (state1.get(UPSIDE_DOWN)) {
                    if (world1.random.nextInt(35) == 0) { // Chance to spawn particles
                        double x = pos.getX() + world1.random.nextDouble();
                        double y = pos.getY() + 0.6; // Spawn slightly below the block, offset inverted since block is inverted
                        double z = pos.getZ() + world1.random.nextDouble();

                        // Spawn Particles with wood variant
                        world1.addParticle(ModParticles.getForVariant(state1.get(WOOD_VARIANT)), x, y, z, 0, HamsterBeddingParticle.BEDDING_ITEM_FLAG, 0);
                    }
                }
            });
        }
        return null;
    }

    @Override
    public ItemStack getPickStack(BlockView world, BlockPos pos, BlockState state) {
        // Called by Jade and middle-mouse-click; should return the correct item variant.
        WoodVariant variant = state.get(WOOD_VARIANT);
        Item item = ModItems.HAMSTER_BED_ITEMS.get(variant).get();
        return new ItemStack(item);
    }

    @Override
    public List<ItemStack> getDroppedStacks(BlockState state, LootContextParameterSet.Builder builder) {
        WoodVariant variant = state.get(WOOD_VARIANT);
        Item itemToDrop = ModItems.HAMSTER_BED_ITEMS.get(variant).get();
        ItemStack stack = new ItemStack(itemToDrop);

        BlockEntity blockEntity = builder.get(LootContextParameters.BLOCK_ENTITY);
        // 1.20.1 NBT logic
        if (blockEntity instanceof HamsterBedBlockEntity bedEntity) {
            NbtCompound nbt = stack.getOrCreateNbt(); // Prepare NBT

            bedEntity.getLinkedHamsterUuid().ifPresent(uuid ->
                    nbt.putUuid(ModNbtKeys.LINKED_HAMSTER_UUID, uuid));
            bedEntity.getLinkedHamsterName().ifPresent(name ->
                    nbt.putString(ModNbtKeys.LINKED_HAMSTER_NAME, Text.Serializer.toJson(name)));
            nbt.putString(ModNbtKeys.WANDER_DISTANCE, bedEntity.getWanderDistance().asString());
        }
        return List.of(stack);
    }
}
```

`SunflowerBlock.java`
```java
package net.dawson.adorablehamsterpets.block.custom;

// (Imports omitted to save token count)

public class SunflowerBlock extends TallFlowerBlock implements Fertilizable {

    public static final BooleanProperty HAS_SEEDS = BooleanProperty.of("has_seeds");

    public SunflowerBlock(Settings settings) {
        super(settings);
        this.setDefaultState(this.stateManager.getDefaultState()
                .with(HALF, DoubleBlockHalf.LOWER)
                .with(HAS_SEEDS, true));
    }

    @Override
    protected void appendProperties(StateManager.Builder<Block, BlockState> builder) {
        super.appendProperties(builder);
        builder.add(HAS_SEEDS);
    }

    @Override
    public boolean hasRandomTicks(BlockState state) {
        return state.get(HALF) == DoubleBlockHalf.UPPER && !state.get(HAS_SEEDS);
    }

    @Override
    public void randomTick(BlockState state, ServerWorld world, BlockPos pos, Random random) {
        if (state.get(HALF) == DoubleBlockHalf.UPPER && !state.get(HAS_SEEDS)) {
            // Access the stored config instance from the main mod class
            final AhpWorldGenConfig config = AdorableHamsterPets.WORLD_GEN_CONFIG;

            double modifier = config.sunflowerRegrowthModifier.get();
            modifier = Math.max(0.1, modifier);

            int baseRegrowthChanceDenominator = 150;
            int effectiveDenominator = (int) Math.round(baseRegrowthChanceDenominator * modifier);
            effectiveDenominator = Math.max(1, effectiveDenominator);

            if (random.nextInt(effectiveDenominator) == 0) {
                world.setBlockState(pos, state.with(HAS_SEEDS, true), Block.NOTIFY_LISTENERS);
            }
        }
    }

    @Override
    public ActionResult onUse(BlockState state, World world, BlockPos pos, PlayerEntity player, Hand hand, BlockHitResult hit) {
        // Redirect clicks on lower half to upper half
        if (state.get(HALF) == DoubleBlockHalf.LOWER) {
            BlockPos topPos = pos.up();
            BlockState topState = world.getBlockState(topPos);
            // Check if the top block is indeed the upper half of this sunflower type
            if (topState.isOf(this) && topState.get(HALF) == DoubleBlockHalf.UPPER) {
                // Call onUse on the top block's state and position
                return this.onUse(topState, world, topPos, player, hand, hit);
            }
            return ActionResult.PASS;
        }

        // Logic for the UPPER half
        if (state.get(HAS_SEEDS)) {
            if (!world.isClient) {
                int seedAmount = world.random.nextInt(3) + 1; // 1-3 seeds
                ItemStack seedStack = new ItemStack(ModItems.SUNFLOWER_SEEDS.get(), seedAmount);
                ItemScatterer.spawn(world, (double)pos.getX() + 0.5, (double)pos.getY() + 0.5, (double)pos.getZ() + 0.5, seedStack);

                world.setBlockState(pos, state.with(HAS_SEEDS, false), Block.NOTIFY_LISTENERS);
                world.playSound(null, pos, SoundEvents.BLOCK_SWEET_BERRY_BUSH_PICK_BERRIES, SoundCategory.BLOCKS, 1.0f, 1.0f);
            }
            return ActionResult.success(world.isClient);
        }

        return ActionResult.PASS;
    }


    @Override
    public void onPlaced(World world, BlockPos pos, BlockState state, @Nullable LivingEntity placer, ItemStack itemStack) {
        // Let the parent class place the top half FIRST
        super.onPlaced(world, pos, state, placer, itemStack);

        // Now, find the top half and modify its state if on the server
        if (!world.isClient) {
            BlockPos topPos = pos.up();
            BlockState topState = world.getBlockState(topPos);

            if (topState.isOf(this) && topState.get(HALF) == DoubleBlockHalf.UPPER) {
                // Set the state to NO seeds initially
                world.setBlockState(topPos, topState.with(HAS_SEEDS, false), Block.NOTIFY_LISTENERS);
            }
        }
    }


    @Override
    public ItemStack getPickStack(BlockView world, BlockPos pos, BlockState state) {
        return new ItemStack(Items.SUNFLOWER);
    }

    // --- Fertilizable Implementation ---
    @Override
    public boolean isFertilizable(WorldView world, BlockPos pos, BlockState state, boolean isClient) {
        // Only the bottom half can be bonemealed to grow the top
        return state.get(HALF) == DoubleBlockHalf.LOWER && world.getBlockState(pos.up()).isAir();
    }

    @Override
    public boolean canGrow(World world, Random random, BlockPos pos, BlockState state) {
        // Can only grow if it's the lower half and the space above is air
        return state.get(HALF) == DoubleBlockHalf.LOWER && world.isAir(pos.up());
    }

    @Override
    public void grow(ServerWorld world, Random random, BlockPos pos, BlockState state) {
        // Standard TallPlantBlock grow logic places the top half
        TallPlantBlock.placeAt(world, this.getDefaultState().with(HALF, DoubleBlockHalf.UPPER).with(HAS_SEEDS, false), pos.up(), 2);
        // Ensure the newly placed top half starts WITHOUT seeds
    }
    // --- End Fertilizable ---

    @Override
    public BlockState getStateForNeighborUpdate(BlockState state, Direction direction, BlockState neighborState, WorldAccess world, BlockPos pos, BlockPos neighborPos) {
        // Standard TallPlantBlock neighbor update logic handles breaking
        return super.getStateForNeighborUpdate(state, direction, neighborState, world, pos, neighborPos);
    }
}
```

`WildCucumberBushBlock.java`
```java
package net.dawson.adorablehamsterpets.block.custom;

// (Imports omitted to save token count)

/**
 * Represents a wild cucumber bush block that can be harvested for seeds and regrows over time.
 */
public class WildCucumberBushBlock extends PlantBlock {
    // --- Constants and Static Fields ---
    public static final BooleanProperty SEEDED = BooleanProperty.of("seeded");

    private static final VoxelShape SEEDLESS_SHAPE = Block.createCuboidShape(3.0, 0.0, 3.0, 13.0, 8.0, 13.0);
    private static final VoxelShape SEEDED_SHAPE = Block.createCuboidShape(1.0, 0.0, 1.0, 15.0, 16.0, 15.0);

    // --- Constructor ---
    public WildCucumberBushBlock(Settings settings) {
        super(settings);
        this.setDefaultState(this.stateManager.getDefaultState().with(SEEDED, true));
    }

    // --- Overridden Methods ---
    @Override
    public ItemStack getPickStack(BlockView world, BlockPos pos, BlockState state) {
        return new ItemStack(ModItems.CUCUMBER_SEEDS.get());
    }

    @Override
    public VoxelShape getOutlineShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context) {
        return state.get(SEEDED) ? SEEDED_SHAPE : SEEDLESS_SHAPE;
    }

    @Override
    public boolean hasRandomTicks(BlockState state) {
        return !state.get(SEEDED); // Only ticks when seedless to regrow
    }

    @Override
    public void randomTick(BlockState state, ServerWorld world, BlockPos pos, Random random) {
        // --- Regrowth Logic ---
        if (!state.get(SEEDED)) {
            final AhpWorldGenConfig config = AdorableHamsterPets.WORLD_GEN_CONFIG;
            double modifier = config.wildBushRegrowthModifier.get();
            modifier = Math.max(0.1, modifier); // Ensure positive modifier

            int baseRegrowthChanceDenominator = 5;
            int effectiveDenominator = (int) Math.round(baseRegrowthChanceDenominator * modifier);
            effectiveDenominator = Math.max(1, effectiveDenominator);

            if (world.getBaseLightLevel(pos.up(), 0) >= 9 && random.nextInt(effectiveDenominator) == 0) {
                BlockState newState = state.with(SEEDED, true);
                world.setBlockState(pos, newState, Block.NOTIFY_LISTENERS);
                world.emitGameEvent(GameEvent.BLOCK_CHANGE, pos, GameEvent.Emitter.of(newState));
            }
        }
    }

    @Override
    public ActionResult onUse(BlockState state, World world, BlockPos pos, PlayerEntity player, Hand hand, BlockHitResult hit) {
        if (state.get(SEEDED)) {
            if (!world.isClient) {
                int seedAmount = 1 + world.random.nextInt(2);
                dropStack(world, pos, new ItemStack(ModItems.CUCUMBER_SEEDS.get(), seedAmount));

                world.playSound(null, pos, SoundEvents.BLOCK_SWEET_BERRY_BUSH_PICK_BERRIES, SoundCategory.BLOCKS, 1.0F, 0.8F + world.random.nextFloat() * 0.4F);

                BlockState newState = state.with(SEEDED, false);
                world.setBlockState(pos, newState, Block.NOTIFY_LISTENERS);
                world.emitGameEvent(GameEvent.BLOCK_CHANGE, pos, GameEvent.Emitter.of(player, newState));

                return ActionResult.SUCCESS;
            }
            return ActionResult.success(world.isClient);
        }
        return ActionResult.PASS;
    }

    @Override
    protected void appendProperties(StateManager.Builder<Block, BlockState> builder) {
        builder.add(SEEDED);
    }

    @Override
    protected boolean canPlantOnTop(BlockState floor, BlockView world, BlockPos pos) {
        return floor.isOf(Blocks.GRASS_BLOCK) || floor.isOf(Blocks.DIRT) || floor.isOf(Blocks.COARSE_DIRT)
                || floor.isOf(Blocks.PODZOL) || floor.isOf(Blocks.FARMLAND) || floor.isOf(Blocks.CLAY)
                || floor.isOf(Blocks.MOSS_BLOCK) || floor.isOf(Blocks.MUD);
    }
}
```

`WildGreenBeanBushBlock.java`
```java
package net.dawson.adorablehamsterpets.block.custom;

// (Imports omitted to save token count)

/**
 * Represents a wild green bean bush block that can be harvested for seeds and regrows over time.
 */
public class WildGreenBeanBushBlock extends PlantBlock {
    // --- Constants and Static Fields ---
    public static final BooleanProperty SEEDED = BooleanProperty.of("seeded");

    private static final VoxelShape SEEDLESS_SHAPE = Block.createCuboidShape(3.0, 0.0, 3.0, 13.0, 8.0, 13.0);
    private static final VoxelShape SEEDED_SHAPE = Block.createCuboidShape(1.0, 0.0, 1.0, 15.0, 16.0, 15.0);

    // --- Constructor ---
    public WildGreenBeanBushBlock(Settings settings) {
        super(settings);
        this.setDefaultState(this.stateManager.getDefaultState().with(SEEDED, true));
    }

    // --- Overridden Methods ---
    @Override
    public ItemStack getPickStack(BlockView world, BlockPos pos, BlockState state) {
        return new ItemStack(ModItems.GREEN_BEAN_SEEDS.get());
    }

    @Override
    public VoxelShape getOutlineShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context) {
        return state.get(SEEDED) ? SEEDED_SHAPE : SEEDLESS_SHAPE;
    }

    @Override
    public boolean hasRandomTicks(BlockState state) {
        return !state.get(SEEDED); // Only ticks when seedless to regrow
    }

    @Override
    public void randomTick(BlockState state, ServerWorld world, BlockPos pos, Random random) {
        // --- Regrowth Logic ---
        if (!state.get(SEEDED)) {
            final AhpWorldGenConfig config = AdorableHamsterPets.WORLD_GEN_CONFIG;
            double modifier = config.wildBushRegrowthModifier.get();
            modifier = Math.max(0.1, modifier); // Ensure positive modifier

            int baseRegrowthChanceDenominator = 5;
            int effectiveDenominator = (int) Math.round(baseRegrowthChanceDenominator * modifier);
            effectiveDenominator = Math.max(1, effectiveDenominator);

            if (world.getBaseLightLevel(pos.up(), 0) >= 9 && random.nextInt(effectiveDenominator) == 0) {
                BlockState newState = state.with(SEEDED, true);
                world.setBlockState(pos, newState, Block.NOTIFY_LISTENERS);
                world.emitGameEvent(GameEvent.BLOCK_CHANGE, pos, GameEvent.Emitter.of(newState));
            }
        }
    }

    @Override
    public ActionResult onUse(BlockState state, World world, BlockPos pos, PlayerEntity player, Hand hand, BlockHitResult hit) {
        if (state.get(SEEDED)) {
            if (!world.isClient) {
                int seedAmount = 1 + world.random.nextInt(2);
                dropStack(world, pos, new ItemStack(ModItems.GREEN_BEAN_SEEDS.get(), seedAmount));

                world.playSound(null, pos, SoundEvents.BLOCK_SWEET_BERRY_BUSH_PICK_BERRIES, SoundCategory.BLOCKS, 1.0F, 0.8F + world.random.nextFloat() * 0.4F);

                BlockState newState = state.with(SEEDED, false);
                world.setBlockState(pos, newState, Block.NOTIFY_LISTENERS);
                world.emitGameEvent(GameEvent.BLOCK_CHANGE, pos, GameEvent.Emitter.of(player, newState));

                return ActionResult.SUCCESS;
            }
            return ActionResult.success(world.isClient);
        }
        return ActionResult.PASS;
    }

    @Override
    protected void appendProperties(StateManager.Builder<Block, BlockState> builder) {
        builder.add(SEEDED);
    }

    @Override
    protected boolean canPlantOnTop(BlockState floor, BlockView world, BlockPos pos) {
        return floor.isOf(Blocks.GRASS_BLOCK) || floor.isOf(Blocks.DIRT) || floor.isOf(Blocks.COARSE_DIRT)
                || floor.isOf(Blocks.PODZOL) || floor.isOf(Blocks.FARMLAND) || floor.isOf(Blocks.CLAY)
                || floor.isOf(Blocks.MOSS_BLOCK) || floor.isOf(Blocks.MUD);
    }
}
```

`WoodVariant.java`
```java
package net.dawson.adorablehamsterpets.block.custom;

// (Imports omitted to save token count)

public enum WoodVariant implements StringIdentifiable {
    ACACIA("acacia"),
    BAMBOO("bamboo"),
    BIRCH("birch"),
    CHERRY("cherry"),
    DARK_OAK("dark_oak"),
    JUNGLE("jungle"),
    MANGROVE("mangrove"),
    OAK("oak"),
    PALE_OAK("pale_oak"),
    SPRUCE("spruce");

    public static final Codec<WoodVariant> CODEC = StringIdentifiable.createCodec(WoodVariant::values);
    private final String name;

    WoodVariant(String name) {
        this.name = name;
    }

    @Override
    public String asString() {
        return this.name;
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/block/entity/`
`HamsterBedBlockEntity.java`
```java
package net.dawson.adorablehamsterpets.block.entity;

// (Imports omitted to save token count)

public class HamsterBedBlockEntity extends BlockEntity implements GeoBlockEntity {
    private Optional<UUID> linkedHamsterUuid = Optional.empty();
    private Optional<Text> linkedHamsterName = Optional.empty();
    private WanderDistance wanderDistance = WanderDistance.MEDIUM;
    private boolean isNewlyPlaced = true;
    private boolean allowSleep = true;

    // --- Geckolib Stuff ---
    private final AnimatableInstanceCache cache = GeckoLibUtil.createInstanceCache(this);

    @Override
    public void registerControllers(AnimatableManager.ControllerRegistrar registrar) {
        AnimationController<HamsterBedBlockEntity> controller = new AnimationController<>(this, "hamster_bed_controller", 2, state -> {
            BlockState blockState = state.getAnimatable().getCachedState();
            if (blockState.get(HamsterBedBlock.OCCUPIED)) {
                return state.setAndContinue(RawAnimation.begin().thenLoop("anim_bed_idle_waving_occupied"));
            } else {
                return state.setAndContinue(RawAnimation.begin().thenLoop("anim_bed_idle_waving_unoccupied"));
            }
        });

        // Register one-shot animations
        controller.triggerableAnim("anim_bed_being_placed", RawAnimation.begin().thenPlay("anim_bed_being_placed"));
        controller.triggerableAnim("anim_bed_becoming_occupied", RawAnimation.begin().thenPlay("anim_bed_becoming_occupied"));
        controller.triggerableAnim("anim_bed_becoming_unoccupied", RawAnimation.begin().thenPlay("anim_bed_becoming_unoccupied"));
        controller.triggerableAnim("anim_bed_interact_occupied", RawAnimation.begin().thenPlay("anim_bed_interact_occupied"));
        controller.triggerableAnim("anim_bed_interact_unoccupied", RawAnimation.begin().thenPlay("anim_bed_interact_unoccupied"));

        registrar.add(controller);
    }

    @Override
    public AnimatableInstanceCache getAnimatableInstanceCache() {
        return this.cache;
    }

    // --- Jade HUD info ---
    public Optional<UUID> getLinkedHamsterUuid() {
        return this.linkedHamsterUuid;
    }

    public Optional<Text> getLinkedHamsterName() {
        return this.linkedHamsterName;
    }

    public boolean isWanderModeActive() {
        if (world instanceof ServerWorld serverWorld && linkedHamsterUuid.isPresent()) {
            Entity entity = serverWorld.getEntity(linkedHamsterUuid.get());
            if (entity instanceof HamsterEntity hamster) {
                return hamster.isWanderModeActive();
            }
        }
        return false; // Default to false if hamster not found or on client
    }

    // --- Everything Else ---
    public boolean isNewlyPlaced() {
        return this.isNewlyPlaced;
    }

    public void markAsUsed() {
        this.isNewlyPlaced = false;
    }

    public boolean isSleepingAllowed() {
        return this.allowSleep;
    }

    public void setAllowSleep(boolean allow) {
        this.allowSleep = allow;
        markDirty();
    }

    public void applyRepellentEffect() {
        this.setAllowSleep(false);
    }


    public HamsterBedBlockEntity(BlockPos pos, BlockState state) {
        super(ModBlockEntities.HAMSTER_BED_BLOCK_ENTITY.get(), pos, state);
    }

    public void setLinkedHamster(UUID uuid, Text name, WanderDistance distance) {
        this.linkedHamsterUuid = Optional.of(uuid);
        this.linkedHamsterName = Optional.of(name);
        this.wanderDistance = distance;
        markDirty();
    }

    public WanderDistance getWanderDistance() {
        return this.wanderDistance;
    }

    public void toggleWanderMode(PlayerEntity player) {
        if (world instanceof ServerWorld serverWorld && linkedHamsterUuid.isPresent()) {
            Entity entity = serverWorld.getEntity(linkedHamsterUuid.get());
            if (entity instanceof HamsterEntity hamster) {
                boolean newMode = !hamster.isWanderModeActive();
                hamster.setWanderModeActive(newMode);

                // If disabling wander mode while hamster is in bed, wake it up
                if (!newMode && getCachedState().get(HamsterBedBlock.OCCUPIED) && hamster.isSleeping()) {
                    hamster.wakeUpFromBed(true);
                }

                Text status = newMode ? Text.literal("ENABLED") : Text.literal("DISABLED");
                player.sendMessage(Text.translatable("message.adorablehamsterpets.wander_mode_set", hamster.getName(), status), true);
                world.playSound(null, getPos(), SoundEvents.UI_BUTTON_CLICK.value(), SoundCategory.BLOCKS, 0.5f, newMode ? 1.2f : 0.8f);
            }
        }
    }

    public void cycleWanderDistance(PlayerEntity player) {
        WanderDistance[] values = WanderDistance.values();
        this.wanderDistance = values[(this.wanderDistance.ordinal() + 1) % values.length];
        markDirty();
        if (linkedHamsterName.isPresent()) {
            player.sendMessage(Text.translatable("message.adorablehamsterpets.wander_distance_set", linkedHamsterName.get(), this.wanderDistance.asString()), true);
            world.playSound(null, getPos(), SoundEvents.UI_BUTTON_CLICK.value(), SoundCategory.BLOCKS, 0.5f, 1.0f);
        }
    }

    public boolean lureHamsterToBed(PlayerEntity player, ItemStack lureItem) {
        if (world instanceof ServerWorld serverWorld && linkedHamsterUuid.isPresent()) {
            Entity entity = serverWorld.getEntity(linkedHamsterUuid.get());
            if (entity instanceof HamsterEntity hamster) {
                // Re-enable wander mode for this specific hamster/bed pair
                if (!hamster.isWanderModeActive()) {
                    hamster.setWanderModeActive(true);
                }

                if (hamster.isSitting() || hamster.isSleeping()) {
                    player.sendMessage(Text.translatable("message.adorablehamsterpets.lure_to_bed_fail").formatted(Formatting.RED), true);
                    return false;
                }

                hamster.lureToBed();

                // Play dynamic sound and particles
                SoundEvent lureSound = ModSounds.getDynamicItemSound(lureItem);
                world.playSound(null, getPos(), lureSound, SoundCategory.BLOCKS, 1.0f, 1.0f);
                ((ServerWorld)world).spawnParticles(new ItemStackParticleEffect(ParticleTypes.ITEM, lureItem),
                        getPos().getX() + 0.5, getPos().getY() + 0.7, getPos().getZ() + 0.5,
                        8, 0.25D, 0.25D, 0.25D, 0.05);

                return true;
            }
        }
        return false;
    }

    public void unlinkHamster(PlayerEntity player) {
        if (world instanceof ServerWorld serverWorld && linkedHamsterUuid.isPresent()) {
            UUID uuidToUnlink = linkedHamsterUuid.get();
            Text hamsterNameToUnlink = linkedHamsterName.orElse(Text.literal("A hamster"));

            // Wake up the hamster if it's sleeping in the bed
            if (getCachedState().get(HamsterBedBlock.OCCUPIED)) {
                Entity entity = serverWorld.getEntity(uuidToUnlink);
                if (entity instanceof HamsterEntity hamster && hamster.isSleeping()) {
                    hamster.wakeUpFromBed(true);
                }
            }

            // Clear data on the block entity
            this.linkedHamsterUuid = Optional.empty();
            this.linkedHamsterName = Optional.empty();
            this.wanderDistance = Configs.AHP.defaultWanderDistance.get(); // Reset to default
            markDirty();

            // Update the hamster entity
            Entity entity = serverWorld.getEntity(uuidToUnlink);
            if (entity instanceof HamsterEntity hamster) {
                hamster.setWanderModeActive(false);
                hamster.setLinkedBedPos(Optional.empty());
            }

            // Feedback
            player.sendMessage(Text.translatable("message.adorablehamsterpets.bed_unlinked", hamsterNameToUnlink).formatted(Formatting.YELLOW), true);
            world.playSound(null, getPos(), SoundEvents.ENTITY_SHEEP_SHEAR, SoundCategory.BLOCKS, 1.0f, 1.2f);
        }
    }

    @Override
    public void writeNbt(NbtCompound nbt) {
        super.writeNbt(nbt);
        linkedHamsterUuid.ifPresent(uuid -> nbt.putUuid("LinkedHamsterUuid", uuid));
        // Use Text.Serializer.toJson(Text) for 1.20.1
        linkedHamsterName.ifPresent(name -> nbt.putString("LinkedHamsterName", Text.Serializer.toJson(name)));
        nbt.putString("WanderDistance", wanderDistance.asString());
        nbt.putBoolean("IsNewlyPlaced", this.isNewlyPlaced);

        // If an upside down bed is broken and replaced right-side up, set "AllowSleep" to true
        if (!this.getCachedState().get(HamsterBedBlock.UPSIDE_DOWN)) {
            nbt.putBoolean("AllowSleep", this.allowSleep);
        }
    }

    @Override
    public void readNbt(NbtCompound nbt) {
        super.readNbt(nbt);
        if (nbt.containsUuid("LinkedHamsterUuid")) {
            this.linkedHamsterUuid = Optional.of(nbt.getUuid("LinkedHamsterUuid"));
        } else {
            this.linkedHamsterUuid = Optional.empty();
        }

        if (nbt.contains("LinkedHamsterName")) {
            // Use Text.Serializer.fromJson(String) for 1.20.1
            this.linkedHamsterName = Optional.ofNullable(Text.Serializer.fromJson(nbt.getString("LinkedHamsterName")));
        } else {
            this.linkedHamsterName = Optional.empty();
        }

        try {
            this.wanderDistance = WanderDistance.valueOf(nbt.getString("WanderDistance").toUpperCase());
        } catch (IllegalArgumentException e) {
            this.wanderDistance = WanderDistance.MEDIUM;
        }

        this.isNewlyPlaced = nbt.contains("IsNewlyPlaced") ? nbt.getBoolean("IsNewlyPlaced") : false;
        this.allowSleep = !nbt.contains("AllowSleep") || nbt.getBoolean("AllowSleep");
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/entity/`
`ModEntities.java`
```java
package net.dawson.adorablehamsterpets.entity;

// (Imports omitted to save token count)

public class ModEntities {

    public static final DeferredRegister<EntityType<?>> ENTITY_TYPES = DeferredRegister.create(AdorableHamsterPets.MOD_ID, RegistryKeys.ENTITY_TYPE);

    public static final RegistrySupplier<EntityType<HamsterEntity>> HAMSTER = ENTITY_TYPES.register(
            Identifier.of(AdorableHamsterPets.MOD_ID, "hamster"),
            () -> EntityType.Builder.create(HamsterEntity::new, SpawnGroup.CREATURE)
                    .setDimensions(0.5F, 0.5F)
                    .build("hamster")
    );

    public static void register() {
        ENTITY_TYPES.register();
    }
}
```

`ImplementedInventory.java`
```java
package net.dawson.adorablehamsterpets.entity;

// (Imports omitted to save token count)

public interface ImplementedInventory extends Inventory {
    /**
     * Retrieves the item list of this inventory.
     * Must return the same instance every time it's called.
     */
    DefaultedList<ItemStack> getItems();

    /**
     * Creates and returns a new DefaultedList of the correct size
     * for this inventory.
     */
    static DefaultedList<ItemStack> create(int size) {
        return DefaultedList.ofSize(size, ItemStack.EMPTY);
    }

    /**
     * Gets the inventory size.
     * Defaults to the item list size.
     * @see Inventory#size()
     */
    @Override
    default int size() {
        return getItems().size();
    }

    /**
     * Checks if the inventory is empty.
     * Defaults to checking if every stack in the item list is empty.
     * @see Inventory#isEmpty()
     */
    @Override
    default boolean isEmpty() {
        for (int i = 0; i < size(); i++) {
            ItemStack stack = getStack(i);
            if (!stack.isEmpty()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Gets the stack currently at the given slot.
     * Defaults to simply getting it from the item list.
     * @see Inventory#getStack(int)
     */
    @Override
    default ItemStack getStack(int slot) {
        return getItems().get(slot);
    }

    /**
     * Removes a stack from the given slot and returns it.
     * This implementation uses Inventories.splitStack to correctly handle the amount.
     * @see Inventory#removeStack(int, int)
     * @param slot  The slot to remove from.
     * @param amount  The amount to remove.
     * @return The removed stack.
     */
    @Override
    default ItemStack removeStack(int slot, int amount) {
        // Use helper method that respects the 'amount' parameter.
        ItemStack result = Inventories.splitStack(getItems(), slot, amount);
        if (!result.isEmpty()) {
            markDirty();
        }
        return result;
    }

    /**
     * Removes the stack currently at the given slot and returns it.
     * Defaults to {@link DefaultedList removeStack(int)} and marks the inventory as dirty.
     * @see Inventory#removeStack(int)
     * @param slot  The slot to remove from.
     * @return The removed stack.
     */
    @Override
    default ItemStack removeStack(int slot) {
        markDirty();
        return Inventories.removeStack(getItems(), slot);
    }

    /**
     * Replaces the stack in the given slot with the provided stack.
     * Defaults to {@link DefaultedList#set(int, Object)} and marks the inventory as dirty.
     * @see Inventory#setStack(int, ItemStack)
     * @param slot  The slot to set in.
     * @param stack  The stack to set to.
     */
    @Override
    default void setStack(int slot, ItemStack stack) {
        getItems().set(slot, stack);
        markDirty();
    }

    /**
     * Clears all stacks in the inventory.
     * Defaults to {@link DefaultedList#clear()} and marks the inventory as dirty.
     * @see Inventory#clear()
     */
    @Override
    default void clear() {
        getItems().clear();
        markDirty();
    }

    /**
     * Marks the state as dirty.
     * Must be called after doing anything that modifies the inventory.
     * <p>
     * For implementors, this method is usually implemented simply by calling {@link net.minecraft.block.entity.BlockEntity#markDirty()}.
     * @see Inventory#markDirty()
     */
    @Override
    default void markDirty() {
        // Client-side inventories do not need to be saved.
    }

    /**
     * Gets the maximum stack size for items in this Inventory.
     * Defaults to 64
     * @see Inventory#getMaxCountPerStack()
     */
    @Override
    default int getMaxCountPerStack() {
        return 64;
    }

    /**
     * Called when a user starts using the inventory.
     * No default implementation.
     * @see Inventory#onOpen(net.minecraft.entity.player.PlayerEntity)
     */
    @Override
    default void onOpen(net.minecraft.entity.player.PlayerEntity player) {
    }

    /**
     * Called when a user stops using the inventory.
     * No default implementation.
     * @see Inventory#onClose(net.minecraft.entity.player.PlayerEntity)
     */
    @Override
    default void onClose(net.minecraft.entity.player.PlayerEntity player) {
    }

    /**
     * Check if the given player can use this inventory.
     * Defaults to always return true because BlockInventories are generally available to be used by anyone.
     * @see Inventory#canPlayerUse(net.minecraft.entity.player.PlayerEntity)
     */
    @Override
    default boolean canPlayerUse(net.minecraft.entity.player.PlayerEntity player) {
        return true;
    }

    /**
     * Returns {@code true} if automation (specifically hopper) can insert to the bottom of the inventory.
     * @return {@code true} if automation can insert to the bottom of the inventory, {@code false} otherwise.
     * @see Inventory#isValid(int, ItemStack)
     */
    @Override
    default boolean isValid(int slot, ItemStack stack) {
        return true;
    }

    /**
     * Returns the property delegate of this inventory.
     * @return the property delegate of this inventory.
     * @see Inventory getPropertyDelegate()
     */

    default net.minecraft.screen.PropertyDelegate getPropertyDelegate() {
        return new net.minecraft.screen.ArrayPropertyDelegate(0);
    }
}
```

`ShoulderLocation.java`
```java
package net.dawson.adorablehamsterpets.entity;

public enum ShoulderLocation {
    RIGHT_SHOULDER,
    LEFT_SHOULDER,
    HEAD
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/entity/AI/`
`HamsterFleeGoal.java`
```java
package net.dawson.adorablehamsterpets.entity.AI;

// (Imports omitted to save token count)

public class HamsterFleeGoal<T extends LivingEntity> extends FleeEntityGoal<T> {

    // --- 1. Fields ---
    private final HamsterEntity hamster;
    // No other unique fields in this class

    // --- 2. Constructors ---
    public HamsterFleeGoal(
            HamsterEntity hamster,
            Class<T> fleeFromType,
            float distance,
            double slowSpeed,
            double fastSpeed
    ) {
        super(
                hamster,
                fleeFromType,
                distance,
                slowSpeed,
                fastSpeed,
                livingEntity -> shouldFlee(hamster, livingEntity) // Pass the static helper method directly
        );
        this.hamster = hamster; // Store the hamster instance
    }

    // --- 3. Public Static Helper Methods ---

    @Override
    public void start() {
        super.start();
        this.hamster.setActiveCustomGoalDebugName(this.getClass().getSimpleName());
    }

    @Override public void stop(){
        super.stop();
        if (this.hamster.getActiveCustomGoalDebugName().equals(this.getClass().getSimpleName())) { this.hamster.setActiveCustomGoalDebugName("None"); }
    }

    /**
     * Determines if a player is considered "safe" to a wild hamster,
     * meaning the hamster should not flee from them.
     * A player is safe if they are sneaking AND holding Sliced Cucumber.
     *
     * @param player The player to check.
     * @return True if the player is safe, false otherwise.
     */
    public static boolean isPlayerSafe(PlayerEntity player) {
        // --- 1. Sneaking Check ---
        // If the player is not sneaking, they are not considered safe.
        if (!player.isSneaking()) {
            return false;
        }
        // --- End 1. Sneaking Check ---

        // --- 2. Item Check ---
        // Check if the player is holding Sliced Cucumber in either hand.
        ItemStack mainHandStack = player.getMainHandStack();
        ItemStack offHandStack = player.getOffHandStack();
        boolean holdingCucumber = mainHandStack.isOf(ModItems.SLICED_CUCUMBER.get()) || offHandStack.isOf(ModItems.SLICED_CUCUMBER.get());
        // --- End 2. Item Check ---

        return holdingCucumber; // Player is safe only if sneaking AND holding cucumber
    }

    // --- 4. Private Static Helper Methods ---

    /**
     * Determines if the given hamster should flee from the specified living entity.
     * This method is used as the predicate for the FleeEntityGoal.
     *
     * @param hamster The hamster that might flee.
     * @param livingToFleeFrom The entity to potentially flee from.
     * @return True if the hamster should flee, false otherwise.
     */
    private static boolean shouldFlee(HamsterEntity hamster, LivingEntity livingToFleeFrom) {
        // --- 1. Tamed Check ---
        // Tamed hamsters do not use this flee logic.
        if (hamster.isTamed()) {
            return false;
        }
        // --- End 1. Tamed Check ---

        // --- 2. Hostile Entity Check ---
        // Always flee from hostile entities.
        if (livingToFleeFrom instanceof HostileEntity) {
            return true;
        }
        // --- End 2. Hostile Entity Check ---

        // --- 3. Player Entity Check ---
        // If the entity is a player, check if the player is considered "safe".
        // Flee if the player is NOT safe.
        if (livingToFleeFrom instanceof PlayerEntity player) {
            return !isPlayerSafe(player);
        }
        // --- End 3. Player Entity Check ---

        // --- 4. Default ---
        // Do not flee from other non-hostile, non-player entities.
        return false;
        // --- End 4. Default ---
    }
    // No other methods (canStart, shouldContinue, start, stop, tick) are overridden in this class, so the superclass FleeEntityGoal implementations are used.
}
```

`HamsterFollowOwnerGoal.java`
```java
package net.dawson.adorablehamsterpets.entity.AI;

// (Imports omitted to save token count)

public class HamsterFollowOwnerGoal extends FollowOwnerGoal {
    private final HamsterEntity hamster;
    private static final double BUFFED_FOLLOW_SPEED = 1.5D;

    public HamsterFollowOwnerGoal(HamsterEntity hamster, double speed, float minDistance, float maxDistance) {
        // In 1.20.1, the boolean is 'leavesAllowed'. We set it to true as a safe default.
        super(hamster, speed, minDistance, maxDistance, true);
        this.hamster = hamster;
    }

    @Override
    public boolean canStart() {
        if (!super.canStart()) {
            return false;
        }

        // --- 2. Apply  custom conditions ---
        if (this.hamster.isSitting() ||
                this.hamster.isSleeping() ||
                this.hamster.isKnockedOut() ||
                this.hamster.isSulking() ||
                this.hamster.isCelebratingDiamond() ||
                this.hamster.isCelebratingChase() ||
                this.hamster.isWanderModeActive()) {
            return false;
        }

        // The super.canStart() already checks the base minDistance.
        if (this.hamster.hasGreenBeanBuff()) {
            LivingEntity owner = ((FollowOwnerGoalAccessor) this).getOwner();
            if (owner != null) {
                // If buffed, require a larger distance to start following.
                return !(this.hamster.squaredDistanceTo(owner) < (double) ((((FollowOwnerGoalAccessor) this).getMinDistance() + 5.0F) * (((FollowOwnerGoalAccessor) this).getMinDistance() + 5.0F)));
            }
        }

        return true;
    }

    @Override
    public boolean shouldContinue() {
        // Custom state checks that should stop the goal immediately.
        if (this.hamster.isSitting() || this.hamster.isSleeping() || this.hamster.isKnockedOut() ||
                this.hamster.isSulking() || this.hamster.isCelebratingDiamond() || this.hamster.isCelebratingChase()) {
            return false;
        }

        // Let the vanilla logic handle the rest.
        return super.shouldContinue();
    }

    @Override
    public void start() {
        super.start();
        this.hamster.setActiveCustomGoalDebugName(this.getClass().getSimpleName() + (this.hamster.hasGreenBeanBuff() ? " (Zoomies)" : ""));
        AdorableHamsterPets.LOGGER.trace("[FollowGoal-{}] start: Goal has started. IsBuffed: {}", this.hamster.getId(), this.hamster.hasGreenBeanBuff());
    }

    @Override
    public void tick() {
        FollowOwnerGoalAccessor accessor = (FollowOwnerGoalAccessor) this;
        LivingEntity owner = accessor.getOwner();
        if (owner == null) return;

        this.hamster.getLookControl().lookAt(owner, 10.0F, this.hamster.getMaxLookPitchChange());

        int currentTicks = accessor.getUpdateCountdownTicks() - 1;
        accessor.setUpdateCountdownTicks(currentTicks);

        if (currentTicks <= 0) {
            accessor.setUpdateCountdownTicks(this.getTickCount(10));

            // --- Replicated Vanilla Teleport Logic ---
            if (this.hamster.squaredDistanceTo(owner) >= 144.0) {
                this.tryTeleport();
            } else {
                // --- Custom Pathfinding Logic ---
                if (this.hamster.hasGreenBeanBuff()) {
                    // "Zoomies" pathfinding
                    Vec3d targetPos = FuzzyTargeting.findTo(this.hamster, 8, 5, Vec3d.ofCenter(owner.getBlockPos()));
                    if (targetPos != null) {
                        this.hamster.getNavigation().startMovingTo(targetPos.x, targetPos.y, targetPos.z, BUFFED_FOLLOW_SPEED);
                    }
                } else {
                    // Standard pathfinding
                    this.hamster.getNavigation().startMovingTo(owner, accessor.getSpeed());
                }
            }
        }
    }

    @Override
    public void stop() {
        super.stop();
        if (this.hamster.getActiveCustomGoalDebugName().startsWith(this.getClass().getSimpleName())) {
            this.hamster.setActiveCustomGoalDebugName("None");
        }
    }

    // --- Private Helper Methods for Teleportation (Replicated from Vanilla) ---
    private void tryTeleport() {
        LivingEntity owner = ((FollowOwnerGoalAccessor) this).getOwner();
        if (owner == null) return;
        BlockPos blockPos = owner.getBlockPos();

        for(int i = 0; i < 10; ++i) {
            int j = this.getRandomInt(-3, 3);
            int k = this.getRandomInt(-1, 1);
            int l = this.getRandomInt(-3, 3);
            if (this.tryTeleportTo(blockPos.getX() + j, blockPos.getY() + k, blockPos.getZ() + l)) {
                return;
            }
        }
    }

    private boolean tryTeleportTo(int x, int y, int z) {
        LivingEntity owner = ((FollowOwnerGoalAccessor) this).getOwner();
        if (owner == null) return false;

        if (Math.abs((double)x - owner.getX()) < 2.0 && Math.abs((double)z - owner.getZ()) < 2.0) {
            return false;
        }
        if (!this.canTeleportTo(new BlockPos(x, y, z))) {
            return false;
        }

        this.hamster.refreshPositionAndAngles((double)x + 0.5, y, (double)z + 0.5, this.hamster.getYaw(), this.hamster.getPitch());
        this.hamster.getNavigation().stop();
        return true;
    }

    private boolean canTeleportTo(BlockPos pos) {
        WorldView world = this.hamster.getWorld();
        PathNodeType pathNodeType = LandPathNodeMaker.getLandNodeType(world, pos.mutableCopy());
        if (pathNodeType != PathNodeType.WALKABLE) {
            return false;
        }
        BlockState blockState = world.getBlockState(pos.down());
        if (blockState.getBlock() instanceof LeavesBlock) { // The 'leavesAllowed' check
            return false;
        }
        BlockPos blockPos = pos.subtract(this.hamster.getBlockPos());
        return world.isSpaceEmpty(this.hamster, this.hamster.getBoundingBox().offset(blockPos));
    }

    private int getRandomInt(int min, int max) {
        return this.hamster.getRandom().nextInt(max - min + 1) + min;
    }
}
```

`HamsterGoToBedAndSleepGoal.java`
```java
package net.dawson.adorablehamsterpets.entity.AI;

// (Imports omitted to save token count)

public class HamsterGoToBedAndSleepGoal extends Goal {
    private final HamsterEntity hamster;
    private final World world;
    private int pounceTicks;
    @Nullable
    private Vec3d pounceStartPos;
    private int startDelay = 0;
    private boolean wasLured = false;
    private int awakeTimer = 0;

    private static final int MIN_START_DELAY_TICKS = 5;
    private static final int MAX_START_DELAY_TICKS = 100;

    private enum State {
        MOVING_TO_BED,
        POUNCING_INTO_BED
    }

    private State currentState = State.MOVING_TO_BED;

    public HamsterGoToBedAndSleepGoal(HamsterEntity hamster) {
        this.hamster = hamster;
        this.world = hamster.getWorld();
        this.setControls(EnumSet.of(Control.MOVE, Control.LOOK, Control.JUMP));
    }

    @Override
    public boolean canStart() {
        // --- 1. Pre-checks for any sleep attempt ---
        if (!this.hamster.isWanderModeActive() || this.hamster.isSitting() || !Configs.AHP.allowSleepInBed.get()) {
            return false;
        }

        Optional<GlobalPos> bedPosOptional = this.hamster.getLinkedBedPos();
        if (bedPosOptional.isEmpty() || this.world.getRegistryKey() != bedPosOptional.get().getDimension()) {
            return false;
        }

        BlockPos bedPos = bedPosOptional.get().getPos();
        BlockState bedState = this.world.getBlockState(bedPos);
        BlockEntity be = this.world.getBlockEntity(bedPos);
        if (!(bedState.getBlock() instanceof HamsterBedBlock) || bedState.get(HamsterBedBlock.OCCUPIED) || !(be instanceof HamsterBedBlockEntity bedEntity)) {
            return false;
        }

        // Check if sleeping is allowed on this specific bed
        if (!bedEntity.isSleepingAllowed()) {
            return false;
        }

        // --- 2. Lure Path (Ignores time of day and cooldowns) ---
        if (this.hamster.getLureToBedTimer() > 0) {
            return true; // Lure is active, all basic checks passed.
        }

        // --- 3. Automatic Path (Checks time of day or random timer) ---
        if (bedEntity.isNewlyPlaced()) {
            return true; // Bypass cooldown and time checks if bed was just placed
        }

        if (this.hamster.getGoToBedCooldown() > 0) {
            return false;
        }

        // --- 4a. Circadian Chaos Logic ---
        if (Configs.AHP.circadianChaos.get()) {
            if (this.awakeTimer > 0) {
                this.awakeTimer--;
                return false;
            }
            return true; // Cooldown is over, time for a random nap
        } else {
            // --- 4b. Time-of-Day Logic ---
            boolean isSleepTime = Configs.AHP.sleepDuringDay.get() ? this.world.isDay() : this.world.isNight();
            return isSleepTime;
        }
    }

    @Override
    public void start() {
        this.hamster.setActiveCustomGoalDebugName(this.getClass().getSimpleName());
        this.hamster.setOnTheWayToBed(true); // Set the flag for the debug overlay

        // Reset random sleep cooldown if Circadian Chaos is enabled
        if (Configs.AHP.circadianChaos.get()) {
            int min = Configs.AHP.minNapInBedIntervalSeconds .get() * 20;
            int max = Configs.AHP.maxNapInBedIntervalSeconds.get() * 20;
            this.awakeTimer = this.hamster.getRandom().nextBetween(min, max);
        }

        boolean isLured = this.hamster.getLureToBedTimer() > 0;
        this.wasLured = isLured;
        boolean isNewBed = false;
        boolean shouldBypass = this.hamster.shouldBypassNextSleepDelay();

        Optional<GlobalPos> bedPosOpt = this.hamster.getLinkedBedPos();
        if (bedPosOpt.isPresent()) {
            BlockPos bedPos = bedPosOpt.get().getPos();
            if (this.world.getRegistryKey() == bedPosOpt.get().getDimension()) {
                BlockEntity be = this.world.getBlockEntity(bedPos);
                if (be instanceof HamsterBedBlockEntity bedEntity) {
                    isNewBed = bedEntity.isNewlyPlaced();
                }
            }
        }

        // If lured to bed, bed lock was just placed, manually woken up, or Circadian Chaos is enabled, bypass the "realism" delay.
        if (isLured || isNewBed || shouldBypass || Configs.AHP.circadianChaos.get()) {
            this.startDelay = 0;
            if (isLured) {
                this.hamster.setLureToBedTimer(0);
            }
            if (shouldBypass) {
                this.hamster.setBypassNextSleepDelay(false);
            }
        } else {
            this.startDelay = this.hamster.getRandom().nextBetween(MIN_START_DELAY_TICKS, MAX_START_DELAY_TICKS);
        }

        this.hamster.setGoToBedDelayTicks(this.startDelay); // Update for the debug overlay
        this.currentState = State.MOVING_TO_BED; // Start in idle, wait for delay
    }

    @Override
    public void stop() {
        this.hamster.getNavigation().stop();
        this.currentState = State.MOVING_TO_BED;
        this.pounceStartPos = null;
        this.wasLured = false;
        if (this.hamster.getActiveCustomGoalDebugName().equals(this.getClass().getSimpleName())) {
            this.hamster.setActiveCustomGoalDebugName("None");
        }
        this.hamster.setOnTheWayToBed(false); // Clear the flag on the debug overlay
        this.hamster.setGoToBedDelayTicks(this.startDelay); // Reset delay for the debug overlay
    }

    @Override
    public boolean shouldContinue() {
        // --- 1. Basic state checks ---
        if (this.hamster.isSitting() || !this.hamster.isWanderModeActive()) {
            return false;
        }

        // --- 2. Bed validity checks ---
        Optional<GlobalPos> bedPosOptional = this.hamster.getLinkedBedPos();
        if (bedPosOptional.isEmpty() || this.world.getRegistryKey() != bedPosOptional.get().getDimension()) {
            return false;
        }
        BlockPos bedPos = bedPosOptional.get().getPos();
        BlockState bedState = this.world.getBlockState(bedPos);
        if (!(bedState.getBlock() instanceof HamsterBedBlock) || bedState.get(HamsterBedBlock.OCCUPIED)) {
            return false;
        }

        // --- 3. If all checks pass, continue the goal ---
        return true;
    }

    @Override
    public void tick() {
        if (startDelay > 0) {
            startDelay--;
            this.hamster.setGoToBedDelayTicks(startDelay); // Continuously update for the debug overlay
            return; // Wait for delay to finish
        }

        Optional<GlobalPos> bedPosOptional = this.hamster.getLinkedBedPos();
        if (bedPosOptional.isEmpty()) {
            stop();
            return;
        }
        BlockPos bedPos = bedPosOptional.get().getPos();

        // This block now runs only after the delay is over.
        // If we are in the moving state but the navigator is idle, it means we need to start it.
        if (this.currentState == State.MOVING_TO_BED && this.hamster.getNavigation().isIdle()) {
            this.hamster.getNavigation().startMovingTo(bedPos.getX() + 0.5, bedPos.getY(), bedPos.getZ() + 0.5, 0.75D);
        }

        switch (this.currentState) {
            case MOVING_TO_BED:
                this.hamster.getLookControl().lookAt(Vec3d.ofCenter(bedPos));

                // Particle Breadcrumb Logic for Lure
                if (this.wasLured && !this.world.isClient() && !this.hamster.getNavigation().isIdle()) {
                    ParticleBreadcrumbHelper.spawnBreadcrumbs((ServerWorld) this.world, this.hamster.getNavigation().getCurrentPath());
                }

                if (this.hamster.getNavigation().isIdle()) {
                    // If navigation becomes idle before reaching the target (e.g., stuck), stop the goal to allow re-evaluation.
                    stop();
                    return;
                }

                // When close enough, transition to pouncing.
                if (this.hamster.getBlockPos().isWithinDistance(bedPos, 1.2)) {
                    this.hamster.getNavigation().stop();
                    this.currentState = State.POUNCING_INTO_BED;
                    this.pounceTicks = 5; // 0.25 seconds for the pounce
                    this.pounceStartPos = this.hamster.getPos();

                    // --- Pounce Arc ---
                    // Apply an initial upward velocity to create a "hop" into the bed.
                    this.hamster.setVelocity(this.hamster.getVelocity().x, 0.4, this.hamster.getVelocity().z);
                    this.hamster.velocityDirty = true; // Client sync

                    // --- Set Suffocation Grace Period ---
                    this.hamster.suffocationGracePeriod = 40;

                    // --- Play Sound ---
                    this.world.playSound(null, this.hamster.getBlockPos(), ModSounds.HAMSTER_SWISH.get(), SoundCategory.NEUTRAL, 0.35f, 1.0f + this.hamster.getRandom().nextFloat() * 0.5f);

                    // --- Randomized Animation Logic ---
                    int choice = this.hamster.getRandom().nextInt(3);
                    String settleAnimId;
                    String deepSleepAnimIdForTracker;
                    switch (choice) {
                        case 0 -> {
                            settleAnimId = "anim_hamster_stand_settle_sleep1";
                            deepSleepAnimIdForTracker = "anim_hamster_sleep_pose1";
                        }
                        case 1 -> {
                            settleAnimId = "anim_hamster_stand_settle_sleep2";
                            deepSleepAnimIdForTracker = "anim_hamster_sleep_pose2";
                        }
                        default -> {
                            settleAnimId = "anim_hamster_stand_settle_sleep3";
                            deepSleepAnimIdForTracker = "anim_hamster_sleep_pose3";
                        }
                    }
                    this.hamster.getDataTracker().set(HamsterEntity.CURRENT_DEEP_SLEEP_ANIM_ID, deepSleepAnimIdForTracker);
                    this.hamster.triggerAnimOnServer("mainController", settleAnimId);
                }
                break;

            case POUNCING_INTO_BED:
                this.pounceTicks--;
                this.hamster.getLookControl().lookAt(Vec3d.ofCenter(bedPos));

                if (this.pounceStartPos != null && this.pounceTicks >= 0) {
                    // Calculate progress (from 0.0 to 1.0 over the pounce duration)
                    double progress = 1.0 - ((double) this.pounceTicks / 5.0);
                    // Apply a quadratic ease-in curve for acceleration
                    double easedProgress = progress * progress;
                    Vec3d targetCenter = Vec3d.ofCenter(bedPos).add(0, 0.1, 0);

                    // Interpolate X and Z coordinates; let gravity handle Y.
                    double newX = pounceStartPos.x + easedProgress * (targetCenter.x - pounceStartPos.x);
                    double newZ = pounceStartPos.z + easedProgress * (targetCenter.z - pounceStartPos.z);
                    this.hamster.setPosition(newX, this.hamster.getY(), newZ);
                }

                if (this.pounceTicks < 0) {
                    // --- Finalize Landing ---
                    // Set the hamster's final position to be slightly elevated inside the bed, preventing it from clipping through the floor on landing.
                    Vec3d targetCenter = Vec3d.ofCenter(bedPos).add(0, 0.1, 0);
                    this.hamster.setPosition(targetCenter.x, targetCenter.y, targetCenter.z);
                    this.hamster.setVelocity(Vec3d.ZERO); // Stop all movement
                    this.hamster.velocityDirty = true;

                    // Finalize state after pounce
                    this.hamster.setDozingPhase(HamsterEntity.DozingPhase.DEEP_SLEEP);
                    this.hamster.setSleeping(true);
                    this.hamster.setInSittingPose(true); // Vanilla flag to prevent other AI movement
                    this.world.setBlockState(bedPos, this.world.getBlockState(bedPos).with(HamsterBedBlock.OCCUPIED, true), Block.NOTIFY_ALL);

                    // Start the nap timer on the hamster
                    this.hamster.startNapTimer();

                    // Trigger bed animation
                    BlockEntity be = this.world.getBlockEntity(bedPos);
                    if (be instanceof GeoBlockEntity geoBlockEntity) {
                        geoBlockEntity.triggerAnim("hamster_bed_controller", "anim_bed_becoming_occupied");
                    }

                    // Call the effects helper method
                    this.hamster.startBedSleepEffects();

                    // Mark the bed as used to ensure the cooldown comes into effect the next time
                    if (be instanceof HamsterBedBlockEntity bedEntity) {
                        bedEntity.markAsUsed();
                    }
                }
                break;
        }
    }
}
```

`HamsterLookAroundGoal.java`
```java
package net.dawson.adorablehamsterpets.entity.AI;

// (Imports omitted to save token count)

public class HamsterLookAroundGoal extends LookAroundGoal {

    // --- 1. Fields ---
    private final MobEntity hamsterMob; // Store our own reference
    // --- End 1. Fields ---

    // --- 2. Constructor ---
    public HamsterLookAroundGoal(MobEntity mob) {
        super(mob);
        this.hamsterMob = mob; // Initialize our reference
    }
    // --- End 2. Constructor ---

    // --- 3. Overridden Methods ---
    @Override
    public boolean canStart() {
        // Use the accessor to get the mob field
        LookAroundGoalAccessor accessor = (LookAroundGoalAccessor) this;
        MobEntity mob = accessor.getMob();

        // First, perform the vanilla probability check.
        if (mob.getRandom().nextFloat() >= 0.02F) { // Vanilla's hardcoded chance
            return false;
        }
        // Check Hamster State
        // Use our stored 'hamsterMob' reference
        if (this.hamsterMob instanceof HamsterEntity hamster) {
            return !hamster.isSitting() && !hamster.isSleeping() && !hamster.isKnockedOut() && !hamster.isSulking()
                    && !hamster.isStealingDiamond() && !hamster.isCelebratingChase()
                    && !hamster.getActiveCustomGoalDebugName().equals(HamsterWanderAroundFarGoal.class.getSimpleName());
        }
        return true;
    }

    @Override
    public void start() {
        super.start();
        if (this.hamsterMob instanceof HamsterEntity he) {
            he.setActiveCustomGoalDebugName(this.getClass().getSimpleName());
            AdorableHamsterPets.LOGGER.trace("[AI Goal Start] Hamster {} started LookAroundGoal.", he.getId());
        }
    }

    @Override
    public boolean shouldContinue() {
        // --- 1. Check Hamster State ---
        // Use our stored 'hamsterMob' reference
        if (this.hamsterMob instanceof HamsterEntity hamster) {
            if (hamster.isSitting() || hamster.isSleeping() || hamster.isKnockedOut() || hamster.isSulking() || hamster.isStealingDiamond() || hamster.isCelebratingChase()) {
                return false;
            }
        }
        // --- End 1. Check Hamster State ---
        return super.shouldContinue();
    }

    @Override
    public void stop() {
        super.stop();
        if (this.hamsterMob instanceof HamsterEntity he) {
            if (he.getActiveCustomGoalDebugName().equals(this.getClass().getSimpleName())) {
                he.setActiveCustomGoalDebugName("None");
            }
        }
    }

    @Override
    public void tick() {
        LookAroundGoalAccessor accessor = (LookAroundGoalAccessor) this;
        MobEntity mob = accessor.getMob(); // Get the mob via accessor

        // Replicate the vanilla logic of decrementing the timer
        accessor.setLookTime(accessor.getLookTime() - 1);

        // Use our centralized constants for rotation speed
        mob.getLookControl().lookAt(
                mob.getX() + accessor.getDeltaX(),
                mob.getEyeY(),
                mob.getZ() + accessor.getDeltaZ(),
                HamsterEntity.FAST_YAW_CHANGE,
                HamsterEntity.FAST_PITCH_CHANGE
        );
    }
    // --- End 3. Overridden Methods ---
}
```

`HamsterLookAtEntityGoal.java`
```java
package net.dawson.adorablehamsterpets.entity.AI;

// (Imports omitted to save token count)

public class HamsterLookAtEntityGoal extends LookAtEntityGoal {

    // --- 1. Fields ---
    private final MobEntity hamsterMob; // Store our own reference
    private final float chance; // Initialize with default vanilla chance
    // --- End 1. Fields ---

    // --- 2. Constructors ---
    public HamsterLookAtEntityGoal(MobEntity mob, Class<? extends LivingEntity> targetType, float range) {
        super(mob, targetType, range);
        this.hamsterMob = mob; // Initialize our reference
        this.chance = 0.02F; // Initialize the chance
    }

    public HamsterLookAtEntityGoal(MobEntity mob, Class<? extends LivingEntity> targetType, float range, float chance) {
        super(mob, targetType, range, chance);
        this.hamsterMob = mob;
        this.chance = chance; // Store the chance
    }

    public HamsterLookAtEntityGoal(MobEntity mob, Class<? extends LivingEntity> targetType, float range, float chance, boolean lookForward) {
        super(mob, targetType, range, chance, lookForward);
        this.hamsterMob = mob; // Initialize our reference
        this.chance = chance; // Initialize the chance
    }
    // --- End 2. Constructors ---

    // --- 3. Overridden Methods ---
    @Override
    public boolean canStart() {
        // --- 1. Hamster State Check (Perform this FIRST for efficiency) ---
        if (this.hamsterMob instanceof HamsterEntity hamster) {
            if (hamster.isSitting() || hamster.isSleeping() || hamster.isKnockedOut() || hamster.isSulking() || hamster.isStealingDiamond()
                    || hamster.getActiveCustomGoalDebugName().equals(HamsterWanderAroundFarGoal.class.getSimpleName())) {
                return false;
            }
        }

        // --- 2. Defer to Superclass Logic ---
        boolean superCanStart = super.canStart();
        if (!superCanStart) {
            AdorableHamsterPets.LOGGER.trace("[LookAtGoal-{}] canStart FAILED: super.canStart() returned false (chance or no target).", this.hamsterMob.getId());
            return false;
        }

        // --- 3. Success ---
        AdorableHamsterPets.LOGGER.trace("[LookAtGoal-{}] canStart SUCCEEDED. All checks passed.", this.hamsterMob.getId());
        return true;
    }

    @Override
    public void start() {
        super.start();
        if (this.mob instanceof HamsterEntity he) {
            he.setActiveCustomGoalDebugName(this.getClass().getSimpleName());
            he.getDataTracker().set(HamsterEntity.CURRENT_LOOK_UP_ANIM_ID, he.getRandom().nextBetween(1, 3));
            AdorableHamsterPets.LOGGER.trace("[AI Goal Start] Hamster {} started LookAtEntityGoal.", he.getId());
        }
    }

    @Override
    public boolean shouldContinue() {
        // --- 1. Check Hamster State ---
        // Use our stored 'hamsterMob' reference
        if (this.hamsterMob instanceof HamsterEntity hamster) {
            if (hamster.isSitting() || hamster.isSleeping() || hamster.isKnockedOut() || hamster.isSulking() || hamster.isStealingDiamond()) {
                return false;
            }
        }
        // --- End 1. Check Hamster State ---
        return super.shouldContinue();
    }

    @Override
    public void stop() {
        super.stop();
        if (this.mob instanceof HamsterEntity he) {
            if (he.getActiveCustomGoalDebugName().equals(this.getClass().getSimpleName())) {
                he.setActiveCustomGoalDebugName("None");
            }
        }
    }

    @Override
    public void tick() {
        LookAtEntityGoalAccessor accessor = (LookAtEntityGoalAccessor) this;
        Entity target = accessor.getTarget();

        if (target != null && target.isAlive()) {
            double targetY = accessor.getLookForward() ? this.mob.getEyeY() : target.getEyeY();
            // Use our centralized constants for rotation speed
            this.mob.getLookControl().lookAt(target.getX(), targetY, target.getZ(), HamsterEntity.FAST_YAW_CHANGE, HamsterEntity.FAST_PITCH_CHANGE);
            accessor.setLookTime(accessor.getLookTime() - 1);
        }
    }
    // --- End 3. Overridden Methods ---
}
```

`HamsterMateGoal.java`
```java
package net.dawson.adorablehamsterpets.entity.AI;

// (Imports omitted to save token count)

public class HamsterMateGoal extends Goal {
    private final HamsterEntity hamster;
    private HamsterEntity targetMate;
    private final double speed;
    private int timer;

    public HamsterMateGoal(HamsterEntity hamster, double speed) {
        this.hamster = hamster;
        this.speed = speed;
        this.setControls(EnumSet.of(Control.MOVE, Control.LOOK));
    }

    @Override
    public boolean canStart() {
        // Check the master sitting state
        if (this.hamster.isSitting()) {
            return false;
        }
        boolean inLove = this.hamster.isInCustomLove();
        if (inLove) {
            this.targetMate = this.getNearbyMate();
            return this.targetMate != null;
        }
        return false;
    }

    @Override
    public boolean shouldContinue() {
        return this.targetMate != null
                && this.targetMate.isAlive()
                && this.hamster.isInCustomLove()
                && this.timer < 60;
        // let's say 3 seconds for them to breed
    }

    @Override
    public void start() {
        this.timer = 0;
        this.hamster.setActiveCustomGoalDebugName(this.getClass().getSimpleName());
    }

    @Override
    public void stop() {
        if (this.hamster.getActiveCustomGoalDebugName().equals(this.getClass().getSimpleName())) {
            this.hamster.setActiveCustomGoalDebugName("None");
        }
        this.targetMate = null;
    }

    @Override
    public void tick() {
        this.hamster.getNavigation().startMovingTo(this.targetMate, this.speed);
        this.hamster.getLookControl().lookAt(this.targetMate, HamsterEntity.FAST_YAW_CHANGE, HamsterEntity.FAST_PITCH_CHANGE);
        this.timer++;

        if (this.timer >= 60) {
            this.breed();
        }
    }

    private HamsterEntity getNearbyMate() {
        AdorableHamsterPets.LOGGER.trace("[MateGoal {} Tick {}] getNearbyMate() searching...", this.hamster.getId(), this.hamster.getWorld().getTime());
        List<HamsterEntity> candidates = this.hamster.getWorld().getEntitiesByClass(
                HamsterEntity.class,
                this.hamster.getBoundingBox().expand(8.0D),
                // --- Start of Predicate Lambda ---
                h -> { // Check each potential mate 'h'
                    boolean potential = h != this.hamster && h.isInCustomLove() && h.getBreedingAge() == 0;
                    // Log check for each candidate inside the lambda
                    AdorableHamsterPets.LOGGER.trace("  - Checking candidate {}: isInCustomLove={}, getBreedingAge={}, isSelf={}, Result={}", h.getId(), h.isInCustomLove(), h.getBreedingAge(), h == this.hamster, potential);
                    return potential; // Return the result of the check for this candidate
                }
        );

        // Find any candidate from the filtered list
        HamsterEntity found = candidates.stream().findAny().orElse(null);

        // Log the final result after checking all candidates
        AdorableHamsterPets.LOGGER.trace("[MateGoal {} Tick {}] getNearbyMate() found: {}", this.hamster.getId(), this.hamster.getWorld().getTime(), found != null ? found.getId() : "null");

        return found;
    }

    private void breed() {

        // --- Use Config Value for Breeding Cooldown ---
        final AhpConfig config = AdorableHamsterPets.CONFIG;
        int cooldown = config.breedingCooldownTicks.get();
        this.hamster.setBreedingAge(cooldown);
        this.targetMate.setBreedingAge(cooldown);
        // --- End Use Config Value ---

        this.hamster.customLoveTimer = 0;
        this.targetMate.customLoveTimer = 0;

        // Create baby
        HamsterEntity baby = (HamsterEntity)this.hamster.createChild((ServerWorld)this.hamster.getWorld(), this.targetMate);
        if (baby != null) {
            // Position baby
            baby.refreshPositionAndAngles(this.hamster.getX(), this.hamster.getY(), this.hamster.getZ(), 0.0F, 0.0F);
            this.hamster.getWorld().spawnEntity(baby);
        }
    }
}
```

`HamsterMeleeAttackGoal.java`
```java
package net.dawson.adorablehamsterpets.entity.AI;

// (Imports omitted to save token count)

public class HamsterMeleeAttackGoal extends MeleeAttackGoal {
    private final HamsterEntity hamster;
    private static final int CUSTOM_ATTACK_COOLDOWN_TICKS = 35;


    public HamsterMeleeAttackGoal(HamsterEntity hamster, double speed, boolean pauseWhenMobIdle) {
        super(hamster, speed, pauseWhenMobIdle);
        this.hamster = hamster;
    }


    @Override
    protected void attack(LivingEntity target, double squaredDistance) {
        // --- Gatekeeper Logic ---
        // Check 1: Is the cooldown ready?
        // Check 2: Is the target in the custom attack range?
        if (this.getCooldown() <= 0 && this.hamster.isInAttackRange(target)) {

            // --- Attack Action ---
            this.resetCooldown();
            this.mob.tryAttack(target);

            // --- Sound and Animation ---
            SoundEvent attackSound = ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_ATTACK_SOUNDS, this.hamster.getRandom());
            if (attackSound != null) {
                this.hamster.playSound(attackSound, 1.2F, this.hamster.getSoundPitch());
                AdorableHamsterPets.LOGGER.trace("[AttackGoal {} Tick {}] Played attack sound: {}", this.hamster.getId(), this.hamster.getWorld().getTime(), attackSound.getId());
            }
            this.hamster.triggerAnimOnServer("mainController", "attack");

            // --- DAMAGE LOGIC ---
            // 1. Create a DamageSource where the hamster is the attacker.
            DamageSource damageSource = this.hamster.getDamageSources().mobAttack(this.hamster);
            // 2. Get the damage amount from the hamster's attributes.
            float damageAmount = (float)this.hamster.getAttributeValue(EntityAttributes.GENERIC_ATTACK_DAMAGE);
            // 3. Deal the damage to the target using the correct source.
            target.damage(damageSource, damageAmount);

            AdorableHamsterPets.LOGGER.trace("[AttackGoal {} Tick {}] Called tryAttack() on target {}.", this.hamster.getId(), this.hamster.getWorld().getTime(), target.getId());

        }
    }


    @Override
    protected int getMaxCooldown() {
        return CUSTOM_ATTACK_COOLDOWN_TICKS;
    }


    @Override
    protected void resetCooldown() {
        // Cast 'this' to the accessor interface and call the public setter method.
        ((MeleeAttackGoalAccessor) this).setCooldown(this.getMaxCooldown());
    }


    @Override
    public boolean canStart() {
        // Check the master sitting state
        if (this.hamster.isSitting()) {
            return false;
        }
        return super.canStart();
    }


    @Override
    public void start() {
        super.start();
        AdorableHamsterPets.LOGGER.trace("[AttackGoal {} Tick {}] Goal started.", this.hamster.getId(), this.hamster.getWorld().getTime());
        // Use the accessor to set the cooldown to 0, making the hamster able to attack immediately.
        ((MeleeAttackGoalAccessor) this).setCooldown(0);
        this.hamster.setActiveCustomGoalDebugName(this.getClass().getSimpleName());
    }


    @Override
    public void stop() {
        super.stop();
        AdorableHamsterPets.LOGGER.trace("[AttackGoal {} Tick {}] Goal stopped.", this.hamster.getId(), this.hamster.getWorld().getTime());
        if (this.hamster.getActiveCustomGoalDebugName().equals(this.getClass().getSimpleName())) {
            this.hamster.setActiveCustomGoalDebugName("None");
        }
    }

    @Override
    public void tick() {
        super.tick(); // Handles pathing updates and cooldown decrementing
        // We need to call attack() every tick because the superclass doesn't call it automatically
        // if we override tick() without calling super.tick() *first*.
        // However, the actual attack logic is now correctly gated by canAttack().
        LivingEntity target = this.mob.getTarget();
        if (target != null) {
            this.attack(target, this.mob.squaredDistanceTo(target));
        }
    }
}
```

`HamsterSeekDiamondGoal.java`
```java
package net.dawson.adorablehamsterpets.entity.AI;

// (Imports omitted to save token count)

public class HamsterSeekDiamondGoal extends Goal {

    private final HamsterEntity hamster;
    private final World world;
    private BlockPos targetOrePos; // The specific ore block being targeted
    private boolean isSeekingGold; // True if the current target is gold ore

    private enum SeekingState {
        IDLE,
        SCANNING,
        MOVING_TO_ORE,
        WAITING_FOR_PATH,
        CELEBRATING_DIAMOND,
        SULKING_AT_GOLD
    }

    private SeekingState currentState = SeekingState.IDLE;
    private int pathingTickTimer;
    private int soundTimer;
    @Nullable private Path path;

    private static final int PATHING_RECHECK_INTERVAL = 20; // Ticks (1 second)
    private static final int SNIFF_SOUND_INTERVAL_MOVING = 30; // Less than 2 seconds
    private static final int SNIFF_SOUND_INTERVAL_WAITING = 160; // Approx 8 seconds

    public HamsterSeekDiamondGoal(HamsterEntity hamster) {
        this.hamster = hamster;
        this.world = hamster.getWorld();
        this.setControls(EnumSet.of(Goal.Control.MOVE, Goal.Control.LOOK));
    }

    @Override
    public boolean canStart() {
        if (world.isClient || !Configs.AHP.enableIndependentDiamondSeeking) {
            return false;
        }
        // Check the isPrimedToSeekDiamonds flag directly
        if (!this.hamster.isPrimedToSeekDiamonds) {
            return false;
        }
        if (this.hamster.isSitting() || this.hamster.isSleeping() || this.hamster.isKnockedOut() || this.hamster.isCelebratingChase()|| this.hamster.isSulking()) {
            return false;
        }
        if (this.hamster.getTarget() != null) { // In combat
            return false;
        }
        if (Configs.AHP.enableIndependentDiamondSeekCooldown &&
                this.hamster.foundOreCooldownEndTick > this.world.getTime()) {
            return false;
        }
        // Attempt to find a target only if all above conditions pass
        return findNewTargetOreAndSetState();
    }

    private boolean findNewTargetOreAndSetState() {
        this.targetOrePos = null; // Reset before scan
        this.isSeekingGold = false;
        this.hamster.currentOreTarget = null; // Clear entity's direct target tracker initially

        List<BlockPos> exposedDiamondOres = new ArrayList<>();
        List<BlockPos> buriedDiamondOres = new ArrayList<>();
        List<BlockPos> buriedGoldOres = new ArrayList<>(); // Only track buried gold for the "mistake"
        int radius = Configs.AHP.diamondSeekRadius.get();

        for (BlockPos pos : BlockPos.iterateOutwards(hamster.getBlockPos(), radius, radius, radius)) {
            BlockState state = world.getBlockState(pos);
            Block block = state.getBlock();

            if (block == Blocks.DIAMOND_ORE || block == Blocks.DEEPSLATE_DIAMOND_ORE) {
                if (isOreExposed(pos, this.world)) {
                    exposedDiamondOres.add(pos.toImmutable());
                } else {
                    buriedDiamondOres.add(pos.toImmutable());
                }
            } else if (block == Blocks.GOLD_ORE || block == Blocks.DEEPSLATE_GOLD_ORE) {
                if (isOreExposed(pos, this.world)) { // Only consider gold if it's hidden
                    buriedGoldOres.add(pos.toImmutable());
                }
            }
        }

        // --- Prioritized Target Selection ---
        boolean targetIsGold = !buriedGoldOres.isEmpty() && this.world.random.nextFloat() < Configs.AHP.goldMistakeChance.get();

        if (targetIsGold) {
            buriedGoldOres.sort(Comparator.comparingDouble(pos -> pos.getSquaredDistance(hamster.getPos())));
            this.targetOrePos = buriedGoldOres.get(0);
            this.isSeekingGold = true;
        } else {
            if (!exposedDiamondOres.isEmpty()) {
                exposedDiamondOres.sort(Comparator.comparingDouble(pos -> pos.getSquaredDistance(hamster.getPos())));
                this.targetOrePos = exposedDiamondOres.get(0);
            } else if (!buriedDiamondOres.isEmpty()) {
                buriedDiamondOres.sort(Comparator.comparingDouble(pos -> pos.getSquaredDistance(hamster.getPos())));
                this.targetOrePos = buriedDiamondOres.get(0);
            }
        }

        if (this.targetOrePos != null) {
            this.hamster.currentOreTarget = this.targetOrePos;
            this.currentState = SeekingState.SCANNING;
            return true; // A target was selected
        }

        return false; // No valid target found
    }

    @Override
    public void start() {
        this.hamster.setActiveCustomGoalDebugName(this.getClass().getSimpleName() + (isSeekingGold ? "_Gold" : "_Diamond"));
        this.pathingTickTimer = 0;
        this.soundTimer = 0;
        // currentState is already SCANNING from canStart/findNewTargetOreAndSetState
        attemptPathToTarget();
    }

    private void attemptPathToTarget() {
        if (this.targetOrePos == null) {
            this.currentState = SeekingState.IDLE;
            return;
        }
        // --- Store the Path ---
        this.path = this.hamster.getNavigation().findPathTo(
                this.targetOrePos.getX() + 0.5,
                this.targetOrePos.getY(),
                this.targetOrePos.getZ() + 0.5,
                0
        );

        if (this.path != null) {
            this.hamster.getNavigation().startMovingAlong(this.path, 0.5D);
            this.currentState = SeekingState.MOVING_TO_ORE;
            this.soundTimer = SNIFF_SOUND_INTERVAL_MOVING / 2;
        } else {
            this.currentState = SeekingState.WAITING_FOR_PATH;
            this.pathingTickTimer = PATHING_RECHECK_INTERVAL;
            this.soundTimer = SNIFF_SOUND_INTERVAL_WAITING / 2;
        }
    }

    @Override
    public boolean shouldContinue() {
        // Terminal states for this goal instance
        if (this.currentState == SeekingState.IDLE || this.currentState == SeekingState.CELEBRATING_DIAMOND || this.currentState == SeekingState.SULKING_AT_GOLD) {
            return false;
        }
        // Interruptions
        if (this.hamster.isSitting() || this.hamster.isSleeping() || this.hamster.isKnockedOut() || this.hamster.isSulking()) {
            return false;
        }
        if (this.hamster.getTarget() != null) { // Combat
            return false;
        }
        // Target validity
        if (this.targetOrePos == null) return false; // Should be caught by IDLE state, but good check

        Block targetBlock = world.getBlockState(this.targetOrePos).getBlock();
        boolean isTargetDiamond = targetBlock == Blocks.DIAMOND_ORE || targetBlock == Blocks.DEEPSLATE_DIAMOND_ORE;
        boolean isTargetGold = targetBlock == Blocks.GOLD_ORE || targetBlock == Blocks.DEEPSLATE_GOLD_ORE;

        if (this.isSeekingGold) {
            return isTargetGold; // Target gold ore was broken or changed
        } else {
            return isTargetDiamond; // Target diamond ore was broken or changed
        }
    }

    @Override
    public void tick() {
        if (this.targetOrePos == null) {
            stop();
            return;
        }

        this.hamster.getLookControl().lookAt(this.targetOrePos.getX() + 0.5, this.targetOrePos.getY() + 0.5, this.targetOrePos.getZ() + 0.5, HamsterEntity.FAST_YAW_CHANGE, HamsterEntity.FAST_PITCH_CHANGE);

        if (this.soundTimer > 0) {
            this.soundTimer--;
        }

        switch (this.currentState) {
            case MOVING_TO_ORE:

                // Particle Breadcrumb Logic
                if (!this.world.isClient()) {
                    ParticleBreadcrumbHelper.spawnBreadcrumbs((ServerWorld) this.world, this.path);
                }

                if (this.hamster.getNavigation().isIdle() || this.hamster.getBlockPos().isWithinDistance(this.targetOrePos, 1.5)) {
                    if (this.hamster.getBlockPos().isWithinDistance(this.targetOrePos, 1.5)) {
                        onOreReached();
                    } else {
                        this.path = null; // Clear old path
                        this.currentState = SeekingState.WAITING_FOR_PATH;
                        this.pathingTickTimer = PATHING_RECHECK_INTERVAL;
                        this.soundTimer = SNIFF_SOUND_INTERVAL_WAITING / 2;
                    }
                } else {
                    if (this.soundTimer <= 0) {
                        playSniffSound();
                        this.soundTimer = SNIFF_SOUND_INTERVAL_MOVING;
                    }
                }
                break;
            case WAITING_FOR_PATH:
                if (this.pathingTickTimer > 0) {
                    this.pathingTickTimer--;
                } else {
                    attemptPathToTarget();
                }
                if (this.soundTimer <= 0) {
                    playSniffSound();
                    this.soundTimer = SNIFF_SOUND_INTERVAL_WAITING;
                }
                break;
        }
    }

    private void onOreReached() {
        this.hamster.getNavigation().stop();
        this.hamster.isPrimedToSeekDiamonds = false;

        if (Configs.AHP.enableIndependentDiamondSeekCooldown) {
            this.hamster.foundOreCooldownEndTick = this.world.getTime() + Configs.AHP.independentOreSeekCooldownTicks.get();
        }

        if (this.isSeekingGold) {
            this.currentState = SeekingState.SULKING_AT_GOLD;
            if (this.hamster.getOwner() instanceof ServerPlayerEntity owner) {
                if (this.hamster.squaredDistanceTo(owner) < 36.0) {
                    this.hamster.getLookControl().lookAt(owner, HamsterEntity.FAST_YAW_CHANGE, HamsterEntity.FAST_PITCH_CHANGE);
                }
                // Send message to the owner
                sendMessageToOwner(owner);
            }

            // --- Startled Jump & Sound Logic ---
            // Calculate a vector pointing away from the target ore
            Vec3d awayFromOre = this.hamster.getPos().subtract(Vec3d.ofCenter(this.targetOrePos)).normalize();
            // Apply a small backward and upward velocity
            this.hamster.setVelocity(awayFromOre.x * 0.1, 0.5, awayFromOre.z * 0.1);
            this.hamster.velocityDirty = true; // Mark velocity for client sync
            // Play a random bounce sound at the hamster's location
            SoundEvent bounceSound = ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_BOUNCE_SOUNDS, this.hamster.getRandom());
            if (bounceSound != null) {
                this.world.playSound(null, this.hamster.getBlockPos(), bounceSound, SoundCategory.NEUTRAL, 0.6f, this.hamster.getSoundPitch());
            }
            // --- End Startled Jump & Sound Logic ---

            this.hamster.setSulking(true);
            this.hamster.triggerAnimOnServer("mainController", "anim_hamster_sulk");

        } else {
            this.currentState = SeekingState.CELEBRATING_DIAMOND;
            this.hamster.setCelebratingDiamond(true); // Triggers begging animation
            AdorableHamsterPets.LOGGER.trace("Hamster {} reached CELEBRATING_DIAMOND state for ore at {}", this.hamster.getId(), this.targetOrePos);

            if (this.hamster.getOwner() instanceof ServerPlayerEntity serverPlayerOwner) {
                ModCriteria.HAMSTER_LED_TO_DIAMOND.trigger(serverPlayerOwner, this.hamster, this.targetOrePos);
            }
        }
    }

    private void playSniffSound() {
        SoundEvent sniffSound = ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_DIAMOND_SNIFF_SOUNDS, this.hamster.getRandom());
        if (sniffSound != null) {
            this.world.playSound(null, this.hamster.getBlockPos(), sniffSound, SoundCategory.NEUTRAL, 3.0F, this.hamster.getSoundPitch());
        }
    }

    @Override
    public void stop() {
        this.path = null; // Clear the path when the goal stops
        this.hamster.getNavigation().stop();
        boolean targetOreStillExists = false;
        if (this.targetOrePos != null) {
            Block targetBlock = world.getBlockState(this.targetOrePos).getBlock();
            boolean isTargetDiamond = targetBlock == Blocks.DIAMOND_ORE || targetBlock == Blocks.DEEPSLATE_DIAMOND_ORE;
            boolean isTargetGold = targetBlock == Blocks.GOLD_ORE || targetBlock == Blocks.DEEPSLATE_GOLD_ORE;
            if (this.isSeekingGold && isTargetGold) targetOreStillExists = true;
            if (!this.isSeekingGold && isTargetDiamond) targetOreStillExists = true;
        }

        if (this.currentState != SeekingState.CELEBRATING_DIAMOND && this.currentState != SeekingState.SULKING_AT_GOLD && !targetOreStillExists) {
            this.hamster.isPrimedToSeekDiamonds = false;
        }

        if (this.hamster.isCelebratingDiamond() && (this.currentState != SeekingState.CELEBRATING_DIAMOND || !targetOreStillExists)) {
            this.hamster.setCelebratingDiamond(false);
        }

        if (this.hamster.getActiveCustomGoalDebugName().startsWith(this.getClass().getSimpleName())) {
            this.hamster.setActiveCustomGoalDebugName("None");
        }
        this.currentState = SeekingState.IDLE;
        this.targetOrePos = null;
    }

    /**
     * Selects and sends a humorous message to the hamster's owner about finding gold.
     * <p>
     * This method implements specific logic to enhance the player experience:
     * <ul>
     *     <li><b>First-Time Experience:</b> It checks if the player has the
     *     {@code adorablehamsterpets:technical/hamster_found_gold_first_time} advancement.
     *     If not, it sends a specific, predetermined message (index 0) and grants the
     *     advancement to ensure this "first-time" message is only seen once per player.</li>
     *     <li><b>Subsequent Experiences:</b> For all subsequent times, it retrieves the index of the
     *     last message shown from the player's persistent NBT data (via the {@link PlayerEntityAccessor}).
     *     It then randomly selects a new message from the available pool, guaranteeing it will not be the
     *     same as the one shown immediately prior.</li>
     *     <li><b>State Persistence:</b> The index of the newly displayed message is saved back to the
     *     player's NBT data, ensuring the "don't repeat" logic works across game sessions.</li>
     * </ul>
     * The method also triggers the {@link ModCriteria#HAMSTER_FOUND_GOLD} criterion on every execution.
     *
     * @param owner The player who owns the hamster and will receive the message.
     */
    private void sendMessageToOwner(ServerPlayerEntity owner) {
        PlayerAdvancementTracker tracker = owner.getAdvancementTracker();
        Identifier advId = Identifier.of(AdorableHamsterPets.MOD_ID, "technical/hamster_found_gold_first_time");
        Advancement advancement = owner.server.getAdvancementLoader().get(advId);

        if (advancement == null) {
            AdorableHamsterPets.LOGGER.error("[GoldMessage] CRITICAL: Could not find advancement '{}'. Message will not be sent. Check file path and JSON validity.", advId);
            return;
        }

        AdvancementProgress progress = tracker.getProgress(advancement);
        int messageIndex;

        if (!progress.isDone()) {
            // First time ever for this player
            messageIndex = 0;
            // Grant the criterion using the Advancement object so this block doesn't run again
            for (String criterion : advancement.getCriteria().keySet()) {
                tracker.grantCriterion(advancement, criterion);
            }
        } else {
            // Subsequent times
            PlayerEntityAccessor accessor = (PlayerEntityAccessor) owner;
            int lastIndex = accessor.ahp_getLastGoldMessageIndex();

            List<Integer> possibleIndices = IntStream.range(0, 7).boxed().collect(Collectors.toList());
            if (lastIndex >= 0 && lastIndex < 7) {
                possibleIndices.remove(Integer.valueOf(lastIndex));
            }

            messageIndex = possibleIndices.get(this.world.random.nextInt(possibleIndices.size()));
        }

        // Save the new index and send the message
        ((PlayerEntityAccessor) owner).ahp_setLastGoldMessageIndex(messageIndex);
        String messageKey = "message.adorablehamsterpets.found_gold_mistake." + (messageIndex + 1);
        owner.sendMessage(Text.translatable(messageKey).formatted(Formatting.GOLD), true);

        // Trigger the criterion for any other potential uses
        ModCriteria.HAMSTER_FOUND_GOLD.trigger(owner);
    }

    /**
     * Checks if an ore block is "exposed" by having at least one adjacent air-like block.
     *
     * @param orePos The position of the ore block.
     * @return True if the ore is exposed, false otherwise.
     */
    public static boolean isOreExposed(BlockPos orePos, World world) {
        for (Direction direction : Direction.values()) {
            BlockPos adjacentPos = orePos.offset(direction);
            // A block is considered "exposed" if the adjacent block has no collision shape (e.g., air, water, grass).
            if (world.getBlockState(adjacentPos).getCollisionShape(world, adjacentPos, ShapeContext.absent()).isEmpty()) {
                return true;
            }
        }
        return false;
    }
}
```

`HamsterSitGoal.java`
```java
package net.dawson.adorablehamsterpets.entity.AI;

// (Imports omitted to save token count)

public class HamsterSitGoal extends SitGoal {
    private final HamsterEntity hamster;

    public HamsterSitGoal(HamsterEntity hamster) {
        super(hamster);
        this.hamster = hamster;
    }

    @Override
    public boolean canStart() {
        // Prevent this goal from starting if the hamster is knocked out.
        if (this.hamster.isKnockedOut()) {
            return false;
        }
        return super.canStart();
    }

    @Override
    public void start() {
        super.start();
        this.hamster.setActiveCustomGoalDebugName(this.getClass().getSimpleName());
    }

    @Override
    public void stop() {
        super.stop();
        if (this.hamster.getActiveCustomGoalDebugName().equals(this.getClass().getSimpleName())) {
            this.hamster.setActiveCustomGoalDebugName("None");
        }
    }
}
```

`HamsterSleepGoal.java`
```java
package net.dawson.adorablehamsterpets.entity.AI;

// (Imports omitted to save token count)

public class HamsterSleepGoal extends Goal {

    // --- 1. Constants and Static Utilities ---
    private static final int CHECK_INTERVAL = 20; // Check for threats every second

    // --- 2. Fields ---
    private final HamsterEntity hamster;
    private int checkTimer = 0;

    // --- 3. Constructors ---
    public HamsterSleepGoal(HamsterEntity hamster) {
        this.hamster = hamster;
        // Control movement and look to prevent interference
        this.setControls(EnumSet.of(Control.MOVE, Control.LOOK, Control.JUMP));
    }

    // --- 4. Public Methods (Overrides from Goal) ---
    @Override
    public boolean canStart() {
        // Only wild hamsters sleep via this goal.
        if (this.hamster.isTamed() ||
                this.hamster.isSleeping() ||
                this.hamster.isSitting() ||
                this.hamster.isKnockedOut()) {
            return false;
        }
        if (!this.hamster.getWorld().isDay()) {
            return false;
        }
        if (!this.hamster.isOnGround()) {
            return false;
        }
        if (this.checkTimer > 0) {
            this.checkTimer--;
            return false;
        }
        this.checkTimer = CHECK_INTERVAL;
        double radius = 5.0;
        boolean threatNearby = !this.hamster.getWorld().getOtherEntities(
                this.hamster,
                this.hamster.getBoundingBox().expand(radius),
                this::isThreat
        ).isEmpty();
        return !threatNearby;
    }

    /**
     * Called when the goal starts. Sets the hamster to a sleeping state,
     * plays a sleep sound, and triggers the wild settle sleep animation.
     */
    @Override
    public void start() {
        // --- Stop Movement and Targeting ---
        this.hamster.getNavigation().stop();
        this.hamster.setTarget(null);

        // --- Set Sleep State ---
        this.hamster.setSleeping(true);
        this.hamster.setInSittingPose(true); // Vanilla flag to prevent other AI movement

        // --- Trigger Wild Settle Sleep Animation ---
        if (!this.hamster.getWorld().isClient()) { // Ensure server-side
            // 1. Randomly select a sleep pose (1, 2, or 3)
            int choice = this.hamster.getRandom().nextInt(3);
            String settleAnimId;
            String deepSleepAnimIdForTracker;

            switch (choice) {
                case 0 -> {
                    settleAnimId = "anim_hamster_stand_settle_sleep1";
                    deepSleepAnimIdForTracker = "anim_hamster_sleep_pose1";
                }
                case 1 -> {
                    settleAnimId = "anim_hamster_stand_settle_sleep2";
                    deepSleepAnimIdForTracker = "anim_hamster_sleep_pose2";
                }
                default -> { // case 2
                    settleAnimId = "anim_hamster_stand_settle_sleep3";
                    deepSleepAnimIdForTracker = "anim_hamster_sleep_pose3";
                }
            }

            // 2. Store the chosen deep sleep animation name in the DataTracker
            this.hamster.getDataTracker().set(HamsterEntity.CURRENT_DEEP_SLEEP_ANIM_ID, deepSleepAnimIdForTracker);

            // 3. Trigger the corresponding settle animation
            this.hamster.triggerAnimOnServer("mainController", settleAnimId);

            // 4. Trigger the sound effects
            this.hamster.triggerSettleEffects(0.24f, 14, 0.27f);
        }

        // --- Play Sound ---
        if (!this.hamster.getWorld().isClient()) {
            SoundEvent sleepSound = ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_SLEEP_SOUNDS, this.hamster.getRandom());
            if (sleepSound != null) {
                this.hamster.getWorld().playSound(
                        null,
                        this.hamster.getBlockPos(),
                        sleepSound,
                        SoundCategory.NEUTRAL,
                        1.0F,
                        1.0F
                );
            }
        }
        this.hamster.setActiveCustomGoalDebugName(this.getClass().getSimpleName());
    }

    @Override
    public boolean shouldContinue() {
        if (this.hamster.isTamed() || !this.hamster.getWorld().isDay()) {
            return false;
        }
        if (this.checkTimer > 0) {
            this.checkTimer--;
            return true;
        }
        this.checkTimer = CHECK_INTERVAL;
        double radius = 5.0;
        boolean threatNearby = !this.hamster.getWorld().getOtherEntities(
                this.hamster,
                this.hamster.getBoundingBox().expand(radius),
                this::isThreat
        ).isEmpty();
        return !threatNearby;
    }

    @Override
    public void stop() {
        // If hamster was sleeping, trigger wake up animation and sound
        if (this.hamster.isSleeping()) {
            this.hamster.triggerWakeUpFromSleepAnimation(false);
        }

        this.hamster.setSleeping(false);
        this.hamster.setInSittingPose(false);
        this.checkTimer = 0;

        if (this.hamster.getActiveCustomGoalDebugName().equals(this.getClass().getSimpleName())) {
            this.hamster.setActiveCustomGoalDebugName("None");
        }
    }

    // --- 5. Private Helper Methods ---

    /**
     * Determines if the given entity is considered a threat to a sleeping wild hamster,
     * which would cause it to wake up.
     *
     * @param entity The entity to check.
     * @return True if the entity is a threat, false otherwise.
     */
    private boolean isThreat(Entity entity) {
        if (entity instanceof HostileEntity) {
            return true;
        }
        if (entity instanceof PlayerEntity) {
            return true;
        }
        return false;
    }
}
```

`HamsterStealDiamondGoal.java`
```java
package net.dawson.adorablehamsterpets.entity.AI;

// (Imports omitted to save token count)

public class HamsterStealDiamondGoal extends Goal {

    private final HamsterEntity hamster;
    private final World world;
    @Nullable private ItemEntity targetItem;
    @Nullable private PlayerEntity owner;
    @Nullable private Vec3d pounceStartPos;
    private int bounceSoundDelayTicks;
    private int tauntSettleTicks;
    @Nullable private Vec3d repositionTarget;
    private int repositionAttempts;

    private static final int LUNGE_DURATION_TICKS = 5;

    private enum State {
        SCANNING,
        MOVING_TO_DIAMOND,
        REPOSITIONING,
        POUNCING,
        FLEEING,
        TAUNTING
    }

    private int lungeTicks;
    private State currentState = State.SCANNING;
    private int stealDurationTimer;

    public HamsterStealDiamondGoal(HamsterEntity hamster) {
        this.hamster = hamster;
        this.world = hamster.getWorld();
        this.setControls(EnumSet.of(Control.MOVE, Control.LOOK, Control.JUMP));
    }
    
    @Override
    public boolean canStart() {
        AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] Evaluating canStart...", this.hamster.getId());
        // --- 1. Resume Logic ---
        if (this.hamster.isStealingDiamond()) {
            if (this.hamster.isSitting()) return false; // Don't resume if sitting
            if (!(this.hamster.getOwner() instanceof PlayerEntity)) return false; // Can't resume without an owner

            this.owner = (PlayerEntity) this.hamster.getOwner();
            AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] canStart SUCCEEDED: Resuming existing steal.", this.hamster.getId());
            return true; // Resume the goal
        }
        // --- 2. Steal Logic ---
        // --- Initial Checks ---
        if (!Configs.AHP.enableDiamondStealing) {
            return false; // Silent return
        }
        if (this.hamster.isStealingDiamond()) {
            AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] canStart FAILED: Hamster is already in a stealing state.", this.hamster.getId());
            return false;
        }
        if (this.hamster.isSitting()) {
            AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] canStart FAILED: Hamster is sitting.", this.hamster.getId());
            return false;
        }
        long currentTime = this.world.getTime();
        if (this.hamster.stealCooldownEndTick > currentTime) {
            AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] canStart FAILED: Steal cooldown is active for another {} ticks.", this.hamster.getId(), this.hamster.stealCooldownEndTick - currentTime);
            return false;
        }

        // --- Pounce Chance Check ---
        float randomVal = this.hamster.getRandom().nextFloat();
        float chance = Configs.AHP.diamondPounceChance.get();
        if (randomVal > chance) {
            // This is a common failure case, so we use trace to avoid spamming the log.
            AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] canStart FAILED: Pounce chance check failed (Rolled {} > Chance {})", this.hamster.getId(), String.format("%.2f", randomVal), String.format("%.2f", chance));
            return false;
        }

        // --- Owner Check ---
        if (!(this.hamster.getOwner() instanceof PlayerEntity playerOwner)) {
            AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] canStart FAILED: Hamster has no valid owner.", this.hamster.getId());
            return false;
        }
        this.owner = playerOwner;

        // --- Find Target Item ---
        List<Item> stealableItems = Configs.AHP.stealableItems.stream()
                .map(Identifier::tryParse)
                .filter(Objects::nonNull)
                .map(Registries.ITEM::get)
                .filter(item -> item != Items.AIR)
                .toList();

        if (stealableItems.isEmpty()) {
            AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] canStart FAILED: No valid stealable items configured or parsed.", this.hamster.getId());
            return false;
        }

        List<ItemEntity> nearbyItems = this.world.getEntitiesByClass(
                ItemEntity.class,
                this.hamster.getBoundingBox().expand(10.0),
                itemEntity -> ConfigDataCache.isStealableItem(itemEntity.getStack()) && itemEntity.isOnGround()
        );

        Optional<ItemEntity> closestItem = nearbyItems.stream()
                .filter(item -> this.hamster.getNavigation().findPathTo(item, 0) != null)
                .min((item1, item2) -> Float.compare(item1.distanceTo(this.hamster), item2.distanceTo(this.hamster)));

        if (closestItem.isPresent()) {
            this.targetItem = closestItem.get();
            AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] canStart SUCCEEDED. Target item: {} at {}. Owner: {}", this.hamster.getId(), this.targetItem.getStack().getItem(), this.targetItem.getBlockPos(), this.owner.getName().getString());
            return true;
        }

        return false;
    }

    @Override
    public boolean shouldContinue() {
        // --- 1. Check for external interruptions that should ALWAYS stop the goal ---
        if (this.hamster.isSitting()) {
            AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] shouldContinue check failed: Hamster is sitting.", this.hamster.getId());
            return false;
        }
        if (this.owner == null || !this.owner.isAlive()) {
            AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] shouldContinue check failed: Owner is null or not alive.", this.hamster.getId());
            return false;
        }
        if (this.stealDurationTimer <= 0) {
            AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] shouldContinue check failed: Steal duration timer expired.", this.hamster.getId());
            return false;
        }

        // --- 2. State-aware logic ---
        // If it is fleeing or taunting, the ONLY thing that should stop it (besides the checks above) is the player
        if (this.currentState == State.FLEEING || this.currentState == State.TAUNTING) {
            if (!this.hamster.isStealingDiamond()) {
                AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] shouldContinue check failed: Player retrieved diamond (isStealingDiamond is false).", this.hamster.getId());
                return false;
            }
        }
        // If it is moving to or pouncing on the item, it MUST still exist in the world.
        else if (this.currentState == State.MOVING_TO_DIAMOND || this.currentState == State.POUNCING) {
            if (this.targetItem == null || !this.targetItem.isAlive()) {
                AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] shouldContinue check failed: Target item disappeared before pounce.", this.hamster.getId());
                return false;
            }
        }

        return true; // All checks passed for the current state, continue the goal.
    }

    @Override
    public void start() {
        this.hamster.setActiveCustomGoalDebugName(this.getClass().getSimpleName());

        if (this.hamster.isStealingDiamond()) {
            // --- RESUME LOGIC ---
            this.stealDurationTimer = this.hamster.getStealDurationTimer();
            this.targetItem = null; // No item entity to target, it's already "stolen"
            AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] Resuming steal. Duration left: {} ticks.", this.hamster.getId(), this.stealDurationTimer);

            // Immediately decide whether to flee or taunt based on distance to owner
            if (this.hamster.distanceTo(this.owner) < Configs.AHP.minFleeDistance.get()) {
                this.currentState = State.FLEEING;
            } else {
                this.currentState = State.TAUNTING;
            }
        } else {
            // --- FRESH START LOGIC ---
            this.currentState = State.MOVING_TO_DIAMOND;
            this.hamster.getNavigation().startMovingTo(this.targetItem, 0.75D);
            this.stealDurationTimer = this.hamster.getRandom().nextBetween(
                    Configs.AHP.minStealDurationSeconds.get() * 20,
                    Configs.AHP.maxStealDurationSeconds.get() * 20
            );
            this.hamster.setStealDurationTimer(this.stealDurationTimer);
            this.repositionTarget = null;
            this.repositionAttempts = 0;
            AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] Goal started fresh. State: MOVING_TO_DIAMOND. Duration: {} ticks.", this.hamster.getId(), this.stealDurationTimer);
        }
    }

    @Override
    public void stop() {
        AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] Goal stopped. Final state was: {}.", this.hamster.getId(), this.currentState);

        // Apply cooldown regardless of how the goal ended.
        this.hamster.stealCooldownEndTick = this.world.getTime() + Configs.AHP.stealCooldownTicks.get();

        // Only drop the item if the goal is stopping because the timer ran out.
        // If it stops for any other reason (like player interaction), the timer will be > 0.
        if (this.hamster.isStealingDiamond() && this.stealDurationTimer <= 0) {
            ItemStack stolenStack = this.hamster.getStolenItemStack();
            if (!stolenStack.isEmpty()) {
                this.world.spawnEntity(new ItemEntity(this.world, this.hamster.getX(), this.hamster.getY(), this.hamster.getZ(), stolenStack.copy()));
                this.hamster.playSound(ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_HURT_SOUNDS, this.hamster.getRandom()), 1.0f, 1.0f);
                // Get and play the dynamic sound
                SoundEvent pounceSound = ModSounds.getDynamicItemSound(stolenStack);
                float volume = (pounceSound == SoundEvents.ENTITY_GENERIC_EAT) ? 0.35f : 1.0f;
                this.world.playSound(null, this.hamster.getBlockPos(), pounceSound, SoundCategory.NEUTRAL, volume, 1.7f);
                AdorableHamsterPets.LOGGER.trace ("[StealGoal-{}] Dropped stolen item {} because timer expired.", this.hamster.getId(), stolenStack.getItem());
            }
        }
        this.hamster.setStolenItemStack(ItemStack.EMPTY); // Clear the stolen item stack
        this.hamster.setStealDurationTimer(0);
        this.hamster.setTaunting(false);
        this.hamster.setStealingDiamond(false);
        this.hamster.getNavigation().stop();
        this.targetItem = null;
        this.owner = null;
        this.currentState = State.SCANNING;
        if (this.hamster.getActiveCustomGoalDebugName().equals(this.getClass().getSimpleName())) {
            this.hamster.setActiveCustomGoalDebugName("None");
        }
    }

    @Override
    public void tick() {
        // --- Timer Decrement ---
        if (this.stealDurationTimer > 0) {
            this.stealDurationTimer--;
            this.hamster.setStealDurationTimer(this.stealDurationTimer);
        }

        // --- Owner Check ---
        if (this.owner == null) {
            return; // Cannot proceed without an owner.
        }

        // --- Handle Delayed Bounce and Celebrate Sound ---
        if (this.bounceSoundDelayTicks > 0) {
            this.bounceSoundDelayTicks--;
            if (this.bounceSoundDelayTicks == 0) {
                this.hamster.playSound(ModSounds.HAMSTER_BOUNCE.get(), 0.6f, this.hamster.getSoundPitch() * 1.2f);
            }
        }

        this.stealDurationTimer--;
        this.hamster.setStealDurationTimer(this.stealDurationTimer);

        switch (this.currentState) {
            case MOVING_TO_DIAMOND:
                if (this.targetItem == null) return;
                this.hamster.getLookControl().lookAt(this.targetItem, HamsterEntity.FAST_YAW_CHANGE, HamsterEntity.FAST_PITCH_CHANGE);
                // If navigation stops before reaching the target, try to reposition.
                if (this.hamster.getNavigation().isIdle()) {
                    this.currentState = State.REPOSITIONING;
                    AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] Navigator is idle, transitioning to REPOSITIONING.", this.hamster.getId());
                    return; // End this tick, start repositioning on the next
                }
                if (this.hamster.distanceTo(this.targetItem) < 1.5) {
                    this.currentState = State.POUNCING;
                    this.lungeTicks = LUNGE_DURATION_TICKS; // Use the constant
                    this.pounceStartPos = this.hamster.getPos(); // Store starting position for the lunge
                    this.hamster.getNavigation().stop();
                    this.hamster.triggerAnimOnServer("mainController", "anim_hamster_diamond_pounce");
                    this.bounceSoundDelayTicks = 5;
                    // --- Play celebration sound ---
                    SoundEvent celebrationSound = ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_CELEBRATE_SOUNDS, this.hamster.getRandom());
                    if (celebrationSound != null) {
                        this.hamster.playSound(celebrationSound, 0.7f, this.hamster.getSoundPitch());
                    }
                    AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] State changed to POUNCING.", this.hamster.getId());
                }
                break;

            case REPOSITIONING:
                if (this.targetItem == null) return;
                // Check if exceeded repositioning budget.
                if (this.repositionAttempts >= 3) {
                    AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] Exceeded max reposition attempts. Stopping goal.", this.hamster.getId());
                    this.stealDurationTimer = 0; // Force the goal to stop.
                    // Also apply the cooldown to prevent an immediate restart loop.
                    return;
                }
                // If we don't have a reposition target yet, find one.
                if (this.repositionTarget == null) {
                    this.repositionAttempts++; // Increment the attempt counter.
                    // Use findTo to get a spot in the direction of the item.
                    this.repositionTarget = FuzzyTargeting.findTo(this.hamster, 2, 3, Vec3d.ofCenter(this.targetItem.getBlockPos()));
                    if (this.repositionTarget != null) {
                        this.hamster.getNavigation().startMovingTo(this.repositionTarget.x, this.repositionTarget.y, this.repositionTarget.z, 0.75D);
                        AdorableHamsterPets.LOGGER.trace ("[StealGoal-{}] Attempt #{}: Found repositioning target at {}. Moving now.", this.hamster.getId(), this.repositionAttempts, this.repositionTarget);
                    } else {
                        // If we can't find a random spot, the area is likely too cramped. Stop the goal.
                        AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] Could not find a repositioning target. Stopping goal.", this.hamster.getId());
                        this.stealDurationTimer = 0; // Force stop
                        return;
                    }
                }
                // If the navigator is idle, we've reached the reposition target or failed. Try again.
                if (this.hamster.getNavigation().isIdle()) {
                    this.repositionTarget = null; // Clear the target to find a new one next tick if needed
                    this.currentState = State.MOVING_TO_DIAMOND;
                    AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] Repositioning move complete. Transitioning back to MOVING_TO_DIAMOND.", this.hamster.getId());
                }
                break;

            case POUNCING:
                if (this.targetItem == null) return;
                this.lungeTicks--;

                // --- Pounce Lunge Interpolation ---
                if (this.pounceStartPos != null) {
                    // The pounce lunge uses the constant
                    if (this.lungeTicks >= 0) {
                        // Calculate progress (from 0.0 to 1.0 over the lunge duration)
                        double progress = (double)(LUNGE_DURATION_TICKS - this.lungeTicks) / LUNGE_DURATION_TICKS;
                        // Apply a quadratic ease-in curve for acceleration
                        double easedProgress = progress * progress;

                        // Interpolate X and Z coordinates. Y is left alone to be controlled by the animation's jump.
                        double newX = pounceStartPos.x + easedProgress * (this.targetItem.getX() - pounceStartPos.x);
                        double newZ = pounceStartPos.z + easedProgress * (this.targetItem.getZ() - pounceStartPos.z);
                        this.hamster.setPosition(newX, this.hamster.getY(), newZ);
                    }
                }

                if (this.lungeTicks < 0) {
                    // Get the stack from the target ItemEntity
                    ItemStack stackToSteal = this.targetItem.getStack().copy();
                    if (stackToSteal.isEmpty()) {
                        // Safety check in case the item entity's stack somehow became empty.
                        this.stealDurationTimer = 0; // Stop the goal.
                        return;
                    }

                    this.hamster.setStolenItemStack(stackToSteal);
                    this.targetItem.discard();
                    this.hamster.setStealingDiamond(true);

                    // --- Play Sounds and Spawn Particles Simultaneously ---
                    // Get the dynamic sound for the item
                    SoundEvent pounceSound = ModSounds.getDynamicItemSound(stackToSteal);
                    float volume = (pounceSound == SoundEvents.ENTITY_GENERIC_EAT) ? 0.35f : 1.0f;
                    this.world.playSound(null, this.hamster.getBlockPos(), pounceSound, SoundCategory.NEUTRAL, volume, 1.7f);

                    // Spawn particles
                    if (!this.world.isClient) {
                        ((ServerWorld)this.world).spawnParticles(ParticleTypes.END_ROD, this.hamster.getX(), this.hamster.getY() + 0.5, this.hamster.getZ(), 5, 0.1, 0.1, 0.1, 0.05);
                        // Use the actual stolenStack for the particle effect
                        ((ServerWorld)this.world).spawnParticles(new ItemStackParticleEffect(ParticleTypes.ITEM, stackToSteal), this.hamster.getX(), this.hamster.getY() + 0.5, this.hamster.getZ(), 18, 0.2, 0.2, 0.2, 0.1);
                    }

                    this.currentState = State.FLEEING;
                    AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] Pounce finished. Item stolen. State changed to FLEEING.", this.hamster.getId());
                }
                break;

            case FLEEING:
                this.hamster.setTaunting(false); // Ensure taunting is off while fleeing
                if (this.hamster.distanceTo(this.owner) < Configs.AHP.minFleeDistance.get()) {
                    Vec3d fleePos = FuzzyTargeting.findFrom(this.hamster, Configs.AHP.maxFleeDistance.get(), 7, this.owner.getPos());
                    // First, check if a valid flee position was found.
                    if (fleePos != null) {
                        // Then, attempt to start moving to it.
                        this.hamster.getNavigation().startMovingTo(fleePos.x, fleePos.y, fleePos.z, 1.5D);
                        AdorableHamsterPets.LOGGER.trace ("[StealGoal-{}] Fleeing: Owner too close, found new flee point at {}.", this.hamster.getId(), fleePos);
                    }
                } else {
                    this.currentState = State.TAUNTING;
                    this.hamster.getNavigation().stop();
                    AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] State changed to TAUNTING.", this.hamster.getId());
                }
                break;

            case TAUNTING:
                // Immediately start looking at the owner as soon as we enter the taunting state.
                this.hamster.getLookControl().lookAt(this.owner, HamsterEntity.FAST_YAW_CHANGE, HamsterEntity.FAST_PITCH_CHANGE);

                // If we just entered the taunting state, start the settle timer.
                if (!this.hamster.isTaunting() && this.tauntSettleTicks == 0) {
                    this.tauntSettleTicks = 5; // 5-tick (0.25s) taunt delay
                }

                if (this.tauntSettleTicks > 0) {
                    this.tauntSettleTicks--;
                }

                // Only set the taunting animation flag to true if the hamster has stopped moving and the settle timer is done.
                if (this.hamster.getNavigation().isIdle() && this.tauntSettleTicks == 0) {
                    this.hamster.setTaunting(true);
                }

                // Check if we need to switch back to fleeing.
                if (this.hamster.distanceTo(this.owner) < Configs.AHP.minFleeDistance.get()) {
                    this.currentState = State.FLEEING;
                    this.hamster.setTaunting(false); // Immediately turn off taunting when fleeing
                    this.tauntSettleTicks = 0; // Reset the settle timer
                    AdorableHamsterPets.LOGGER.trace("[StealGoal-{}] State changed back to FLEEING.", this.hamster.getId());
                }
                break;
        }
    }
}
```

`HamsterTemptGoal.java`
```java
package net.dawson.adorablehamsterpets.entity.AI;

// (Imports omitted to save token count)

public class HamsterTemptGoal extends TemptGoal {

    // --- 1. Fields ---
    private final HamsterEntity hamster;
    private int recheckTimer = 0; // Frequency of begging state updates

    // A custom predicate that uses the dynamic item tag check.
    private final TargetPredicate TEMPTATION_PREDICATE = TargetPredicate.createNonAttackable()
            .setBaseMaxDistance(10.0)
            .ignoreVisibility()
            .setPredicate(this::isTemptedBy);

    // --- 2. Constructors ---
    public HamsterTemptGoal(HamsterEntity hamster, double speed, boolean canBeScared) {
        // We must call super, but the Ingredient is now irrelevant.
        super(hamster, speed, Ingredient.EMPTY, canBeScared);
        this.hamster = hamster;
        this.setControls(EnumSet.of(Control.MOVE, Control.LOOK));
    }

    /**
     * This is the predicate method used by the custom TargetPredicate.
     * It checks if the given entity (a player) is holding a valid temptation item.
     */
    private boolean isTemptedBy(LivingEntity entity) {
        return ConfigDataCache.isTamingFood(entity.getMainHandStack()) || ConfigDataCache.isTamingFood(entity.getOffHandStack());
    }

    @Override
    public boolean canStart() {
        // --- 1. Cooldown and State Checks ---
        TemptGoalAccessor accessor = (TemptGoalAccessor) this;
        if (accessor.getCooldown() > 0) {
            accessor.setCooldown(accessor.getCooldown() - 1);
            return false;
        }
        if (this.hamster.isSitting() || this.hamster.isCelebratingDiamond()) {
            return false;
        }

        // --- 2. Custom Player Search ---
        // Instead of super.canStart(), we do the player search ourselves using our custom predicate.
        this.closestPlayer = this.hamster.getWorld().getClosestPlayer(this.TEMPTATION_PREDICATE, this.hamster);
        if (this.closestPlayer == null) {
            return false; // No tempting player found.
        }

        // --- 3. Ownership Check ---
        if (this.hamster.isTamed()) {
            return this.hamster.isOwner(this.closestPlayer);
        }

        return true; // Wild hamsters can be tempted by anyone.
    }



    @Override
    public void start() {
        super.start();
        this.hamster.setActiveCustomGoalDebugName(this.getClass().getSimpleName());
    }

    // --- 3. Public Methods (Overrides from TemptGoal/Goal) ---
    @Override
    public boolean shouldContinue() {
        // --- 1. Sitting Check ---
        if (this.hamster.isSitting() || this.hamster.isCelebratingDiamond()) {
            return false;
        }
        // --- End 1. Sitting Check ---

        // --- 2. Superclass Logic ---
        return super.shouldContinue();
    }

    @Override
    public void tick() {
        super.tick(); // Handles pathfinding towards the player and looking at them.

        // --- Begging State Logic ---
        if (this.recheckTimer > 0) {
            this.recheckTimer--;
            return;
        }
        this.recheckTimer = 5; // Re-check begging state roughly every 5 ticks.

        if (this.closestPlayer != null) {
            // The begging state should only be true if the player is actually holding the item.
            this.hamster.setBegging(isTemptedBy(this.closestPlayer));
        } else {
            this.hamster.setBegging(false);
        }
    }

    @Override
    public void stop() {
        super.stop(); // Calls vanilla TemptGoal's stop logic (clears navigation, sets cooldown).
        if (this.hamster.getActiveCustomGoalDebugName().equals(this.getClass().getSimpleName())) {
            this.hamster.setActiveCustomGoalDebugName("None");
        }
        this.hamster.setBegging(false);
        this.recheckTimer = 0;
    }
}
```

`HamsterWanderAroundFarGoal.java`
```java
package net.dawson.adorablehamsterpets.entity.AI;

// (Imports omitted to save token count)

public class HamsterWanderAroundFarGoal extends WanderAroundFarGoal {
    private final HamsterEntity hamster;
    private static final double BUFFED_WANDER_SPEED = 0.9D;

    public HamsterWanderAroundFarGoal(HamsterEntity hamster, double speed) {
        super(hamster, speed);
        this.hamster = hamster;
        this.setChance(110); // Chance for non-buffed state
    }

    public HamsterWanderAroundFarGoal(HamsterEntity hamster, double speed, float probability) {
        super(hamster, speed, probability);
        this.hamster = hamster;
        this.setChance(110); // Chance for non-buffed state
    }

    @Override
    public boolean canStart() {
        // --- 1. Initial State Checks ---
        if (this.hamster.isSitting() || this.hamster.isSleeping() || this.hamster.isKnockedOut() || this.hamster.isSulking() || this.hamster.isCelebratingDiamond() || this.hamster.isCelebratingChase()) {
            return false;
        }

        // --- 2. "Zoomies" vs. Normal Activation Logic ---
        if (this.hamster.hasGreenBeanBuff()) {

            // For zoomies, use a high-frequency check and bypass the superclass's internal cooldown.
            if (this.mob.getRandom().nextInt(3) != 0) {
                AdorableHamsterPets.LOGGER.trace("[WanderGoal-{}] canStart (Zoomies): FAILED - On cooldown.", this.hamster.getId());
                return false;
            }
            // We must manually find a target here because we are not calling super.canStart().
            Vec3d target = getWanderTarget();
            if (target == null) {
                AdorableHamsterPets.LOGGER.trace("[WanderGoal-{}] canStart (Zoomies): FAILED - No valid target found.", this.hamster.getId());
                return false;
            }
            // Set the target coordinates that the superclass would normally set.
            this.targetX = target.x;
            this.targetY = target.y;
            this.targetZ = target.z;
            AdorableHamsterPets.LOGGER.trace("[WanderGoal-{}] canStart (Zoomies): SUCCEEDED. Target: ({}, {}, {})", this.hamster.getId(), String.format("%.2f", target.x), String.format("%.2f", target.y), String.format("%.2f", target.z));
            return true; // A valid target was found.
        } else {
            // For normal wandering, defer to the superclass, which includes the 120-tick cooldown.
            boolean canStartNormal = super.canStart();
            AdorableHamsterPets.LOGGER.trace("[WanderGoal-{}] canStart (Normal): Result: {}", this.hamster.getId(), canStartNormal);
            return canStartNormal;
        }
    }

    @Override
    public boolean shouldContinue() {
        if (this.hamster.hasGreenBeanBuff()) {
            // For zoomies, the goal should now stop if it's interrupted OR if it has reached its destination.
            // This allows the canStart() cooldown to be checked again.
            return !(this.hamster.isSitting() || this.hamster.isSleeping() || this.hamster.isKnockedOut())
                    && !this.mob.getNavigation().isIdle();
        } else {
            // For normal wandering, use the default behavior.
            return super.shouldContinue();
        }
    }

    @Override
    public void tick() {
        // For "zoomies" mode, if the hamster reaches its destination, immediately find a new one.
        if (this.hamster.hasGreenBeanBuff() && this.mob.getNavigation().isIdle()) {
            AdorableHamsterPets.LOGGER.trace("[WanderGoal-{}] tick (Zoomies): Navigation is idle. Finding new target.", this.hamster.getId());
            Vec3d newTarget = this.getWanderTarget();
            if (newTarget != null) {
                this.mob.getNavigation().startMovingTo(newTarget.x, newTarget.y, newTarget.z, BUFFED_WANDER_SPEED);
            }
        }
        // For normal wandering, the superclass tick is empty, so we don't need to call it.
    }

    @Override
    public void start() {
        // --- Determine Speed Dynamically ---
        double currentSpeed = this.hamster.hasGreenBeanBuff() ? BUFFED_WANDER_SPEED : this.speed;
        this.mob.getNavigation().startMovingTo(this.targetX, this.targetY, this.targetZ, currentSpeed);

        this.hamster.setActiveCustomGoalDebugName(this.getClass().getSimpleName() + (this.hamster.hasGreenBeanBuff() ? " (Zoomies)" : ""));
        AdorableHamsterPets.LOGGER.trace("[WanderGoal-{}] start: Goal has started. IsBuffed: {}", this.hamster.getId(), this.hamster.hasGreenBeanBuff());
    }

    @Nullable
    @Override
    protected Vec3d getWanderTarget() {
        // --- 1. Priority: Green Bean Buff "Zoomies" ---
        if (this.hamster.hasGreenBeanBuff()) {
            // Convert the BlockPos from our precise helper to a Vec3d for the goal.
            return getPreciseZoomiesTarget().map(Vec3d::ofCenter).orElse(null);
        }

        // --- 2. Priority: Wander Mode (around bed) ---
        if (this.hamster.isWanderModeActive()) {
            Optional<GlobalPos> bedPosOptional = this.hamster.getLinkedBedPos();
            if (bedPosOptional.isPresent()) {
                GlobalPos bedGlobalPos = bedPosOptional.get();
                if (this.hamster.getWorld().getRegistryKey() == bedGlobalPos.getDimension()) {
                    BlockPos bedPos = bedGlobalPos.getPos();
                    BlockEntity be = this.hamster.getWorld().getBlockEntity(bedPos);
                    if (be instanceof HamsterBedBlockEntity bedEntity) {
                        WanderDistance distance = bedEntity.getWanderDistance();
                        int radius = switch (distance) {
                            case NEAR -> Configs.AHP.wanderDistanceNear.get();
                            case FAR -> Configs.AHP.wanderDistanceFar.get();
                            default -> Configs.AHP.wanderDistanceMedium.get();
                        };

                        // If hamster is outside its radius, path back towards the bed
                        if (this.hamster.getBlockPos().getSquaredDistance(bedPos) > radius * radius) {
                            Vec3d directionToBed = Vec3d.ofCenter(bedPos).subtract(this.hamster.getPos());
                            // Use findTo with a reasonable range to find a point in the direction of the bed
                            return FuzzyTargeting.findTo(this.mob, 7, 7, directionToBed);
                        } else {
                            // Hamster is inside the radius, find a random point centered on the bed
                            for (int i = 0; i < 10; ++i) { // Try up to 10 times
                                int dx = this.hamster.getRandom().nextInt(2 * radius + 1) - radius;
                                int dz = this.hamster.getRandom().nextInt(2 * radius + 1) - radius;

                                BlockPos potentialTarget = bedPos.add(dx, 0, dz);

                                if (bedPos.getSquaredDistance(potentialTarget) <= radius * radius) {
                                    BlockPos validatedPos = FuzzyTargeting.validate(this.mob, potentialTarget);
                                    if (validatedPos != null) {
                                        return Vec3d.ofBottomCenter(validatedPos);
                                    }
                                }
                            }
                            return null; // Failed to find a point
                        }
                    }
                }
            }
        }

        // --- 3. Fallback: Default Wandering ---
        return super.getWanderTarget();
    }

    /**
     * Calculates a precise point on a circle around the owner and finds the nearest safe,
     * reachable block. This avoids the imprecision of FuzzyTargeting.
     *
     * @return An Optional containing the safe BlockPos, or empty if none is found.
     */
    private Optional<BlockPos> getPreciseZoomiesTarget() {
        if (!(this.hamster.getOwner() instanceof PlayerEntity owner)) {
            return Optional.empty();
        }

        // --- Circular Pathing Logic ---
        double lastAngle = this.hamster.getLastZoomiesAngle();
        boolean isClockwise = this.hamster.getZoomiesIsClockwise();

        // Calculate the next angle step (degrees in radians).
        double angleStep = Math.toRadians(this.hamster.getRandom().nextBetween(40, 70));
        double newAngle = isClockwise ? lastAngle + angleStep : lastAngle - angleStep;
        this.hamster.setLastZoomiesAngle(newAngle); // Persist the new angle on the entity.

        // Calculate a new random point on the circumference of a circle whose radius is also randomized.
        int radiusModifier = this.hamster.getZoomiesRadiusModifier();
        double radius = this.hamster.getRandom().nextBetween(3 + radiusModifier, 5 + radiusModifier);
        double targetX = owner.getX() + radius * Math.cos(newAngle);
        double targetZ = owner.getZ() + radius * Math.sin(newAngle);

        // --- Precise Position Finding ---
        BlockPos idealPos = new BlockPos((int)targetX, (int)this.hamster.getY(), (int)targetZ);
        // Use the hamster's own safe spawn finder to locate a valid spot near our ideal point.

        // --- LOGGING ---
        Optional<BlockPos> finalTargetPos = this.hamster.findSafeSpawnPosition(idealPos, this.hamster.getWorld(), 2);
        AdorableHamsterPets.LOGGER.trace(
                "[WanderGoal-{}] getPreciseZoomiesTarget:\n  - IsClockwise: {}\n  - LastAngle(rad): {}\n  - AngleStep(rad): {}\n  - NewAngle(rad): {}\n  - Radius: {}\n  - IdealPos: {}\n  - FinalTarget: {}",
                this.hamster.getId(),
                isClockwise,
                String.format("%.2f", lastAngle),
                String.format("%.2f", angleStep),
                String.format("%.2f", newAngle),
                String.format("%.2f", radius),
                idealPos,
                finalTargetPos.map(BlockPos::toString).orElse("null")
        );

        return this.hamster.findSafeSpawnPosition(idealPos, this.hamster.getWorld(), 2);
    }


    @Override
    public void stop() {
        super.stop();
        if (this.hamster.getActiveCustomGoalDebugName().startsWith(this.getClass().getSimpleName())) {
            this.hamster.setActiveCustomGoalDebugName("None");
        }
        AdorableHamsterPets.LOGGER.trace("[WanderGoal-{}] stop: Goal has stopped.", this.hamster.getId());
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/entity/AI/navigation/`
`HamsterNavigation.java`
```java
package net.dawson.adorablehamsterpets.entity.AI.navigation;

// (Imports omitted to save token count)

/**
 * A custom navigation implementation for hamsters that avoids unlinked {@link HamsterBedBlock}s whenever possible.
 */
public class HamsterNavigation extends MobNavigation {
    private final HamsterEntity hamster;

    // --- Detour State ---
    @Nullable private BlockPos avoidanceWaypoint = null;
    @Nullable private BlockPos waypointTargetSnapshot = null; // Target position when waypoint was chosen
    @Nullable private Entity waypointEntitySnapshot = null;   // Entity target snapshot
    @Nullable private BlockPos lastUnsafeTarget = null; // The last target that required a detour
    private int unsafeCycles = 0;

    // --- Tuning ---
    private static final int MAX_ALT_ATTEMPTS = 10;
    private static final int ALT_RADIUS = 4;
    private static final double WAYPOINT_REACH_DIST_SQ = 1.5 * 1.5;
    private static final double TARGET_MOVE_REPATH_DIST_SQ = 5 * 5;
    private static final int ALLOW_UNSAFE_AFTER_CYCLES = 6; // Last resort after repeated failures

    /**
     * Constructs a new HamsterNavigation component.
     * @param hamster The hamster entity this navigator belongs to.
     * @param world The world the entity is in.
     */
    public HamsterNavigation(HamsterEntity hamster, World world) {
        super(hamster, world);
        this.hamster = hamster;
        AdorableHamsterPets.LOGGER.trace("[AHP Nav Debug] HamsterNavigation constructed for hamster {}", hamster.getUuid());
    }

    // --- High-Level Routing Entrypoints ---
    /**
     * Starts the hamster moving towards a specific coordinate, planning a path that avoids unlinked beds.
     * If a safe detour (waypoint) is already active and still valid for the target, it will continue pathing
     * towards the waypoint. Otherwise, it plans a new path, potentially selecting a new waypoint if the direct
     * route is unsafe.
     *
     * @return {@code true} if a path was successfully started, {@code false} otherwise.
     */
    @Override
    public boolean startMovingTo(double x, double y, double z, double speed) {
        BlockPos target = BlockPos.ofFloored(x, y, z);
        AdorableHamsterPets.LOGGER.trace("[AHP Nav Debug] startMovingTo(xyz={}, speed={})  waypoint={}",
                target, speed, avoidanceWaypoint);

        // If there is a valid waypoint, stick to it
        if (isWaypointValidForTarget(target, null)) {
            Path wp = super.findPathTo(avoidanceWaypoint, 0);
            if (wp != null) {
                AdorableHamsterPets.LOGGER.trace("[AHP Nav Debug] Using existing waypoint {} toward {}", avoidanceWaypoint, target);
                return this.startMovingAlong(wp, speed);
            } else {
                AdorableHamsterPets.LOGGER.trace("[AHP Nav Debug] Waypoint {} no longer pathable; clearing", avoidanceWaypoint);
                clearWaypoint();
            }
        }

        // Plan a path; this call can select a new waypoint
        Path planned = planPathWithWaypoint(target, null);
        return planned != null && this.startMovingAlong(planned, speed);
    }

    /**
     * Starts the hamster moving towards a target entity, planning a path that avoids unlinked beds.
     * This method functions similarly to {@link #startMovingTo(double, double, double, double)}, but tracks the
     * target entity's movement to invalidate the detour waypoint if the entity moves too far from its
     * original position.
     *
     * @return {@code true} if a path was successfully started, {@code false} otherwise.
     */
    @Override
    public boolean startMovingTo(Entity entity, double speed) {
        BlockPos target = entity.getBlockPos();
        AdorableHamsterPets.LOGGER.trace("[AHP Nav Debug] startMovingTo(entity={}, speed={}) waypoint={}",
                entity.getName().getString(), speed, avoidanceWaypoint);

        if (isWaypointValidForTarget(target, entity)) {
            Path wp = super.findPathTo(avoidanceWaypoint, 0);
            if (wp != null) {
                AdorableHamsterPets.LOGGER.trace("[AHP Nav Debug] Using existing waypoint {} toward entity {}", avoidanceWaypoint, entity.getName().getString());
                return this.startMovingAlong(wp, speed);
            } else {
                AdorableHamsterPets.LOGGER.trace("[AHP Nav Debug] Waypoint {} no longer pathable; clearing", avoidanceWaypoint);
                clearWaypoint();
            }
        }

        Path planned = planPathWithWaypoint(target, entity);
        return planned != null && this.startMovingAlong(planned, speed);
    }

    /**
     * Finds a path to the given position. This method is intentionally not overridden for detour planning
     * to maintain compatibility with AI goals that call it directly for simple checks. All detour and
     * waypoint logic is handled within the {@code startMovingTo} methods.
     *
     * @return A path to the target, or {@code null} if no path is found.
     */
    @Nullable
    @Override
    public Path findPathTo(BlockPos pos, int range) {
        // Delegate to parent; control planning via startMovingTo
        return super.findPathTo(pos, range);
    }

    // --- Tick Logic ---
    @Override
    public void tick() {
        super.tick();
        // Clear waypoint when reached
        if (avoidanceWaypoint != null) {
            double d2 = this.hamster.squaredDistanceTo(
                    avoidanceWaypoint.getX() + 0.5,
                    avoidanceWaypoint.getY() + 0.1,
                    avoidanceWaypoint.getZ() + 0.5);
            if (d2 <= WAYPOINT_REACH_DIST_SQ) {
                AdorableHamsterPets.LOGGER.trace("[AHP Nav Debug] Reached waypoint {}; clearing", avoidanceWaypoint);
                clearWaypoint();
            }
        }
    }

    // --- Planning ---
    /**
     * Plans a path to the target, creating a detour waypoint if the direct path is unsafe.
     * If the direct path is blocked by an unlinked hamster bed, this method attempts to find a safe
     * alternative nearby. If a safe alternative is found, it is set as a persistent {@code avoidanceWaypoint}.
     * If no safe path can be found after several attempts for the same target, it will eventually allow the
     * unsafe direct path as a last resort to prevent the hamster from getting stuck.
     */
    @Nullable
    private Path planPathWithWaypoint(BlockPos targetPos, @Nullable Entity targetEntity) {
        AdorableHamsterPets.LOGGER.trace("[AHP Nav Debug] planPathWithWaypoint target={}", targetPos);

        Path direct = super.findPathTo(targetPos, 0);
        boolean directUnsafe = direct != null && hamster.isPathThroughUnlinkedBed(direct);

        // If the direct path is safe, reset everything.
        if (!directUnsafe) {
            hamster.pathingFailures = 0;
            hamster.lastFailedTarget = null;
            if (avoidanceWaypoint != null) {
                AdorableHamsterPets.LOGGER.trace("[AHP Nav Debug] Direct path safe; clearing previous waypoint {}", avoidanceWaypoint);
                clearWaypoint();
            }
            return direct;
        }

        // Increment failure count as soon as a detour is needed
        if (hamster.lastFailedTarget == null || !hamster.lastFailedTarget.equals(targetPos)) {
            hamster.pathingFailures = 1; // First failure for this target
            hamster.lastFailedTarget = targetPos.toImmutable();
        } else {
            hamster.pathingFailures++; // Subsequent failure for same target
        }

        // Check if it should give up before searching for a new waypoint
        if (hamster.pathingFailures >= ALLOW_UNSAFE_AFTER_CYCLES) {
            AdorableHamsterPets.LOGGER.trace("[AHP Nav Debug] No safe alternates after {} cycles; allowing direct unsafe path to {}", hamster.pathingFailures, targetPos);
            hamster.pathingFailures = 0;
            hamster.lastFailedTarget = null;
            clearWaypoint();
            return direct; // Allow crossing
        }

        // Try alternates around the target and pick the first safe one
        for (int i = 0; i < MAX_ALT_ATTEMPTS; i++) {
            int dx = hamster.getRandom().nextBetween(-ALT_RADIUS, ALT_RADIUS);
            int dz = hamster.getRandom().nextBetween(-ALT_RADIUS, ALT_RADIUS);
            BlockPos alt = targetPos.add(dx, 0, dz);

            Path altPath = super.findPathTo(alt, 0);
            boolean altUnsafe = altPath == null || hamster.isPathThroughUnlinkedBed(altPath);
            AdorableHamsterPets.LOGGER.trace("[AHP Nav Debug] Alt attempt {}: {} → {} unsafe={}", i + 1, alt, (altPath == null ? "null" : ("len=" + altPath.getLength())), altUnsafe);

            if (!altUnsafe) {
                setWaypoint(alt, targetPos, targetEntity);
                AdorableHamsterPets.LOGGER.trace("[AHP Nav Debug] Using safe waypoint {} toward {}", avoidanceWaypoint, targetPos);
                return altPath;
            }
        }

        AdorableHamsterPets.LOGGER.trace("[AHP Nav Debug] No safe alternates this cycle; will retry next tick; refusing unsafe path to {}", targetPos);
        return null; // Do nothing this tick; caller won't start moving
    }

    // --- Waypoint validity ---
    private boolean isWaypointValidForTarget(BlockPos currentTargetPos, @Nullable Entity currentEntityTarget) {
        if (avoidanceWaypoint == null) return false;

        // If target entity moved too far since choosing the waypoint, invalidate
        if (waypointEntitySnapshot != null && currentEntityTarget != null) {
            double movedSq = currentEntityTarget.squaredDistanceTo(
                    waypointEntitySnapshot.getX(), waypointEntitySnapshot.getY(), waypointEntitySnapshot.getZ());
            if (movedSq > TARGET_MOVE_REPATH_DIST_SQ) {
                AdorableHamsterPets.LOGGER.trace("[AHP Nav Debug] Target entity moved too far; invalidating waypoint {}", avoidanceWaypoint);
                clearWaypoint();
                return false;
            }
        }

        // If static target shifted too far, invalidate
        if (waypointTargetSnapshot != null) {
            if (waypointTargetSnapshot.getSquaredDistance(currentTargetPos) > TARGET_MOVE_REPATH_DIST_SQ) {
                AdorableHamsterPets.LOGGER.trace("[AHP Nav Debug] Target position moved {}; invalidating waypoint {}",
                        waypointTargetSnapshot, avoidanceWaypoint);
                clearWaypoint();
                return false;
            }
        }

        // If a direct path to the current target is now safe, drop the waypoint
        Path directNow = super.findPathTo(currentTargetPos, 0);
        if (directNow != null && !hamster.isPathThroughUnlinkedBed(directNow)) {
            AdorableHamsterPets.LOGGER.trace("[AHP Nav Debug] Direct path became safe; clearing waypoint {}", avoidanceWaypoint);
            clearWaypoint();
            return false;
        }

        return true;
    }

    private void setWaypoint(BlockPos waypoint, BlockPos targetSnapshot, @Nullable Entity entitySnapshot) {
        this.avoidanceWaypoint = waypoint;
        this.waypointTargetSnapshot = targetSnapshot.toImmutable();
        this.waypointEntitySnapshot = entitySnapshot; // lightweight reference; used only for movement delta
    }

    private void clearWaypoint() {
        this.avoidanceWaypoint = null;
        this.waypointTargetSnapshot = null;
        this.waypointEntitySnapshot = null;
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/entity/client/`
`HamsterModel.java`
```java
package net.dawson.adorablehamsterpets.entity.client;

// (Imports omitted to save token count)

@SuppressWarnings("removal") // Suppress deprecation warnings for the old abstract methods

public class HamsterModel extends GeoModel<HamsterEntity> {

    // --- 1. Constants for Scaling and Positioning ---
    private static final float ADULT_SCALE = 0.8f;
    private static final float ADULT_HEAD_SCALE = 1.0f;
    private static final float BABY_SCALE = 0.5f;
    private static final float BABY_HEAD_SCALE = 1.2f;
    // --- End 1. Constants ---

    @Override
    public Identifier getModelResource(HamsterEntity animatable) {
        return Identifier.of(AdorableHamsterPets.MOD_ID, "geo/hamster.geo.json");
    }

    @Override
    public Identifier getTextureResource(HamsterEntity animatable) {
        // This is just a fallback; the actual texture is set in the renderer
        return Identifier.of(AdorableHamsterPets.MOD_ID, "textures/entity/hamster/orange.png");
    }

    @Override
    public Identifier getAnimationResource(HamsterEntity animatable) {
        return Identifier.of(AdorableHamsterPets.MOD_ID, "animations/anim_hamster.animation.json");
    }

    @Override
    public void setCustomAnimations(HamsterEntity entity, long instanceId, AnimationState<HamsterEntity> animationState) {
        super.setCustomAnimations(entity, instanceId, animationState);

        // --- Bone References ---
        CoreGeoBone rootBone = this.getAnimationProcessor().getBone("root");
        CoreGeoBone headParentBone = this.getAnimationProcessor().getBone("head_parent");
        CoreGeoBone leftCheekDefBone = this.getAnimationProcessor().getBone("left_cheek_deflated");
        CoreGeoBone rightCheekDefBone = this.getAnimationProcessor().getBone("right_cheek_deflated");
        CoreGeoBone leftCheekInfBone = this.getAnimationProcessor().getBone("left_cheek_inflated");
        CoreGeoBone rightCheekInfBone = this.getAnimationProcessor().getBone("right_cheek_inflated");

        // --- Cheek Pouch Visibility Logic ---
        if (leftCheekDefBone != null && leftCheekInfBone != null) {
            boolean leftFull = entity.isLeftCheekFull();
            leftCheekDefBone.setHidden(leftFull);
            leftCheekInfBone.setHidden(!leftFull);
        }
        if (rightCheekDefBone != null && rightCheekInfBone != null) {
            boolean rightFull = entity.isRightCheekFull();
            rightCheekDefBone.setHidden(rightFull);
            rightCheekInfBone.setHidden(!rightFull);
        }

        // --- Scaling & Rotation Logic ---
        // bodyParentBone scale is intentionally not set here, allowing JSON breathing anims to work proportionally.
        if (rootBone != null && headParentBone != null) {
            // 1. Determine the base scale for the entire model and the head.
            float baseScale = entity.isBaby() ? BABY_SCALE : ADULT_SCALE;
            float headScale = entity.isBaby() ? BABY_HEAD_SCALE : ADULT_HEAD_SCALE;

            // 2. Start with the base scale for all axes.
            rootBone.setScaleX(baseScale);
            rootBone.setScaleY(baseScale);
            rootBone.setScaleZ(baseScale);

            // 3. If it's a shoulder pet, apply the dynamic squash/stretch by overriding just the Y-axis scale.
            if (entity.isShoulderPet()) {
                rootBone.setScaleY(baseScale * entity.dynamicScaleY);
            }

            // 4. Set the head scale independently.
            headParentBone.setScaleX(headScale);
            headParentBone.setScaleY(headScale);
            headParentBone.setScaleZ(headScale);

            // --- Dynamic Throw Pitch ---
            // Rotates the root bone to match the flight trajectory
            if (entity.isThrown()) {
                double dx = entity.getX() - entity.prevX;
                double dy = entity.getY() - entity.prevY;
                double dz = entity.getZ() - entity.prevZ;
                double horizontalDistance = Math.sqrt(dx * dx + dz * dz);

                // Prevent rotation calculation on zero movement
                if (horizontalDistance > 0.001 || Math.abs(dy) > 0.001) {
                    // Positive X-Rot = Nose Up, Negative X-Rot = Nose Down
                    float pitchRadians = (float) Math.atan2(dy, horizontalDistance);
                    rootBone.setRotX(pitchRadians);
                }
            } else {
                // Ensure rotation is reset when landing/not thrown
                rootBone.setRotX(0);
            }
        }
    }
}
```

`HamsterRenderer.java`
```java
package net.dawson.adorablehamsterpets.entity.client;

// (Imports omitted to save token count)

public class HamsterRenderer extends GeoEntityRenderer<HamsterEntity> {

    private final float adultShadowRadius;
    private static final Map<Integer, HamsterCleaningSoundInstance> activeCleaningSounds = new HashMap<>();

    public HamsterRenderer(EntityRendererFactory.Context ctx) {
        super(ctx, new HamsterModel());
        this.adultShadowRadius = 0.2F;
        this.shadowRadius = this.adultShadowRadius;

        addRenderLayer(new HamsterOverlayLayer(this));
        addRenderLayer(new HamsterPinkPetalOverlayLayer(this));
    }

    @Override
    public Identifier getTextureLocation(HamsterEntity entity) {
        HamsterVariant variant = HamsterVariant.byId(entity.getVariant());
        String baseTextureName = variant.getBaseTextureName();
        return Identifier.of(
                AdorableHamsterPets.MOD_ID,
                "textures/entity/hamster/" + baseTextureName + ".png"
        );
    }

    @Override
    public void render(HamsterEntity entity, float entityYaw, float partialTick, MatrixStack poseStack,
                       VertexConsumerProvider bufferSource, int packedLight) {
        // --- 1. Manage Cleaning Sound ---
        boolean isCleaning = entity.isCleaning();
        HamsterCleaningSoundInstance sound = activeCleaningSounds.get(entity.getId());

        if (isCleaning && (sound == null || sound.isDone())) {
            sound = new HamsterCleaningSoundInstance(entity);
            activeCleaningSounds.put(entity.getId(), sound);
            MinecraftClient.getInstance().getSoundManager().play(sound);
        } else if (!isCleaning && sound != null) {
            sound.stop();
            activeCleaningSounds.remove(entity.getId());
        }

        // --- 2. Set Shadow Radius ---
        if (entity.isBaby()) {
            this.shadowRadius = this.adultShadowRadius * 0.5f;
        } else {
            this.shadowRadius = this.adultShadowRadius;
        }

        // --- 3. Report to Client-Side Tracker ---
        // Adds the entity's ID to a set to determine which entities are no longer being rendered.
        AdorableHamsterPetsClient.onHamsterRendered(entity.getId());

        // --- 4. Smooth Snow Layer Height Adjustment ---
        poseStack.push();
        float targetYOffset = 0.0f;
        BlockPos pos = entity.getBlockPos();
        BlockState blockState = entity.getWorld().getBlockState(pos);

        // If the block is a snow layer, apply a fixed offset equal to one layer's height.
        if (blockState.isOf(Blocks.SNOW)) {
            targetYOffset = 1.0f / 8.0f;
        }

        // Smoothly interpolate the current offset towards the target offset.
        // The 0.25f factor controls the speed of the transition.
        entity.renderedSnowYOffset += (targetYOffset - entity.renderedSnowYOffset) * 0.15f;
        poseStack.translate(0.0, entity.renderedSnowYOffset, 0.0);

        // --- 5. Force Animation Update for In-World Entities ---
        // This prevents animations from shoulder-pet dummies (FeatureRenderer)
        // from "bleeding" onto in-world hamsters during Flashback replays.
        if (!entity.isShoulderPet()) {
            software.bernie.geckolib.core.animatable.instance.AnimatableInstanceCache cache = entity.getAnimatableInstanceCache();
            if (cache != null) {
                software.bernie.geckolib.core.animation.AnimatableManager<?> manager = cache.getManagerForId(entity.getId());
                if (manager != null) {
                    manager.updatedAt(0.0);
                }
            }
        }

        // --- 6. Call Superclass Method ---
        super.render(entity, entityYaw, partialTick, poseStack, bufferSource, packedLight);

        // --- 7. Pop Matrix for Snow Adjustment ---
        poseStack.pop();
    }

    @Override
    public void preRender(MatrixStack poseStack, HamsterEntity animatable, BakedGeoModel model, @Nullable VertexConsumerProvider bufferSource, @Nullable VertexConsumer buffer,
                          boolean isReRender, float partialTick, int packedLight, int packedOverlay, float red, float green, float blue, float alpha) {
        super.preRender(poseStack, animatable, model, bufferSource, buffer, isReRender, partialTick, packedLight, packedOverlay, red, green, blue, alpha);

        model.getBone("left_foot").ifPresent(bone -> bone.setTrackingMatrices(true));
        model.getBone("nose").ifPresent(bone -> bone.setTrackingMatrices(true));
    }

    /**
     * Performs the final rendering steps for the entity, including handling post-animation particle effects.
     * <p>
     * This method polls a transient {@code particleEffectId} flag on the animatable entity each frame.
     * If the flag is set (by a particle keyframe event), it spawns the corresponding particle effect
     * at the animated bone's calculated world position and then immediately resets the flag to {@code null}
     * to prevent re-triggering.
     */
    @Override
    public void renderFinal(MatrixStack poseStack, HamsterEntity animatable, BakedGeoModel model, VertexConsumerProvider bufferSource, @Nullable VertexConsumer buffer, float partialTick, int packedLight, int packedOverlay, float red, float green, float blue, float alpha) {
        super.renderFinal(poseStack, animatable, model, bufferSource, buffer, partialTick, packedLight, packedOverlay, red, green, blue, alpha);

        if (animatable.particleEffectId != null) {
            Random random = animatable.getRandom();
            switch (animatable.particleEffectId) {
                case "attack_poof":
                    model.getBone("left_foot").ifPresent(bone -> {
                        Vector3d pos = bone.getWorldPosition();

                        for (int i = 0; i < 8; ++i) {
                            double d = random.nextGaussian() * 0.1;
                            double e = random.nextGaussian() * 0.2;
                            double f = random.nextGaussian() * 0.1;
                            animatable.getWorld().addParticle(ParticleTypes.POOF,
                                    pos.x + d, pos.y + e, pos.z + f,
                                    random.nextGaussian() * 0.05,
                                    random.nextGaussian() * 0.05,
                                    random.nextGaussian() * 0.05);
                        }
                    });
                    break;
                case "seeking_dust":
                    model.getBone("nose").ifPresent(bone -> {
                        Vector3d pos = bone.getWorldPosition();
                        BlockPos blockBelow = BlockPos.ofFloored(pos.x, pos.y - 0.1, pos.z).down();
                        BlockState state = animatable.getWorld().getBlockState(blockBelow);
                        if (state.isAir()) state = Blocks.DIRT.getDefaultState();

                        for (int i = 0; i < 12; ++i) {
                            double d = random.nextGaussian() * 0.2;
                            double e = random.nextGaussian() * 0.03;
                            double f = random.nextGaussian() * 0.2;
                            animatable.getWorld().addParticle(new BlockStateParticleEffect(ParticleTypes.FALLING_DUST, state),
                                    pos.x + d, pos.y + e, pos.z + f,
                                    0.0, 0.0, 0.0); // Speed is default
                        }
                    });
                    break;
            }
            animatable.particleEffectId = null;
        }
        // --- Handle Sound Spawning via Flag ---
        if (animatable.soundEffectId != null) {
            MinecraftClient client = MinecraftClient.getInstance();
            switch (animatable.soundEffectId) {
                case "hamster_step_sound":
                    BlockPos pos = animatable.getBlockPos();
                    BlockState blockState = animatable.getWorld().getBlockState(pos.down());
                    if (blockState.isAir()) blockState = animatable.getWorld().getBlockState(pos.down(2));
                    if (!blockState.isAir()) {
                        BlockSoundGroup group = blockState.getSoundGroup();
                        float volume = blockState.isOf(Blocks.GRAVEL) ? (0.10F * 0.60F) : 0.10F;
                        client.getSoundManager().play(new PositionedSoundInstance(
                                group.getStepSound(), SoundCategory.NEUTRAL, volume,
                                group.getPitch() * 1.5F, animatable.getRandom(),
                                animatable.getX(), animatable.getY(), animatable.getZ()
                        ));
                    }
                    break;
                case "hamster_beg_bounce":
                    SoundEvent bounceSound = ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_BOUNCE_SOUNDS, animatable.getRandom());
                    if (bounceSound != null) {
                        float basePitch = animatable.getSoundPitch();
                        float randomPitchAddition = animatable.getRandom().nextFloat() * 0.2f;
                        float finalPitch = (basePitch * 1.2f) + randomPitchAddition;
                        client.getSoundManager().play(new PositionedSoundInstance(
                                bounceSound, SoundCategory.NEUTRAL, 0.6f, finalPitch,
                                animatable.getRandom(), animatable.getX(), animatable.getY(), animatable.getZ()
                        ));
                    }
                    break;
            }
            // Reset the flag
            animatable.soundEffectId = null;
        }
    }

    @Override
    public void renderRecursively(MatrixStack poseStack, HamsterEntity animatable, GeoBone bone, RenderLayer renderType, VertexConsumerProvider bufferSource, VertexConsumer buffer, boolean isReRender, float partialTick, int packedLight, int packedOverlay, float red, float green, float blue, float alpha) {
        // First, call the super method to render the bone itself, passing the correct 14 arguments
        super.renderRecursively(poseStack, animatable, bone, renderType, bufferSource, buffer, isReRender, partialTick, packedLight, packedOverlay, red, green, blue, alpha);

        // Get the stolen item stack directly from the animatable entity
        ItemStack stolenStack = animatable.getStolenItemStack();

        // Now, check if this is the bone we want to attach our item to
        if (bone.getName().equals("nose") && animatable.isStealingDiamond()) {
            ItemRenderer itemRenderer = MinecraftClient.getInstance().getItemRenderer();

            poseStack.push();
            // Move the matrix to the bone's position and apply its transformations
            poseStack.translate(bone.getPosX(), bone.getPosY(), bone.getPosZ());
            poseStack.multiply(new Quaternionf().rotateZ(bone.getRotZ()));
            poseStack.multiply(new Quaternionf().rotateY(bone.getRotY()));
            poseStack.multiply(new Quaternionf().rotateX(bone.getRotX()));
            poseStack.scale(bone.getScaleX(), bone.getScaleY(), bone.getScaleZ());

            // --- MANUAL ADJUSTMENTS ---
            // These transformations are applied *relative to the nose bone's pivot point*.
            // The coordinate system is: +X is right, +Y is up, +Z is backward.

            // poseStack.translate(X, Y, Z): Moves the item.
            // X: Positive values move it to the hamster's right. Negative to the left.
            // Y: Positive values move it up. Negative moves it down.
            // Z: Positive values move it TOWARDS THE HAMSTER'S TAIL. Negative values move it FORWARD, AWAY FROM THE FACE.
            // To fix the diamond appearing at the tail, you need a negative Z value.
            poseStack.translate(0, 0.22F, -0.4F);

            // poseStack.scale(X, Y, Z): Resizes the item.
            // Values > 1.0 make it bigger. Values < 1.0 make it smaller.
            poseStack.scale(0.7f, 0.7f, 0.7f);


            // poseStack.multiply(...): Rotates the item. This is complex.
            // Rotates the item 90 degrees on its X-axis, which makes it stand upright as if held, rather than lying flat.
            poseStack.multiply(new Quaternionf(new AxisAngle4f((float) Math.toRadians(90), 1, 0, 0)));

            // Render the item from the DataTracker
            itemRenderer.renderItem(stolenStack, ModelTransformationMode.THIRD_PERSON_RIGHT_HAND, packedLight, packedOverlay, poseStack, bufferSource, animatable.getWorld(), animatable.getId());

            poseStack.pop();
        }
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/entity/client/feature/`
`HamsterShoulderFeatureRenderer.java`
```java
package net.dawson.adorablehamsterpets.entity.client.feature;

// (Imports omitted to save token count)

/**
 * Renders a Hamster model on the player's shoulder if shoulder data is present.
 * Handles scaling for baby/adult hamsters and texture variations.
 */

public class HamsterShoulderFeatureRenderer
        extends FeatureRenderer<AbstractClientPlayerEntity, PlayerEntityModel<AbstractClientPlayerEntity>> {

    // --- 1. Constants ---
    private static final float HAMSTER_SHOULDER_SCALE = 0.8f;

    // --- 2. Fields (Lazy Initialization) ---
    private final Map<ShoulderLocation, HamsterEntity> dummyHamsters = new EnumMap<>(ShoulderLocation.class);
    private final Map<ShoulderLocation, ShoulderHamsterRenderer> hamsterRenderers = new EnumMap<>(ShoulderLocation.class);

    // --- 3. Constructor ---
    public HamsterShoulderFeatureRenderer(
            FeatureRendererContext<AbstractClientPlayerEntity, PlayerEntityModel<AbstractClientPlayerEntity>> context
    ) {
        super(context);
    }

    // --- 4. Public Methods (Overrides from FeatureRenderer) ---
    @Override
    public void render(MatrixStack matrices, VertexConsumerProvider vertexConsumers, int light,
                       AbstractClientPlayerEntity player, float limbAngle, float limbDistance,
                       float tickDelta, float animationProgress, float headYaw, float headPitch) {

        PlayerEntityAccessor playerAccessor = (PlayerEntityAccessor) player;

        // --- Defensive Check ---
        // Some shader mods (Oculus/Iris) create "shadow" player entities that
        // do not have fully initialized DataTrackers. Attempting to access my custom data
        // on them can crash the game (NPE or IllegalArgumentException).
        // Catch these exceptions to safely skip rendering for these specific entities.
        if (!hasShoulderDataSafe(playerAccessor)) {
            return;
        }

        // --- Lazy Initialization ---
        if (this.dummyHamsters.isEmpty()) {
            initializeDummies(player.getWorld());
        }

        // --- Get the per-player data holder ---
        ClientShoulderHamsterData clientData = playerAccessor.adorablehamsterpets$getClientShoulderData();
        if (clientData == null) return; // Safety check

        // --- Render Hamster for Each Occupied Slot ---
        for (ShoulderLocation location : ShoulderLocation.values()) {
            NbtCompound shoulderNbt = playerAccessor.getShoulderHamster(location);
            if (!shoulderNbt.isEmpty()) {
                HamsterShoulderData.fromNbt(shoulderNbt).ifPresent(shoulderData ->
                        renderShoulderHamster(matrices, vertexConsumers, light, player, shoulderData, tickDelta, clientData, location)
                );
            }
        }
    }

    // --- 5. Private Helper Methods ---
    /**
     * Safely checks if the player has any shoulder hamster data.
     * Wraps the DataTracker access in a try-catch block to prevent crashes when rendering
     * malformed entities (e.g., shader shadows or uninitialized fake players).
     */
    private boolean hasShoulderDataSafe(PlayerEntityAccessor playerAccessor) {
        try {
            return playerAccessor.hasAnyShoulderHamster();
        } catch (RuntimeException e) {
            // Swallowing NPE/IllegalArgumentException here is intentional.
            // It indicates the entity is not in a valid state to have its data read.
            return false;
        }
    }

    /**
     * Applies visual data from the stored shoulder NBT to a specific dummy entity.
     * This ensures the rendered model has the correct appearance (variant, age, cheeks, etc.).
     */
    private void applyShoulderData(HamsterEntity dummyHamster, HamsterShoulderData data, PlayerEntity owner) {
        // --- Mark this as a shoulder pet for the animation controller ---
        dummyHamster.setShoulderPet(true);

        // --- Apply Visual Data ---
        dummyHamster.setVariant(data.variantId());
        dummyHamster.setLeftCheekFull((data.hamsterFlags() & HamsterEntity.LEFT_CHEEK_FULL_FLAG) != 0);
        dummyHamster.setRightCheekFull((data.hamsterFlags() & HamsterEntity.RIGHT_CHEEK_FULL_FLAG) != 0);
        dummyHamster.getDataTracker().set(HamsterEntity.PINK_PETAL_TYPE, data.pinkPetalType());
        dummyHamster.getDataTracker().set(HamsterEntity.ANIMATION_PERSONALITY_ID, data.animationPersonalityId());
        dummyHamster.setBreedingAge(data.breedingAge());

        // --- Set Ownership for Animation Logic ---
        dummyHamster.setOwnerUuid(owner.getUuid());
        dummyHamster.setTamed(true, false); // No attribute update needed
    }

    /**
     * Renders the GeckoLib model on the player's shoulder with appropriate transformations and animations.
     */
    private void renderShoulderHamster(
            MatrixStack matrices, VertexConsumerProvider vertexConsumers, int light,
            AbstractClientPlayerEntity player, HamsterShoulderData shoulderData, float tickDelta,
            ClientShoulderHamsterData clientData, ShoulderLocation location
    ) {
        // --- 1. Get the correct dummy and renderer for this specific location ---
        HamsterEntity dummyHamster = this.dummyHamsters.get(location);
        ShoulderHamsterRenderer hamsterRenderer = this.hamsterRenderers.get(location);
        if (dummyHamster == null || hamsterRenderer == null) return;

        // --- 2. Update Dummy Entity State from Pre-Ticked Data ---
        updateDummyState(dummyHamster, shoulderData, clientData, location, player);

        // Manually reset the animation manager's update timer.
        // This forces GeckoLib to perform a full animation update for this specific dummy instance,
        // overwriting any polluted state from other entities rendered in the same batch by Iris.
        // WITHOUT THIS BLOCK, IRIS WILL BREAK THE SHOULDER HAMSTERS
        AnimatableInstanceCache cache = dummyHamster.getAnimatableInstanceCache();
        if (cache != null) {
            AnimatableManager<?> manager = cache.getManagerForId(dummyHamster.getId());
            if (manager != null) {
                manager.updatedAt(0);
            }
        }

        // --- 3. Physics Simulation ---
        float renderOffsetY = clientData.getRenderOffsetY(location, tickDelta);
        float renderScaleY = clientData.getRenderScaleY(location, tickDelta);
        dummyHamster.dynamicScaleY = renderScaleY; // Set the scale on the dummy entity

        matrices.push();

        // --- 4. Apply Transformations Based on Location ---
        ItemStack chestStack = player.getInventory().getArmorStack(2);
        boolean isWearingChestplate = !chestStack.isEmpty() && !chestStack.isOf(Items.ELYTRA);
        boolean isSlim = "slim".equals(player.getModel()); // Do this for 1.20.1

        switch (location) {
            case RIGHT_SHOULDER -> {
                this.getContextModel().rightArm.rotate(matrices);
                float xOffset, yOffset;
                if (isWearingChestplate) {
                    // Universal offsets for when armor is worn
                    xOffset = -0.18F;
                    yOffset = -0.18F;
                } else {
                    // Original offsets based on player model
                    xOffset = isSlim ? -0.08F : -0.12F;
                    yOffset = -0.12F;
                }
                matrices.translate(xOffset, yOffset, -0.016F);
                matrices.multiply(RotationAxis.POSITIVE_Y.rotationDegrees(15.0F));
            }
            case LEFT_SHOULDER -> {
                this.getContextModel().leftArm.rotate(matrices);
                float xOffset, yOffset;
                if (isWearingChestplate) {
                    // Universal offsets for when armor is worn
                    xOffset = 0.18F;
                    yOffset = -0.18F;
                } else {
                    // Original offsets based on player model
                    xOffset = isSlim ? 0.08F : 0.12F;
                    yOffset = -0.12F;
                }
                matrices.translate(xOffset, yOffset, -0.016F);
                matrices.multiply(RotationAxis.POSITIVE_Y.rotationDegrees(-15.0F));
            }
            case HEAD -> {
                this.getContextModel().head.rotate(matrices);
                matrices.translate(0.0F, -0.5F, -0.05F);
            }
        }

        // --- 5. Apply Physics Offset ---
        // The negative sign is crucial to convert our simulation's "up is positive"
        // into the model's "up is negative" local coordinate space.
        matrices.translate(0.0F, -renderOffsetY, 0.0F);

        matrices.multiply(RotationAxis.POSITIVE_X.rotationDegrees(180.0F));
        matrices.scale(HAMSTER_SHOULDER_SCALE, HAMSTER_SHOULDER_SCALE, HAMSTER_SHOULDER_SCALE);
        float renderYaw = 180.0F - player.getBodyYaw();

        // --- 6. Render the Dummy Entity ---
        hamsterRenderer.render(dummyHamster, renderYaw, tickDelta, matrices, vertexConsumers, light);

        matrices.pop();
    }

    /**
     * Calculates the absolute world-space Y-coordinate of a player model's bone.
     *
     * @param matrices   The current MatrixStack from the render method.
     * @param anchorBone The ModelPart (e.g., head, rightArm) to measure.
     * @return The world-space Y-coordinate of the bone's pivot point.
     */
    private double getAnchorBoneWorldY(MatrixStack matrices, ModelPart anchorBone) {
        MatrixStack tempMatrices = new MatrixStack();
        tempMatrices.multiplyPositionMatrix(matrices.peek().getPositionMatrix());
        anchorBone.rotate(tempMatrices);
        Matrix4f finalMatrix = tempMatrices.peek().getPositionMatrix();
        // The Y translation component is at index m31 in a Matrix4f
        return finalMatrix.m31();
    }

    /**
     * Applies all pre-calculated state to the dummy entity right before rendering.
     * This is the final step that bridges the client-thread logic with the render-thread object.
     */
    private void updateDummyState(HamsterEntity dummyHamster, HamsterShoulderData nbtData, ClientShoulderHamsterData clientData, ShoulderLocation location, PlayerEntity owner) {
        // --- 1. Apply visual data from NBT ---
        applyShoulderData(dummyHamster, nbtData, owner);

        // --- 2. Apply animation clock from client data ---
        dummyHamster.age = clientData.getAnimationAge(location);

        // --- 3. Apply animation state from client data ---
        ShoulderHamsterState state = clientData.getHamsterState(location);
        if (state != null) {
            ShoulderAnimationState currentState = state.getCurrentState();
            dummyHamster.getDataTracker().set(HamsterEntity.SHOULDER_ANIMATION_STATE, currentState.ordinal());
            dummyHamster.setSitting(currentState == ShoulderAnimationState.SITTING, true);
        }

        // --- 4. Inform dummy of its location for animation controller ---
        dummyHamster.shoulderLocation = location;
    }

    /**
     * Initializes the dummy hamster entities and their specialized renderers, one for each shoulder location.
     * This is called once, the first time the feature needs to be rendered.
     */
    private void initializeDummies(World world) {
        if (world == null) return; // Cannot proceed without a world instance

        // We need an EntityRendererFactory.Context to create the renderers.
        MinecraftClient client = MinecraftClient.getInstance();
        EntityRendererFactory.Context context = new EntityRendererFactory.Context(
                client.getEntityRenderDispatcher(),
                client.getItemRenderer(),
                client.getBlockRenderManager(),
                client.getEntityRenderDispatcher().getHeldItemRenderer(),
                client.getResourceManager(),
                client.getEntityModelLoader(),
                client.textRenderer
        );

        for (ShoulderLocation location : ShoulderLocation.values()) {
            // Create a unique dummy entity for this location
            HamsterEntity dummy = new HamsterEntity(ModEntities.HAMSTER.get(), world);
            dummy.setNoGravity(true);
            dummy.setSilent(true);
            this.dummyHamsters.put(location, dummy);

            // Create a unique renderer for this location
            this.hamsterRenderers.put(location, new ShoulderHamsterRenderer(context));
        }
    }
}
```

`ShoulderAnimationState.java`
```java
package net.dawson.adorablehamsterpets.entity.client.feature;

public enum ShoulderAnimationState {
    STANDING,
    SITTING,
    LAYING_DOWN
}
```

`ShoulderHamsterState.java`
```java
package net.dawson.adorablehamsterpets.entity.client.feature;

// (Imports omitted to save token count)

/**
 * Manages the animation state for a single shoulder-mounted hamster.
 * This class is used exclusively on the client within the HamsterShoulderFeatureRenderer.
 */
public class ShoulderHamsterState {
    private ShoulderAnimationState currentState;
    private int timer; // Ticks remaining in the current state
    private final Random random = Random.create();
    private int sprintTransitionDelay = 0;
    private int idleSoundCooldown = 0;

    public ShoulderHamsterState() {
        // Start in a random state
        this.currentState = ShoulderAnimationState.values()[random.nextInt(ShoulderAnimationState.values().length)];
        this.timer = getNewRandomDuration();
    }

    /**
     * Ticks the state machine. This should be called once per game tick.
     * @param isPlayerSprinting True if the player is currently sprinting.
     */
    public void tick(boolean isPlayerSprinting, boolean isPlayerWalking) {
        // --- 1. Movement Logic (Highest Priority) ---
        boolean shouldForceLayDown = (Configs.AHP.forceLayDownOnSprint && isPlayerSprinting) ||
                (Configs.AHP.forceLayDownOnWalk && isPlayerWalking);

        if (shouldForceLayDown) {
            // If not already laying down or preparing to, start the transition.
            if (this.currentState != ShoulderAnimationState.LAYING_DOWN && this.sprintTransitionDelay == 0) {
                this.sprintTransitionDelay = random.nextBetween(1, 7);
            }

            // Countdown the sprint delay timer.
            if (this.sprintTransitionDelay > 0) {
                this.sprintTransitionDelay--;
                if (this.sprintTransitionDelay == 0) {
                    // Transition is complete. Force the state and set the temporary timer.
                    this.currentState = ShoulderAnimationState.LAYING_DOWN;
                    this.timer = random.nextBetween(5, 40); // 0.25-2 seconds
                }
            }
            // The state is now either LAYING_DOWN or a previous state during the delay.
            // No other logic should run this tick. A 'return' is unnecessary here, as the last statement in a 'void' method
        }
        // --- 2. Normal State Logic (Runs only if not sprinting) ---
        else {
            // Reset the sprint delay when not sprinting.
            this.sprintTransitionDelay = 0;

            // Countdown the main timer.
            if (this.timer > 0) {
                this.timer--;
            }

            // If the timer has expired, determine the next state.
            if (this.timer <= 0) {
                if (Configs.AHP.enableDynamicShoulderAnimations.get()) {
                    // DYNAMIC: Pick a new random state.
                    ShoulderAnimationState nextState;
                    do {
                        nextState = ShoulderAnimationState.values()[random.nextInt(ShoulderAnimationState.values().length)];
                    } while (nextState == this.currentState);
                    this.currentState = nextState;
                    this.timer = getNewRandomDuration(); // Reset with config duration.
                } else {
                    // NOT DYNAMIC: Snap to the forced state from config.
                    this.currentState = switch (Configs.AHP.forcedShoulderState.get()) {
                        case ALWAYS_SIT -> ShoulderAnimationState.SITTING;
                        case ALWAYS_LAY_DOWN -> ShoulderAnimationState.LAYING_DOWN;
                        default -> ShoulderAnimationState.STANDING;
                    };
                }
            }
        }

        // --- 3. Idle Sound Logic ---
        // Check the config setting first.
        if (!Configs.AHP.silenceShoulderIdleSounds) {
            // Use a random chance to play the sound periodically.
            if (this.idleSoundCooldown > 0) {
                this.idleSoundCooldown--;
            } else if (this.random.nextInt(250) == 0) { // Average once every 12.5 seconds
                MinecraftClient client = MinecraftClient.getInstance();
                if (client.player != null) {
                    SoundEvent idleSound = ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_IDLE_SOUNDS, this.random);
                    if (idleSound != null) {
                        client.getSoundManager().play(
                                new PositionedSoundInstance(
                                        idleSound,
                                        SoundCategory.PLAYERS,
                                        0.25f, // Quieter volume for shoulder pets
                                        1.2f + (this.random.nextFloat() - 0.5f) * 0.4f, // Higher, varied pitch
                                        this.random,
                                        client.player.getX(), client.player.getY(), client.player.getZ()
                                )
                        );
                        this.idleSoundCooldown = 100; // 5-second cooldown after playing a sound
                    }
                }
            }
        }
    }

    /**
     * Gets the current animation state determined by the state machine.
     * @return The current ShoulderAnimationState.
     */
    public ShoulderAnimationState getCurrentState() {
        return this.currentState;
    }

    /**
     * Updates the dummy hamster's internal DataTrackers and flags based on the current state.
     * This is the crucial link that allows the entity's own animation controller to function correctly.
     * @param hamster The dummy hamster entity to update.
     */
    private void updateHamsterEntityState(HamsterEntity hamster, ShoulderAnimationState stateToApply) {
        // Set the primary shoulder animation state tracker
        hamster.getDataTracker().set(HamsterEntity.SHOULDER_ANIMATION_STATE, stateToApply.ordinal());

        // Also update the core 'isSitting' flag. This is essential for the cleaning animation logic
        // and any other logic that relies on the general sitting state.
        hamster.setSitting(stateToApply == ShoulderAnimationState.SITTING, true);
    }

    private int getNewRandomDuration() {
        int min = Configs.AHP.shoulderMinStateSeconds.get() * 20;
        int max = Configs.AHP.shoulderMaxStateSeconds.get() * 20;
        if (min >= max) return min;
        return this.random.nextBetween(min, max);
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/entity/client/layer/`
`HamsterOverlayLayer.java`
```java
package net.dawson.adorablehamsterpets.entity.client.layer;

// (Imports omitted to save token count)

public class HamsterOverlayLayer extends GeoRenderLayer<HamsterEntity> {

    public HamsterOverlayLayer(GeoRenderer<HamsterEntity> entityRendererIn) {
        super(entityRendererIn);
    }

    // Helper method to construct the overlay texture identifier
    @Nullable
    private Identifier getOverlayTexture(HamsterEntity entity) {
        HamsterVariant variant = HamsterVariant.byId(entity.getVariant());
        String overlayName = variant.getOverlayTextureName();

        if (overlayName != null) {
            return Identifier.of(AdorableHamsterPets.MOD_ID, "textures/entity/hamster/" + overlayName + ".png");
        }
        return null; // No overlay for this variant
    }

    @Override
    public void render(MatrixStack poseStack, HamsterEntity animatable, BakedGeoModel bakedModel, RenderLayer renderType,
                       VertexConsumerProvider bufferSource, VertexConsumer buffer, float partialTick, int packedLight, int packedOverlay) {

        Identifier overlayTexture = getOverlayTexture(animatable);

        // If there is no overlayTexture, do nothing.
        if (overlayTexture != null) {
            RenderLayer overlayRenderType = RenderLayer.getEntityTranslucent(overlayTexture); // Use translucent so base shows through

            getRenderer().reRender(
                    bakedModel,
                    poseStack,
                    bufferSource,
                    animatable,
                    overlayRenderType,
                    bufferSource.getBuffer(overlayRenderType),
                    partialTick,
                    packedLight,
                    OverlayTexture.DEFAULT_UV,
                    1.0F, 1.0F, 1.0F, 1.0F // R, G, B, A
            );
        }
    }
}
```

`HamsterPinkPetalOverlayLayer.java`
```java
package net.dawson.adorablehamsterpets.entity.client.layer;

// (Imports omitted to save token count)

public class HamsterPinkPetalOverlayLayer extends GeoRenderLayer<HamsterEntity> {

    public HamsterPinkPetalOverlayLayer(GeoRenderer<HamsterEntity> entityRendererIn) {
        super(entityRendererIn);
    }

    @Nullable
    private Identifier getPetalTexture(HamsterEntity entity) {
        int petalType = entity.getDataTracker().get(HamsterEntity.PINK_PETAL_TYPE);
        if (petalType > 0 && petalType <= 3) {
            return Identifier.of(AdorableHamsterPets.MOD_ID, "textures/entity/hamster/overlay_pink_petal" + petalType + ".png");
        }
        return null; // No petal or invalid type
    }

    @Override
    public void render(MatrixStack poseStack, HamsterEntity animatable, BakedGeoModel bakedModel, RenderLayer renderType,
                       VertexConsumerProvider bufferSource, VertexConsumer buffer, float partialTick, int packedLight, int packedOverlay) {

        Identifier petalTexture = getPetalTexture(animatable);

        if (petalTexture != null) {
            RenderLayer petalRenderType = RenderLayer.getEntityTranslucent(petalTexture);

            getRenderer().reRender(
                    bakedModel,
                    poseStack,
                    bufferSource,
                    animatable,
                    petalRenderType,
                    bufferSource.getBuffer(petalRenderType),
                    partialTick,
                    packedLight,
                    OverlayTexture.DEFAULT_UV,
                    1.0F, 1.0F, 1.0F, 1.0F // R, G, B, A
            );
        }
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/entity/client/renderer/`
`ShoulderHamsterRenderer.java`
```java
package net.dawson.adorablehamsterpets.entity.client.renderer;

// (Imports omitted to save token count)

/**
 * A specialized renderer for the shoulder-mounted hamster.
 * It extends the base HamsterRenderer but overrides methods to suppress
 * sounds, particles, and other world-interactive effects that are not
 * needed for a purely cosmetic render.
 */
public class ShoulderHamsterRenderer extends HamsterRenderer {

    public ShoulderHamsterRenderer(EntityRendererFactory.Context ctx) {
        super(ctx);
    }

    /**
     * Overrides the main render method to bypass logic that is not relevant
     * for a shoulder-mounted entity, such as cleaning sounds and snow offset.
     */
    @Override
    public void render(HamsterEntity entity, float entityYaw, float partialTick, MatrixStack poseStack,
                       VertexConsumerProvider bufferSource, int packedLight) {
        this.shadowRadius = entity.isBaby() ? 0.1F : 0.2F;
        super.render(entity, entityYaw, partialTick, poseStack, bufferSource, packedLight);
    }

    /**
     * Overrides the final render step to prevent keyframe-triggered particles
     * and sounds from being processed for the shoulder model.
     */
    @Override
    public void renderFinal(MatrixStack poseStack, HamsterEntity animatable, BakedGeoModel model,
                            VertexConsumerProvider bufferSource, @Nullable VertexConsumer buffer,
                            float partialTick, int packedLight, int packedOverlay, float red, float green, float blue, float alpha) {
        super.renderFinal(poseStack, animatable, model, bufferSource, buffer, partialTick, packedLight, packedOverlay, red, green, blue, alpha);
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/entity/control/`
`HamsterBodyControl.java`
```java
package net.dawson.adorablehamsterpets.entity.control;

// (Imports omitted to save token count)

/**
 * A custom BodyControl that overrides the vanilla logic to ensure instant, unified rotation
 * for the GeckoLib-based Hamster model, while still respecting the difference between
 * movement-based rotation and look-based rotation.
 * <p>
 * This implementation forces the body to sync with the movement yaw when walking, and
 * instantly sync with the head yaw when standing still. This allows LookControl to
 * function correctly without the undesirable slow interpolation of the vanilla BodyControl.
 */
public class HamsterBodyControl extends BodyControl {
    private final MobEntity entity;

    public HamsterBodyControl(MobEntity entity) {
        super(entity);
        this.entity = entity;
    }

    /**
     * Overrides the default body rotation logic to force an immediate sync based on entity state.
     */
    @Override
    public void tick() {
        // If the hamster is moving (pathfinding), its body should face the direction of movement.
        if (this.isMoving()) {
            this.entity.bodyYaw = this.entity.getYaw();
        } else {
            // If the hamster is standing still, its body should instantly face where its head is looking.
            // This allows LookControl and AI goals to turn the hamster in place without a slow delay.
            this.entity.bodyYaw = this.entity.headYaw;
        }
    }

    /**
     * Checks if the entity has moved significantly since the last tick.
     * This logic is copied directly from the vanilla BodyControl class.
     * @return True if the entity is moving, false otherwise.
     */
    private boolean isMoving() {
        double d = this.entity.getX() - this.entity.prevX;
        double e = this.entity.getZ() - this.entity.prevZ;
        // A very small threshold to detect any horizontal movement.
        return d * d + e * e > 2.5000003E-7F;
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/entity/custom/`
`HamsterEntity.java`
```java
package net.dawson.adorablehamsterpets.entity.custom;

// (Imports omitted to save token count)

public class HamsterEntity extends TameableEntity implements GeoEntity, ImplementedInventory {


    /* ──────────────────────────────────────────────────────────────────────────────
     *                    1. Constants and Static Utilities
     * ────────────────────────────────────────────────────────────────────────────*/

    // --- Constants ---
    private static final double WALK_TO_RUN_THRESHOLD_SQUARED = 0.002;
    private static final double RUN_TO_SPRINT_THRESHOLD_SQUARED = 0.008;
    public static final float FAST_YAW_CHANGE = 25.0f;
    public static final float FAST_PITCH_CHANGE = 25.0f;
    private static final int INVENTORY_SIZE = 6;
    private static final int REFUSE_FOOD_TIMER_TICKS = 40;            // 2 seconds
    private static final int CUSTOM_LOVE_TICKS = 600;                 // 30 seconds
    private static final float THROW_DAMAGE = 20.0f;
    private static final double THROWN_GRAVITY = -0.05;
    private static final double HAMSTER_ATTACK_BOX_EXPANSION = 0.70D;  // Expand by 0.7 blocks horizontally (vanilla is 0.83 blocks, so really this is shrinking it)

    /**
     * Required by the Tameable interface in 1.20.1.
     * It provides a view of the world the entity is in.
     *
     * @return The world this entity belongs to.
     */
    @Override
    public EntityView method_48926() {
        return this.getWorld();
    }

    public enum DozingPhase {
        NONE,                  // Not in any part of the sleep sequence
        QUIESCENT_SITTING,     // Tamed, sitting by command, waiting for drowsiness timer
        DRIFTING_OFF,          // Playing the 90sec anim_hamster_drifting_off animation
        SETTLING_INTO_SLUMBER, // Playing a short anim_hamster_sit_settle_sleepX transition
        DEEP_SLEEP             // Looping one of the anim_hamster_sleep_poseX animations
    }

    public static final int CELEBRATION_PARTICLE_DURATION_TICKS = 600;    // 3 seconds
    private static final float DEFAULT_FOOTSTEP_VOLUME = 0.10F;
    private static final float GRAVEL_VOLUME_MODIFIER = 0.60F;
    private static final Set<PathNodeType> HAZARDOUS_FLOOR_TYPES = EnumSet.of(
            PathNodeType.LAVA,
            PathNodeType.DAMAGE_FIRE,
            PathNodeType.DANGER_FIRE,
            PathNodeType.POWDER_SNOW,
            PathNodeType.DAMAGE_OTHER,
            PathNodeType.DANGER_OTHER,
            PathNodeType.DAMAGE_CAUTIOUS,
            PathNodeType.WATER
    );

    private static final List<HamsterVariant> ORANGE_VARIANTS = List.of(
            HamsterVariant.ORANGE, HamsterVariant.ORANGE_OVERLAY1, HamsterVariant.ORANGE_OVERLAY2,
            HamsterVariant.ORANGE_OVERLAY3, HamsterVariant.ORANGE_OVERLAY4, HamsterVariant.ORANGE_OVERLAY5,
            HamsterVariant.ORANGE_OVERLAY6, HamsterVariant.ORANGE_OVERLAY7, HamsterVariant.ORANGE_OVERLAY8
    );
    private static final List<HamsterVariant> BLUE_VARIANTS = List.of(
            HamsterVariant.BLUE, HamsterVariant.BLUE_OVERLAY1, HamsterVariant.BLUE_OVERLAY2,
            HamsterVariant.BLUE_OVERLAY3, HamsterVariant.BLUE_OVERLAY4, HamsterVariant.BLUE_OVERLAY5,
            HamsterVariant.BLUE_OVERLAY6, HamsterVariant.BLUE_OVERLAY7, HamsterVariant.BLUE_OVERLAY8
    );
    private static final List<HamsterVariant> CHOCOLATE_VARIANTS = List.of(
            HamsterVariant.CHOCOLATE, HamsterVariant.CHOCOLATE_OVERLAY1, HamsterVariant.CHOCOLATE_OVERLAY2,
            HamsterVariant.CHOCOLATE_OVERLAY3, HamsterVariant.CHOCOLATE_OVERLAY4, HamsterVariant.CHOCOLATE_OVERLAY5,
            HamsterVariant.CHOCOLATE_OVERLAY6, HamsterVariant.CHOCOLATE_OVERLAY7, HamsterVariant.CHOCOLATE_OVERLAY8
    );
    private static final List<HamsterVariant> CREAM_VARIANTS = List.of(
            HamsterVariant.CREAM, HamsterVariant.CREAM_OVERLAY1, HamsterVariant.CREAM_OVERLAY2,
            HamsterVariant.CREAM_OVERLAY3, HamsterVariant.CREAM_OVERLAY4, HamsterVariant.CREAM_OVERLAY5,
            HamsterVariant.CREAM_OVERLAY6, HamsterVariant.CREAM_OVERLAY7, HamsterVariant.CREAM_OVERLAY8
    );
    private static final List<HamsterVariant> DARK_GRAY_VARIANTS = List.of(
            HamsterVariant.DARK_GRAY, HamsterVariant.DARK_GRAY_OVERLAY1, HamsterVariant.DARK_GRAY_OVERLAY2,
            HamsterVariant.DARK_GRAY_OVERLAY3, HamsterVariant.DARK_GRAY_OVERLAY4, HamsterVariant.DARK_GRAY_OVERLAY5,
            HamsterVariant.DARK_GRAY_OVERLAY6, HamsterVariant.DARK_GRAY_OVERLAY7, HamsterVariant.DARK_GRAY_OVERLAY8
    );
    private static final List<HamsterVariant> LAVENDER_VARIANTS = List.of(
            HamsterVariant.LAVENDER, HamsterVariant.LAVENDER_OVERLAY1, HamsterVariant.LAVENDER_OVERLAY2,
            HamsterVariant.LAVENDER_OVERLAY3, HamsterVariant.LAVENDER_OVERLAY4, HamsterVariant.LAVENDER_OVERLAY5,
            HamsterVariant.LAVENDER_OVERLAY6, HamsterVariant.LAVENDER_OVERLAY7, HamsterVariant.LAVENDER_OVERLAY8
    );
    private static final List<HamsterVariant> LIGHT_GRAY_VARIANTS = List.of(
            HamsterVariant.LIGHT_GRAY, HamsterVariant.LIGHT_GRAY_OVERLAY1, HamsterVariant.LIGHT_GRAY_OVERLAY2,
            HamsterVariant.LIGHT_GRAY_OVERLAY3, HamsterVariant.LIGHT_GRAY_OVERLAY4, HamsterVariant.LIGHT_GRAY_OVERLAY5,
            HamsterVariant.LIGHT_GRAY_OVERLAY6, HamsterVariant.LIGHT_GRAY_OVERLAY7, HamsterVariant.LIGHT_GRAY_OVERLAY8
    );

    /**
     * Determines the appropriate HamsterVariant for a given biome, using a prioritized, "hamster-centric" approach.
     * This method checks for variants from most specific/rare to most common, ensuring exclusive variants
     * like BLUE and LAVENDER are assigned correctly before falling back to more general, tag-based assignments.
     *
     * @param biomeEntry The RegistryEntry of the biome to check.
     * @param random     A Random instance for variant selection.
     * @return The chosen HamsterVariant.
     */
    private static HamsterVariant determineVariantForBiome(RegistryEntry<Biome> biomeEntry, net.minecraft.util.math.random.Random random) {
        String biomeName = biomeEntry.getKey().map(k -> k.getValue().toString()).orElse("unknown");
        AdorableHamsterPets.LOGGER.debug("[AHP Spawn Debug] determineVariantForBiome called for biome: {}", biomeName);

        HamsterVariant result;

        // --- Check from most specific/rare to most common ---
        if (canSpawnBlue(biomeEntry)) {
            // Ice Spikes has a 70% chance for Blue, 30% for White.
            result = random.nextInt(10) < 7 ? getRandomVariant(BLUE_VARIANTS, random) : HamsterVariant.WHITE;
        } else if (canSpawnLavender(biomeEntry)) {
            result = getRandomVariant(LAVENDER_VARIANTS, random);
        } else if (canSpawnWhite(biomeEntry)) {
            result = HamsterVariant.WHITE; // White has no overlays.
        } else if (canSpawnGray(biomeEntry)) {
            result = random.nextBoolean() ? getRandomVariant(LIGHT_GRAY_VARIANTS, random) : getRandomVariant(DARK_GRAY_VARIANTS, random);
        } else if (canSpawnBlack(biomeEntry)) {
            // Black hamsters should not spawn with overlays in the wild (breaks the camouflage effect)
            result = HamsterVariant.BLACK;
        } else if (canSpawnCream(biomeEntry)) {
            result = getRandomVariant(CREAM_VARIANTS, random);
        } else if (canSpawnChocolate(biomeEntry)) {
            result = getRandomVariant(CHOCOLATE_VARIANTS, random);
        } else {
            // Default Fallback: Orange is the most common, covering Plains, Savanna, etc.
            result = getRandomVariant(ORANGE_VARIANTS, random);
        }

        AdorableHamsterPets.LOGGER.debug("[AHP Spawn Debug] Determined variant for {} is {}", biomeName, result.name());
        return result;
    }

    // --- "Hamster-Centric" Helper Methods for Variant Spawning ---
    private static boolean canSpawnBlue(RegistryEntry<Biome> biomeEntry) {return ConfigDataCache.isBlueBiome(biomeEntry);}
    private static boolean canSpawnLavender(RegistryEntry<Biome> biomeEntry) {return ConfigDataCache.isLavenderBiome(biomeEntry);}
    private static boolean canSpawnWhite(RegistryEntry<Biome> biomeEntry) {return ConfigDataCache.isWhiteBiome(biomeEntry);}
    private static boolean canSpawnGray(RegistryEntry<Biome> biomeEntry) {return ConfigDataCache.isGrayBiome(biomeEntry);}
    private static boolean canSpawnBlack(RegistryEntry<Biome> biomeEntry) {return ConfigDataCache.isBlackBiome(biomeEntry);}
    private static boolean canSpawnCream(RegistryEntry<Biome> biomeEntry) {return ConfigDataCache.isCreamBiome(biomeEntry);}
    private static boolean canSpawnChocolate(RegistryEntry<Biome> biomeEntry) {return ConfigDataCache.isChocolateBiome(biomeEntry);}

    private static HamsterVariant getRandomVariant(List<HamsterVariant> variantPool, net.minecraft.util.math.random.Random random) {
        if (variantPool == null || variantPool.isEmpty()) {
            // Fallback
            return HamsterVariant.ORANGE;
        }
        return variantPool.get(random.nextInt(variantPool.size()));
    }

    /**
     * Creates the attribute container for the Hamster entity.
     * @return The attribute container builder.
     */
    public static DefaultAttributeContainer.Builder createHamsterAttributes() {
        return MobEntity.createMobAttributes()
                .add(EntityAttributes.GENERIC_MAX_HEALTH, Configs.AHP.wildMaxHealth.get())
                .add(EntityAttributes.GENERIC_MOVEMENT_SPEED, 0.25D)
                .add(EntityAttributes.GENERIC_ATTACK_DAMAGE, THROW_DAMAGE)
                .add(EntityAttributes.GENERIC_ATTACK_DAMAGE, Configs.AHP.meleeDamage.get())
                .add(EntityAttributes.GENERIC_FOLLOW_RANGE, 40.0D);
    }

    /**
     * Creates a HamsterEntity instance from NBT data, typically from a player's shoulder.
     * This method loads the hamster's variant, health, age, inventory, effects, and custom name.
     * It does NOT set the entity's position or spawn it in the world.
     *
     * @param world The server world to create the entity in.
     * @param player The player who owns the hamster.
     * @param nbt The NbtCompound containing the hamster's data, usually from the player's DataTracker.
     * @return A fully configured, but not yet spawned, HamsterEntity instance, or null if creation fails.
     */
    @Nullable
    public static HamsterEntity createFromNbt(ServerWorld world, PlayerEntity player, NbtCompound nbt) {
        Optional<HamsterShoulderData> dataOpt = HamsterShoulderData.fromNbt(nbt);
        if (dataOpt.isEmpty()) {
            AdorableHamsterPets.LOGGER.error("Failed to deserialize HamsterShoulderData from NBT: {}", nbt);
            return null;
        }
        HamsterShoulderData data = dataOpt.get();

        AdorableHamsterPets.LOGGER.debug("[HamsterEntity] createFromNbt called for player {} with data: {}", player.getName().getString(), data);
        HamsterEntity hamster = ModEntities.HAMSTER.get().create(world);

        if (hamster != null) {
            // --- 1. Load Core Data ---
            hamster.setUuid(data.entityUuid());
            hamster.setVariant(data.variantId());
            hamster.setHealth(data.health());
            hamster.setOwnerUuid(player.getUuid());
            hamster.setTamed(true, true);
            hamster.setBreedingAge(data.breedingAge());
            hamster.throwCooldownEndTick = data.throwCooldownEndTick();
            hamster.autoEatCooldownTicks = data.autoEatCooldownTicks();
            hamster.getDataTracker().set(PINK_PETAL_TYPE, data.pinkPetalType());
            hamster.getDataTracker().set(ANIMATION_PERSONALITY_ID, data.animationPersonalityId());
            hamster.getDataTracker().set(HAMSTER_FLAGS, data.hamsterFlags());

            // Explicitly clear the sitting flag to ensure the hamster always dismounts standing.
            hamster.setHamsterFlag(SITTING_FLAG, false);

            // --- 2. Load Custom Name ---
            data.customName().ifPresent(name -> {
                if (!name.isEmpty()) {
                    hamster.setCustomName(Text.literal(name));
                }
            });

            // --- 3. Load Inventory ---
            if (!data.inventoryNbt().isEmpty()) {
                Inventories.readNbt(data.inventoryNbt(), hamster.items);
                hamster.updateCheekTrackers();
            }

            // --- 4. Load Green Bean Buff Data/Status Effects ---
            HamsterShoulderData.GreenBeanBuffData buffData = data.greenBeanBuffData();
            hamster.greenBeanBuffEndTick = buffData.greenBeanBuffEndTick();
            hamster.getDataTracker().set(GREEN_BEAN_BUFF_DURATION, buffData.greenBeanBuffDuration());
            // In 1.20.1, handle NbtList directly
            NbtList effectsList = buffData.activeEffectsNbt();
            for (int i = 0; i < effectsList.size(); i++) {
                NbtCompound effectNbt = effectsList.getCompound(i);
                StatusEffectInstance effectInstance = StatusEffectInstance.fromNbt(effectNbt);
                if (effectInstance != null) {
                    hamster.addStatusEffect(effectInstance);
                }
            }

            // --- 5. Load Diamond Seeking Data ---
            HamsterShoulderData.SeekingBehaviorData seekingData = data.seekingBehaviorData();
            hamster.isPrimedToSeekDiamonds = seekingData.isPrimedToSeekDiamonds();
            hamster.foundOreCooldownEndTick = seekingData.foundOreCooldownEndTick();
            hamster.currentOreTarget = seekingData.currentOreTarget().orElse(null);

            // --- 6. Load Wander Mode/Bed Data ---
            HamsterShoulderData.WanderModeData wanderData = data.wanderModeData();
            hamster.linkedBedPos = wanderData.linkedBedPos();
            hamster.bypassNextSleepDelay = wanderData.bypassNextSleepDelay();

            // --- 7. Reset Transient States ---
            hamster.isAutoEating = false;
            hamster.autoEatProgressTicks = 0;

            // Explicitly reset transient action flags to prevent stuck states.
            hamster.setHamsterFlag(CLEANING_FLAG, false);
            hamster.setDozingPhase(DozingPhase.NONE);
        }
        return hamster;
    }

    /**
     * Spawns a HamsterEntity from NBT data near the player, handling position and spawning.
     * This is typically called when a player dismounts a hamster or respawns. It can accept a
     * pre-configured hamster instance (for throws) or create one from NBT (for dismounts/respawns).
     *
     * @param world The server world to spawn the entity in.
     * @param player The player who is dismounting the hamster.
     * @param nbt The NbtCompound containing the hamster's data.
     * @param wasDiamondAlertActive True if the hamster should be primed for diamond seeking.
     * @param preconfiguredHamster An optional, pre-configured HamsterEntity instance. If provided, this instance is used directly.
     */
    public static void spawnFromNbt(ServerWorld world, PlayerEntity player, NbtCompound nbt, boolean wasDiamondAlertActive, @Nullable HamsterEntity preconfiguredHamster) {
        // --- 1. Use Pre-configured Hamster or Create from NBT ---
        HamsterEntity hamster = preconfiguredHamster != null ? preconfiguredHamster : createFromNbt(world, player, nbt);
        if (hamster == null) {
            return;
        }

        // --- Set the suffocation grace period ---
        hamster.suffocationGracePeriod = 200; // 10 seconds

        // --- 2. Prime for Diamond Seeking (if applicable) ---
        if (wasDiamondAlertActive && Configs.AHP.enableIndependentDiamondSeeking) {
            hamster.isPrimedToSeekDiamonds = true;
            AdorableHamsterPets.LOGGER.debug("[HamsterEntity {}] Primed for diamond seeking upon dismount.", hamster.getId());
        }

        // --- 3. Set Position and Spawn ---
        if (hamster.isThrown()) {
            // If thrown, its position and velocity were already set. Just spawn it.
            world.spawnEntity(hamster);
            AdorableHamsterPets.LOGGER.debug("[HamsterEntity] Spawned THROWN Hamster ID {} from NBT data near Player {}.", hamster.getId(), player.getName().getString());
        } else {
            // If not thrown (standard dismount), find a safe landing spot.
            BlockPos initialSearchPos;
            BlockPos ultimateFallbackPos = player.getBlockPos(); // Player's feet as the last resort

        // Raycast to find where the player is looking
        HitResult hitResult = player.raycast(4.5, 0.0f, false);
        if (hitResult.getType() == HitResult.Type.BLOCK) {
            initialSearchPos = ((net.minecraft.util.hit.BlockHitResult) hitResult).getBlockPos();
        } else {
            initialSearchPos = ultimateFallbackPos; // Default to player's position if not looking at a block
        }

        // Use the safe spawning algorithm
        Optional<BlockPos> safePosOpt = hamster.findSafeSpawnPosition(initialSearchPos, world, 5);

        // --- 4. Set Position and Spawn ---
        safePosOpt.ifPresentOrElse(
                safePos -> {
                    // Spawn at the center of the safe block
                    hamster.refreshPositionAndAngles(safePos.getX() + 0.5, safePos.getY(), safePos.getZ() + 0.5, player.getYaw(), player.getPitch());
                    AdorableHamsterPets.LOGGER.debug("[HamsterDismount] Found safe spawn at {} for player {}.", safePos, player.getName().getString());
                },
                () -> {
                    // Fallback if no safe spot is found
                    AdorableHamsterPets.LOGGER.warn("[HamsterDismount] Could not find a safe spawn position for player {}. Spawning at player's feet as a fallback.", player.getName().getString());
                    hamster.refreshPositionAndAngles(ultimateFallbackPos.getX() + 0.5, ultimateFallbackPos.getY(), ultimateFallbackPos.getZ() + 0.5, player.getYaw(), player.getPitch());
                }
        );

        world.spawnEntityAndPassengers(hamster);
        AdorableHamsterPets.LOGGER.debug("[HamsterEntity] Spawned Hamster ID {} from NBT data near Player {}.", hamster.getId(), player.getName().getString());
        }
    }

    /**
     * Attempts to throw the hamster from the player's shoulder.
     * This server-side logic is triggered when the throw packet is received. It now delegates
     * the core logic to the PlayerEntityMixin, which determines which hamster to dismount/throw
     * based on the configured LIFO/FIFO order.
     *
     * @param player The player attempting the throw.
     */
    public static void tryThrowFromShoulder(ServerPlayerEntity player) {
        // --- 1. Initial Setup & Config Check ---
        PlayerEntityAccessor playerAccessor = (PlayerEntityAccessor) player;
        final AhpConfig config = AdorableHamsterPets.CONFIG;

        if (!config.enableHamsterThrowing) {
            player.sendMessage(Text.translatable("message.adorablehamsterpets.throwing_disabled"), true);
            return;
        }

        if (!playerAccessor.hasAnyShoulderHamster()) {
            AdorableHamsterPets.LOGGER.warn("[HamsterThrow] Player {} tried to throw, but has no shoulder hamster.", player.getName().getString());
            return;
        }

        // --- 2. Delegate Dismount/Throw Logic ---
        playerAccessor.adorablehamsterpets$dismountShoulderHamster(true);
    }

    // --- Bitmask Flags for DataTracker ---
    public static final int SLEEPING_FLAG = 1 << 0;
    public static final int SITTING_FLAG = 1 << 1;
    public static final int BEGGING_FLAG = 1 << 2;
    public static final int IN_LOVE_FLAG = 1 << 3;
    public static final int REFUSING_FOOD_FLAG = 1 << 4;
    public static final int THROWN_FLAG = 1 << 5;
    public static final int LEFT_CHEEK_FULL_FLAG = 1 << 6;
    public static final int RIGHT_CHEEK_FULL_FLAG = 1 << 7;
    public static final int KNOCKED_OUT_FLAG = 1 << 8;
    public static final int CHEEK_POUCH_UNLOCKED_FLAG = 1 << 9;
    public static final int CONSIDERING_AUTO_EAT_FLAG = 1 << 10;
    public static final int SULKING_FLAG = 1 << 11;
    public static final int CELEBRATING_DIAMOND_FLAG = 1 << 12;
    public static final int CLEANING_FLAG = 1 << 13;
    public static final int STEALING_DIAMOND_FLAG = 1 << 14;
    public static final int TAUNTING_FLAG = 1 << 15;
    public static final int CELEBRATING_CHASE_FLAG = 1 << 16;
    public static final int IS_SHOULDER_PET_FLAG = 1 << 17;
    public static final int IS_WANDER_MODE_ACTIVE_FLAG = 1 << 18;
    public static final int ON_THE_WAY_TO_BED_FLAG = 1 << 19;

    // --- Data Trackers ---
    private static final TrackedData<Integer> HAMSTER_FLAGS = DataTracker.registerData(HamsterEntity.class, TrackedDataHandlerRegistry.INTEGER);
    private static final TrackedData<Integer> VARIANT = DataTracker.registerData(HamsterEntity.class, TrackedDataHandlerRegistry.INTEGER);
    public static final TrackedData<Integer> ANIMATION_PERSONALITY_ID = DataTracker.registerData(HamsterEntity.class, TrackedDataHandlerRegistry.INTEGER);
    public static final TrackedData<Integer> PINK_PETAL_TYPE = DataTracker.registerData(HamsterEntity.class, TrackedDataHandlerRegistry.INTEGER);
    public static final TrackedData<Integer> DOZING_PHASE = DataTracker.registerData(HamsterEntity.class, TrackedDataHandlerRegistry.INTEGER);
    public static final TrackedData<String> CURRENT_DEEP_SLEEP_ANIM_ID = DataTracker.registerData(HamsterEntity.class, TrackedDataHandlerRegistry.STRING);
    private static final TrackedData<String> ACTIVE_CUSTOM_GOAL_NAME_DEBUG = DataTracker.registerData(HamsterEntity.class, TrackedDataHandlerRegistry.STRING);
    public static final TrackedData<Integer> STEAL_DURATION_TIMER = DataTracker.registerData(HamsterEntity.class, TrackedDataHandlerRegistry.INTEGER);
    public static final TrackedData<ItemStack> STOLEN_ITEM_STACK = DataTracker.registerData(HamsterEntity.class, TrackedDataHandlerRegistry.ITEM_STACK);
    public static final TrackedData<Long> GREEN_BEAN_BUFF_DURATION = DataTracker.registerData(HamsterEntity.class, TrackedDataHandlerRegistry.LONG);
    public static final TrackedData<Integer> CURRENT_LOOK_UP_ANIM_ID = DataTracker.registerData(HamsterEntity.class, TrackedDataHandlerRegistry.INTEGER);
    public static final TrackedData<Integer> SHOULDER_ANIMATION_STATE = DataTracker.registerData(HamsterEntity.class, TrackedDataHandlerRegistry.INTEGER);

    // --- Animation Constants ---
    private static final RawAnimation CRASH_ANIM = RawAnimation.begin().thenPlay("anim_hamster_crash");
    private static final RawAnimation KNOCKED_OUT_ANIM = RawAnimation.begin().thenPlay("anim_hamster_ko");
    private static final RawAnimation WAKE_UP_FROM_KO_ANIM = RawAnimation.begin().thenPlay("anim_hamster_wakeup_from_ko");
    private static final RawAnimation FLYING_ANIM = RawAnimation.begin().thenPlay("anim_hamster_flying");
    private static final RawAnimation STATIONARY_HEADSHAKE_ANIM = RawAnimation.begin().thenPlay("anim_hamster_stationary_headshake");
    private static final RawAnimation MOVING_HEADSHAKE_ANIM = RawAnimation.begin().thenPlay("anim_hamster_moving_headshake");
    private static final RawAnimation SLEEP_POSE1_ANIM = RawAnimation.begin().thenPlay("anim_hamster_sleep_pose1");
    private static final RawAnimation SLEEP_POSE2_ANIM = RawAnimation.begin().thenPlay("anim_hamster_sleep_pose2");
    private static final RawAnimation SLEEP_POSE3_ANIM = RawAnimation.begin().thenPlay("anim_hamster_sleep_pose3");
    private static final RawAnimation SIT_SETTLE_SLEEP1_ANIM = RawAnimation.begin().thenPlay("anim_hamster_sit_settle_sleep1");
    private static final RawAnimation SIT_SETTLE_SLEEP2_ANIM = RawAnimation.begin().thenPlay("anim_hamster_sit_settle_sleep2");
    private static final RawAnimation SIT_SETTLE_SLEEP3_ANIM = RawAnimation.begin().thenPlay("anim_hamster_sit_settle_sleep3");
    private static final RawAnimation STAND_SETTLE_SLEEP1_ANIM = RawAnimation.begin().thenPlay("anim_hamster_stand_settle_sleep1");
    private static final RawAnimation STAND_SETTLE_SLEEP2_ANIM = RawAnimation.begin().thenPlay("anim_hamster_stand_settle_sleep2");
    private static final RawAnimation STAND_SETTLE_SLEEP3_ANIM = RawAnimation.begin().thenPlay("anim_hamster_stand_settle_sleep3");
    private static final RawAnimation SIT1_ANIM = RawAnimation.begin().thenPlay("anim_hamster_sit1");
    private static final RawAnimation SIT2_ANIM = RawAnimation.begin().thenPlay("anim_hamster_sit2");
    private static final RawAnimation SIT3_ANIM = RawAnimation.begin().thenPlay("anim_hamster_sit3");
    private static final RawAnimation STANDUP1_ANIM = RawAnimation.begin().thenPlay("anim_hamster_standup1");
    private static final RawAnimation STANDUP2_ANIM = RawAnimation.begin().thenPlay("anim_hamster_standup2");
    private static final RawAnimation STANDUP3_ANIM = RawAnimation.begin().thenPlay("anim_hamster_standup3");
    private static final RawAnimation WAKE_UP_1_ANIM = RawAnimation.begin().thenPlay("anim_hamster_wakeup1");
    private static final RawAnimation WAKE_UP_2_ANIM = RawAnimation.begin().thenPlay("anim_hamster_wakeup2");
    private static final RawAnimation WAKE_UP_3_ANIM = RawAnimation.begin().thenPlay("anim_hamster_wakeup3");
    private static final RawAnimation SITTING_POSE1_ANIM = RawAnimation.begin().thenPlay("anim_hamster_sitting_pose1");
    private static final RawAnimation SITTING_POSE2_ANIM = RawAnimation.begin().thenPlay("anim_hamster_sitting_pose2");
    private static final RawAnimation SITTING_POSE3_ANIM = RawAnimation.begin().thenPlay("anim_hamster_sitting_pose3");
    private static final RawAnimation DRIFTING_OFF_POSE1_ANIM = RawAnimation.begin().thenPlay("anim_hamster_drifting_off_pose1");
    private static final RawAnimation DRIFTING_OFF_POSE2_ANIM = RawAnimation.begin().thenPlay("anim_hamster_drifting_off_pose2");
    private static final RawAnimation DRIFTING_OFF_POSE3_ANIM = RawAnimation.begin().thenPlay("anim_hamster_drifting_off_pose3");
    private static final RawAnimation CLEANING_ANIM = RawAnimation.begin().thenPlay("anim_hamster_cleaning");
    private static final RawAnimation RUNNING_ANIM = RawAnimation.begin().thenPlay("anim_hamster_running");
    private static final RawAnimation WALKING_ANIM = RawAnimation.begin().thenPlay("anim_hamster_walking");
    private static final RawAnimation SPRINTING_ANIM = RawAnimation.begin().thenPlay("anim_hamster_sprinting");
    private static final RawAnimation BEGGING_ANIM = RawAnimation.begin().thenPlay("anim_hamster_begging");
    private static final RawAnimation IDLE1_ANIM = RawAnimation.begin().thenPlay("anim_hamster_idle1");
    private static final RawAnimation IDLE2_ANIM = RawAnimation.begin().thenPlay("anim_hamster_idle2");
    private static final RawAnimation IDLE_LOOKING_UP1_ANIM = RawAnimation.begin().thenPlay("anim_hamster_idle_looking_up1");
    private static final RawAnimation IDLE_LOOKING_UP2_ANIM = RawAnimation.begin().thenPlay("anim_hamster_idle_looking_up2");
    private static final RawAnimation IDLE_LOOKING_UP3_ANIM = RawAnimation.begin().thenPlay("anim_hamster_idle_looking_up3");
    private static final RawAnimation ATTACK_ANIM = RawAnimation.begin().thenPlay("anim_hamster_attack");
    private static final RawAnimation SULK_ANIM = RawAnimation.begin().thenPlay("anim_hamster_sulk");
    private static final RawAnimation SULKING_ANIM = RawAnimation.begin().thenPlay("anim_hamster_sulking");
    private static final RawAnimation SEEKING_DIAMOND_ANIM = RawAnimation.begin().thenPlay("anim_hamster_seeking_diamond");
    private static final RawAnimation WANTS_TO_SEEK_DIAMOND_ANIM = RawAnimation.begin().thenPlay("anim_hamster_wants_to_seek_diamond");
    private static final RawAnimation DIAMOND_POUNCE_ANIM = RawAnimation.begin().thenPlay("anim_hamster_diamond_pounce");
    private static final RawAnimation DIAMOND_TAUNT_ANIM = RawAnimation.begin().thenPlay("anim_hamster_diamond_taunt");
    private static final RawAnimation CELEBRATE_CHASE_ANIM = RawAnimation.begin().thenPlay("anim_hamster_celebrate_chase");
    private static final RawAnimation LAYING_DOWN_HEAD_ANIM = RawAnimation.begin().thenPlay("anim_hamster_shoulder_laying_down_head");
    private static final RawAnimation LAYING_DOWN_RIGHT_SHOULDER_ANIM = RawAnimation.begin().thenPlay("anim_hamster_shoulder_laying_down_right_shoulder");
    private static final RawAnimation LAYING_DOWN_LEFT_SHOULDER_ANIM = RawAnimation.begin().thenPlay("anim_hamster_shoulder_laying_down_left_shoulder");


    /* ──────────────────────────────────────────────────────────────────────────────
     *                                  2. Fields
     * ────────────────────────────────────────────────────────────────────────────*/

    // --- Unique Instance Fields ---
    @Unique public int interactionCooldown = 0;
    @Unique public int throwTicks = 0;
    @Unique public int wakingUpTicks = 0;
    @Unique private int ejectionCheckCooldown = 20;
    @Unique private int preAutoEatDelayTicks = 0;
    @Unique private int quiescentSitDurationTimer = 0;
    @Unique private int driftingOffTimer = 0;
    @Unique private int settleSleepAnimationCooldown = 0;
    @Unique private String activeCustomGoalDebugName = "None";
    @Unique public boolean isPrimedToSeekDiamonds = false;
    @Unique public long foundOreCooldownEndTick = 0L;
    @Unique public BlockPos currentOreTarget = null;
    @Unique private int celebrationParticleTicks = 0;
    @Unique private int diamondCelebrationSoundTicks = 0;
    @Unique private int sulkOrchestraHitDelayTicks = 0;
    @Unique private int sulkFailParticleTicks = 0;
    @Unique private int sulkEntityEffectTicks = 0;
    @Unique private int sulkShockedSoundDelayTicks = 0;
    @Unique private int diamondSparkleSoundDelayTicks = 0;
    @Unique public transient String particleEffectId = null;
    @Unique public transient String soundEffectId = null;
    @Unique public long stealCooldownEndTick = 0L;
    @Unique private int celebrationChaseTicks = 0;
    @Unique private boolean zoomiesIsClockwise = false;
    @Unique private double lastZoomiesAngle = 0.0;
    @Unique private int zoomiesRadiusModifier = 0;
    @Unique public transient float renderedSnowYOffset = 0.0f;
    @Unique public transient ShoulderLocation shoulderLocation = ShoulderLocation.RIGHT_SHOULDER;
    @Unique public int suffocationGracePeriod = 0;
    @Unique public transient float dynamicScaleY = 1.0f;
    @Unique private Optional<GlobalPos> linkedBedPos = Optional.empty();
    @Unique private int goToBedCooldown = 0;
    @Unique private int lureToBedTimer = 0;
    @Unique public int goToBedDelayTicks = 0;
    @Unique private int wakeUpFromBedDelay = 0;
    @Unique public int bedLeafParticleTicks = 0;
    @Unique private boolean bypassNextSleepDelay = false;
    @Unique private int napInBedDurationTimer = 0;
    @Unique private int thumpSoundDelayTicks = 0;
    @Unique private float thumpSoundVolume = 0.2f;
    @Unique public int pathingFailures = 0;
    @Nullable @Unique public BlockPos lastFailedTarget = null;
    @Unique private boolean hasPlayedIncomingSound = false;

    // --- Inventory ---
    private final DefaultedList<ItemStack> items = ImplementedInventory.create(INVENTORY_SIZE);

    // --- Animation ---
    private final AnimatableInstanceCache cache = GeckoLibUtil.createInstanceCache(this);

    // --- State Variables ---
    private int refuseTimer = 0;
    private ItemStack lastFoodItem = ItemStack.EMPTY;
    public int customLoveTimer;
    private int tamingCooldown = 0;
    public long throwCooldownEndTick = 0L;
    private long greenBeanBuffEndTick = 0L;

    // --- Auto-Eating State/Cooldown Fields ---
    private boolean isAutoEating = false; // Flag for potential animation hook
    private int autoEatProgressTicks = 0; // Ticks remaining for the current eating action
    private int autoEatCooldownTicks = 0; // Ticks remaining before it can start eating again

    public int cleaningTimer = 0;
    private int cleaningCooldownTimer = 0;



    /* ──────────────────────────────────────────────────────────────────────────────
     *                             3. Constructor
     * ────────────────────────────────────────────────────────────────────────────*/

    public HamsterEntity(EntityType<? extends TameableEntity> entityType, World world) {
        super(entityType, world);
        this.experiencePoints = 3;

        // --- Set pathfinding penalties for all relevant goals ---
        this.setPathfindingPenalty(PathNodeType.WATER, 16.0F);
        this.setPathfindingPenalty(PathNodeType.LAVA, 16.0F);
        this.setPathfindingPenalty(PathNodeType.DAMAGE_FIRE, 16.0F);
        this.setPathfindingPenalty(PathNodeType.DANGER_FIRE, 16.0F);
    }


    /* ──────────────────────────────────────────────────────────────────────────────
     *                             4. Public Methods
     * ────────────────────────────────────────────────────────────────────────────*/

    // --- Data Tracker Getters/Setters ---
    public int getVariant() { return this.dataTracker.get(VARIANT); }
    public void setVariant(int variantId) { this.dataTracker.set(VARIANT, variantId); }
    public boolean isSleeping() { return getHamsterFlag(SLEEPING_FLAG); }
    public void setSleeping(boolean sleeping) { setHamsterFlag(SLEEPING_FLAG, sleeping); }
    @Override
    public boolean isSitting() {
        return getHamsterFlag(SITTING_FLAG)
                || getHamsterFlag(SLEEPING_FLAG)
                || getHamsterFlag(KNOCKED_OUT_FLAG)
                || getHamsterFlag(SULKING_FLAG);
    }
    public boolean isCleaning() {return getHamsterFlag(CLEANING_FLAG);}
    public boolean isBegging() { return getHamsterFlag(BEGGING_FLAG); }
    public void setBegging(boolean value) { setHamsterFlag(BEGGING_FLAG, value); }
    public boolean isInLove() { return getHamsterFlag(IN_LOVE_FLAG); }
    public void setInLove(boolean value) { setHamsterFlag(IN_LOVE_FLAG, value); }
    public boolean isRefusingFood() { return getHamsterFlag(REFUSING_FOOD_FLAG); }
    public void setRefusingFood(boolean value) { setHamsterFlag(REFUSING_FOOD_FLAG, value); }
    public boolean isThrown() { return getHamsterFlag(THROWN_FLAG); }
    public void setThrown(boolean thrown) {
        setHamsterFlag(THROWN_FLAG, thrown);
        if (thrown) {
            this.hasPlayedIncomingSound = false; // Reset sound flag on new throw
        }
    }
    public boolean isLeftCheekFull() { return getHamsterFlag(LEFT_CHEEK_FULL_FLAG); }
    public void setLeftCheekFull(boolean full) { setHamsterFlag(LEFT_CHEEK_FULL_FLAG, full); }
    public boolean isRightCheekFull() { return getHamsterFlag(RIGHT_CHEEK_FULL_FLAG); }
    public void setRightCheekFull(boolean full) { setHamsterFlag(RIGHT_CHEEK_FULL_FLAG, full); }
    public boolean isKnockedOut() { return getHamsterFlag(KNOCKED_OUT_FLAG); }
    public void setKnockedOut(boolean knocked_out) { setHamsterFlag(KNOCKED_OUT_FLAG, knocked_out); }
    public String getCurrentDeepSleepAnimationIdFromTracker() {return this.dataTracker.get(CURRENT_DEEP_SLEEP_ANIM_ID);}
    public boolean isAutoEating() {return this.isAutoEating;}
    public boolean isConsideringAutoEat() {return getHamsterFlag(CONSIDERING_AUTO_EAT_FLAG);}
    public DozingPhase getDozingPhase() {return DozingPhase.values()[this.dataTracker.get(DOZING_PHASE)];}
    public void setDozingPhase(DozingPhase phase) {this.dataTracker.set(DOZING_PHASE, phase.ordinal());}
    public void setActiveCustomGoalDebugName(String name) {this.dataTracker.set(ACTIVE_CUSTOM_GOAL_NAME_DEBUG, name);}
    public String getActiveCustomGoalDebugName() {String goalName = this.dataTracker.get(ACTIVE_CUSTOM_GOAL_NAME_DEBUG);return goalName;}
    public boolean isSulking() {return getHamsterFlag(SULKING_FLAG);}
    public boolean isCelebratingDiamond() {return getHamsterFlag(CELEBRATING_DIAMOND_FLAG);}
    public void setCelebratingDiamond(boolean celebrating) {
        setHamsterFlag(CELEBRATING_DIAMOND_FLAG, celebrating);
        if (celebrating) {
            this.setBegging(false); // Ensure not also in normal begging state
            if (!this.getWorld().isClient()) { // Only initialize timer on server
                this.celebrationParticleTicks = HamsterEntity.CELEBRATION_PARTICLE_DURATION_TICKS;
                this.diamondSparkleSoundDelayTicks = 10; // 10-tick delay for sparkle sound
            }
        } else {
            // If stopping celebration, ensure all associated timers are also stopped/reset
            this.celebrationParticleTicks = 0;
            this.diamondSparkleSoundDelayTicks = 0;
            this.diamondCelebrationSoundTicks = 0;
        }
    }
    public void setSulking(boolean sulking) {
        setHamsterFlag(SULKING_FLAG, sulking);
        if (sulking) {
            if (!this.getWorld().isClient()) {
                this.sulkOrchestraHitDelayTicks = 10; // 10-tick delay for orchestra hit
                this.sulkShockedSoundDelayTicks = 44; // 2.2 seconds * 20 ticks/second = 44 ticks
                this.sulkFailParticleTicks = 600;     // Duration for fail particles
                this.sulkEntityEffectTicks = 600;     // Duration for entity effect particles
            }
        } else {
            // If stopping sulking, ensure all associated timers are also stopped/reset
            this.sulkOrchestraHitDelayTicks = 0;
            this.sulkFailParticleTicks = 0;
            this.sulkEntityEffectTicks = 0;
        }
    }
    public boolean isStealingDiamond() {return getHamsterFlag(STEALING_DIAMOND_FLAG);}
    public void setStealingDiamond(boolean stealing) {setHamsterFlag(STEALING_DIAMOND_FLAG, stealing);}
    public int getStealDurationTimer() {return this.dataTracker.get(STEAL_DURATION_TIMER);}
    public void setStealDurationTimer(int ticks) {this.dataTracker.set(STEAL_DURATION_TIMER, ticks);}
    public boolean isTaunting() {return getHamsterFlag(TAUNTING_FLAG);}
    public void setTaunting(boolean taunting) {setHamsterFlag(TAUNTING_FLAG, taunting);}
    public ItemStack getStolenItemStack() { return this.dataTracker.get(STOLEN_ITEM_STACK); }
    public void setStolenItemStack(ItemStack stack) { this.dataTracker.set(STOLEN_ITEM_STACK, stack); }
    public boolean isCelebratingChase() { return getHamsterFlag(CELEBRATING_CHASE_FLAG); }
    public void setCelebratingChase(boolean celebrating) { setHamsterFlag(CELEBRATING_CHASE_FLAG, celebrating); }
    public boolean hasGreenBeanBuff() {return this.getDataTracker().get(GREEN_BEAN_BUFF_DURATION) > this.getWorld().getTime();}
    public boolean getZoomiesIsClockwise() { return this.zoomiesIsClockwise; }
    public double getLastZoomiesAngle() { return this.lastZoomiesAngle; }
    public void setLastZoomiesAngle(double angle) { this.lastZoomiesAngle = angle; }
    public int getZoomiesRadiusModifier() { return this.zoomiesRadiusModifier; }
    public boolean isShoulderPet() { return getHamsterFlag(IS_SHOULDER_PET_FLAG); }
    public void setShoulderPet(boolean isShoulderPet) { setHamsterFlag(IS_SHOULDER_PET_FLAG, isShoulderPet); }
    public boolean isWanderModeActive() { return getHamsterFlag(IS_WANDER_MODE_ACTIVE_FLAG); }
    public void setWanderModeActive(boolean active) { setHamsterFlag(IS_WANDER_MODE_ACTIVE_FLAG, active); }
    public Optional<GlobalPos> getLinkedBedPos() { return this.linkedBedPos; }
    public void setLinkedBedPos(Optional<GlobalPos> pos) { this.linkedBedPos = pos; }
    public int getGoToBedCooldown() { return this.goToBedCooldown; }
    public void wakeUpFromBed(boolean isManualWakeUp) {
        // Wakes the hamster up from its bed, setting the bed block to unoccupied
        // and applying a cooldown to prevent it from immediately going back to sleep.
        if (!this.isSleeping()) return;

        // Trigger animation and sound
        triggerWakeUpFromSleepAnimation(isManualWakeUp); // Pass in the context

        this.setSleeping(false);
        this.setInSittingPose(false); // Explicitly re-enable AI movement
        // Apply a configurable cooldown if woken up by player interaction,
        // preventing the hamster from immediately getting back in bed.
        if (isManualWakeUp) {
            this.goToBedCooldown = Configs.AHP.bedWakeUpCooldown.get();
            this.setBypassNextSleepDelay(true);
        }

        // Set bed block to unoccupied and find a safe spot to move to
        this.getLinkedBedPos().ifPresent(globalPos -> {
            if (this.getWorld().getRegistryKey() == globalPos.getDimension()) {
                BlockPos bedPos = globalPos.getPos();
                BlockState bedState = this.getWorld().getBlockState(bedPos);

                // Spawn Wake-Up Particles with wood type
                if (!this.getWorld().isClient()) {
                    ((ServerWorld)this.getWorld()).spawnParticles(ModParticles.getForVariant(bedState.get(HamsterBedBlock.WOOD_VARIANT)),
                            bedPos.getX() + 0.5, bedPos.getY() + 0.3, bedPos.getZ() + 0.5,
                            50, 0.2, 0.5, 0.2, 0.0);
                }

                // Play Leaf Rustling Sound
                SoundEvent rustleSound = ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_BED_LEAVES_RUSTLE_SOUNDS, this.random);
                if (rustleSound != null) {
                    this.getWorld().playSound(null, this.getBlockPos(), rustleSound, SoundCategory.NEUTRAL, 0.2f, 1.8f);
                }

                if (bedState.isOf(ModBlocks.HAMSTER_BED.get()) && bedState.get(HamsterBedBlock.OCCUPIED)) {
                    this.getWorld().setBlockState(bedPos, bedState.with(HamsterBedBlock.OCCUPIED, false), Block.NOTIFY_ALL);
                }

                // Trigger bed animation
                BlockEntity be = this.getWorld().getBlockEntity(bedPos);
                if (be instanceof GeoBlockEntity geoBlockEntity) {
                    geoBlockEntity.triggerAnim("hamster_bed_controller", "anim_bed_becoming_unoccupied");
                }

                // Find Safe Egress Position and Pathfind
                for (BlockPos checkPos : BlockPos.iterate(bedPos.add(-1, 0, -1), bedPos.add(1, 0, 1))) {
                    // Don't move to the bed block itself
                    if (checkPos.equals(bedPos)) continue;

                    if (isSafeSpawnLocation(checkPos, this.getWorld())) {
                        this.getNavigation().startMovingTo(checkPos.getX() + 0.5, checkPos.getY(), checkPos.getZ() + 0.5, 1.2D);
                        return; // Exit after finding the first safe spot
                    }
                }
            }
        });
    }
    public int getGoToBedDelayTicks() { return this.goToBedDelayTicks; }
    public void setGoToBedDelayTicks(int ticks) { this.goToBedDelayTicks = ticks; }
    public int getLureToBedTimer() { return this.lureToBedTimer; }
    public void setLureToBedTimer(int ticks) { this.lureToBedTimer = ticks; }
    public void lureToBed() { this.lureToBedTimer = 20; }
    public boolean isOnTheWayToBed() { return getHamsterFlag(ON_THE_WAY_TO_BED_FLAG); }
    public void setOnTheWayToBed(boolean onTheWay) { setHamsterFlag(ON_THE_WAY_TO_BED_FLAG, onTheWay); }
    public boolean shouldBypassNextSleepDelay() { return this.bypassNextSleepDelay; }
    public void setBypassNextSleepDelay(boolean bypass) { this.bypassNextSleepDelay = bypass; }
    public void startNapTimer() {
        // Starts the nap timer for the Circadian Chaos feature.
        // This is called by the AI goal when the hamster successfully enters its bed.
        if (Configs.AHP.circadianChaos.get()) {
            int min = Configs.AHP.minNapInBedIntervalSeconds.get() * 20;
            int max = Configs.AHP.maxNapInBedIntervalSeconds.get() * 20;
            this.napInBedDurationTimer = this.random.nextBetween(min, max);
        }
    }
    public void triggerSettleEffects(float swishVolume, int thumpDelay, float thumpVolume) {
        // Triggers a two-part settle sound effect ("swish" then "thump") with dynamic volumes.
        if (!this.getWorld().isClient()) {
            this.getWorld().playSound(null, this.getBlockPos(), ModSounds.HAMSTER_SWISH.get(), SoundCategory.NEUTRAL, swishVolume, 1.0f + this.random.nextFloat() * 0.5f);
        }
        this.thumpSoundDelayTicks = thumpDelay;
        this.thumpSoundVolume = thumpVolume;
    }
    public void triggerWakeUpFromSleepAnimation(boolean isManualWakeUp) {
        // Triggers the appropriate wake-up animation and sound based on the last used sleep pose.
        // This is the centralized method for all "wake from sleep" scenarios.
        if (this.getWorld().isClient()) return;

        String currentSleepAnim = this.getDataTracker().get(CURRENT_DEEP_SLEEP_ANIM_ID);
        String animToTrigger;

        switch (currentSleepAnim) {
            case "anim_hamster_sleep_pose2" -> animToTrigger = "wakeup2";
            case "anim_hamster_sleep_pose3" -> animToTrigger = "wakeup3";
            default -> animToTrigger = "wakeup1";
        }

        this.triggerAnimOnServer("mainController", animToTrigger);

        // --- Conditional Sound Logic ---
        // Swish sound plays for both manual and natural wake-ups.
        this.getWorld().playSound(null, this.getBlockPos(), ModSounds.HAMSTER_SWISH.get(), SoundCategory.NEUTRAL, 0.1f, 1.0f + this.random.nextFloat() * 0.5f);

        if (isManualWakeUp) {
            // Affection sound only for player-initiated manual wake-ups.
            SoundEvent affectionSound = getRandomSoundFrom(ModSounds.HAMSTER_AFFECTION_SOUNDS, this.random);
            if (affectionSound != null) {
                this.getWorld().playSound(null, this.getBlockPos(), affectionSound, SoundCategory.NEUTRAL, 1.0F, 1.0F);
            }
        }
    }
    public boolean isPathThroughUnlinkedBed(@Nullable Path path) {
        // Checks if a given path traverses an unlinked Hamster Bed.
        // This allows AI goals to validate a path before committing the hamster to follow it.
        if (path == null) return false;

        // Get the position of this hamster's linked bed, if it has one.
        BlockPos linkedBed = this.getLinkedBedPos()
                .map(GlobalPos::getPos)
                .orElse(null);

        for (int i = 0; i < path.getLength(); ++i) {
            PathNode node = path.getNode(i);
            // Use direct method to get the BlockPos from the node.
            BlockPos pos = node.getBlockPos();
            if (isUnlinkedBed(pos, linkedBed) || isUnlinkedBed(pos.down(), linkedBed)) {
                AdorableHamsterPets.LOGGER.trace(
                        "[AHP Nav Debug] Path intersects unlinked bed at {}, linkedBed={} for hamster {}",
                        pos, linkedBed, this.getUuid()
                );
                return true;
            }
        }
        return false;
    }
    public boolean isUnlinkedBed(BlockPos pos, BlockPos linkedBed) {
        if (this.getWorld().getBlockState(pos).getBlock() instanceof HamsterBedBlock) {
            // If the node is a bed, check if it's NOT our linked bed.
            // This is true if we have no linked bed, or if the position doesn't match.
            return linkedBed == null || !pos.equals(linkedBed);
        }
        return false; // Path is valid.
    }
    public void updateNavigation() {
        // Dynamically swaps the navigation component based on the current config setting.
        // This ensures that changes to the 'avoidUnlinkedBeds' config are applied to
        // existing hamsters without requiring a world reload.
        if (this.getWorld().isClient()) return;

        boolean useCustomNav = Configs.AHP.avoidUnlinkedBeds;
        boolean isCurrentlyCustom = this.navigation instanceof HamsterNavigation;

        // Only swap if the current navigation type is incorrect
        if (useCustomNav && !isCurrentlyCustom) {
            this.navigation = createNavigation(this.getWorld());
        } else if (!useCustomNav && isCurrentlyCustom) {
            this.navigation = createNavigation(this.getWorld());
        }
    }
    @SuppressWarnings("UnusedReturnValue")
    public boolean tryShoulderMount(PlayerEntity player, ItemStack stack) {
        // Attempts to mount the hamster to the player's shoulder. True if successful.
        PlayerEntityAccessor playerAccessor = (PlayerEntityAccessor) player;

        // Find First Available Slot
        ShoulderLocation availableSlot = null;
        if (playerAccessor.getShoulderHamster(ShoulderLocation.RIGHT_SHOULDER).isEmpty()) {
            availableSlot = ShoulderLocation.RIGHT_SHOULDER;
        } else if (playerAccessor.getShoulderHamster(ShoulderLocation.LEFT_SHOULDER).isEmpty()) {
            availableSlot = ShoulderLocation.LEFT_SHOULDER;
        } else if (playerAccessor.getShoulderHamster(ShoulderLocation.HEAD).isEmpty()) {
            availableSlot = ShoulderLocation.HEAD;
        }

        if (availableSlot != null) {
            // Disable Wander Mode Before Saving
            this.setWanderModeActive(false);

            // Save, Set, and Update Queue
            HamsterShoulderData data = this.saveToShoulderData();
            playerAccessor.setShoulderHamster(availableSlot, data.toNbt());
            playerAccessor.adorablehamsterpets$getMountOrderQueue().addLast(availableSlot);

            BlockPos hamsterPosForMountSound = this.getBlockPos();
            this.discard(); // Remove hamster from world

            // Trigger Generic Events and Play Mount Sound
            if (player instanceof ServerPlayerEntity serverPlayer) {
                ModCriteria.HAMSTER_ON_SHOULDER.trigger(serverPlayer);
            }
            player.sendMessage(Text.translatable("message.adorablehamsterpets.shoulder_mount_success"), true);

            SoundEvent mountSound = ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_SHOULDER_MOUNT_SOUNDS, this.random);
            if (mountSound != null) {
                this.getWorld().playSound(null, player.getBlockPos(), mountSound, SoundCategory.PLAYERS, 1.0f, this.getSoundPitch());
            }

            // Item-Specific Effects and Consumption (if stack is valid lure)
            if (ConfigDataCache.isLureItem(stack)) {
                SoundEvent mountLureSound = ModSounds.getDynamicItemSound(stack);
                this.getWorld().playSound(null, hamsterPosForMountSound, mountLureSound, SoundCategory.PLAYERS, 1.0f, 1.0f);

                // Use stack.copy() to prevent "Failed to encode packet" crashes if decrement empties the stack
                ((ServerWorld)this.getWorld()).spawnParticles(new ItemStackParticleEffect(ParticleTypes.ITEM, stack.copy()),
                        hamsterPosForMountSound.getX() + 0.5, hamsterPosForMountSound.getY() + 0.5, hamsterPosForMountSound.getZ() + 0.5,
                        8, 0.25D, 0.25D, 0.25D, 0.05);

                if (!player.getAbilities().creativeMode && Configs.AHP.consumeLureItem) {
                    stack.decrement(1);
                }
            }
            return true;
        } else {
            player.sendMessage(Text.translatable("message.adorablehamsterpets.shoulder_occupied"), true);
            return false;
        }
    }
    @Override
    public boolean damage(DamageSource source, float amount) {
        // If the damage is suffocation AND the grace period is active, cancel the damage.
        if (source.isOf(DamageTypes.IN_WALL) && this.suffocationGracePeriod > 0) {
            return false; // Cancel suffocation damage
        }
        return super.damage(source, amount);
    }
    @Override
    public boolean canMoveVoluntarily() {
        return super.canMoveVoluntarily() && !this.isThrown();
    }
    @Override
    public boolean isPushable() {
        // A hamster is not pushable if it's being thrown OR if it's sleeping in a bed.
        if (this.isThrown() || (this.isSleeping() && this.getLinkedBedPos().isPresent())) {
            return false;
        }
        return super.isPushable();
    }

    // --- Inventory Implementation ---
    @Override
    public DefaultedList<ItemStack> getItems() {
        return this.items;
    }

    @Override
    public void markDirty() {
        if (!this.getWorld().isClient()) {
            this.updateCheekTrackers();
        }
    }

    /**
     * Gets the display name for the hamster.
     * This will be the hamster's custom name if it has one, otherwise it defaults
     * to a translatable title.
     *
     * @return The {@link Text} component to be used as the screen's title.
     */
    @Override
    public Text getDisplayName() {
        // If the entity has a custom name from a name tag, always use that.
        if (this.hasCustomName()) {
            return super.getDisplayName();
        }

        // If no custom name, check the config for the default name.
        if (Configs.AHP.useHampterName) {
            return Text.translatable("entity.adorablehamsterpets.hampter");
        }

        // Otherwise, use the default vanilla behavior, which will resolve to "entity.adorablehamsterpets.hamster".
        return super.getDisplayName();
    }


    // --- Override isValid for Hopper Interaction ---
    @Override
    public boolean isValid(int slot, ItemStack stack) {
        // --- 1. Check if the item is allowed based on the disallowed logic ---
        // Ensure the slot index is valid for the hamster inventory (0-5)
        if (slot < 0 || slot >= INVENTORY_SIZE) {
            return false;
        }
        // Use the helper method to determine if the item is allowed
        return !this.isItemDisallowed(stack);
    }

    /**
     * Updates the DataTrackers for cheek fullness based on the inventory content.
     * Also triggers the "Chipmunk Aspirations" advancement if all pouch slots become full.
     */
    public void updateCheekTrackers() {
        // --- Update Left Cheek ---
        boolean leftFull = false;
        for (int i = 0; i < 3; i++) {
            if (!this.items.get(i).isEmpty()) {
                leftFull = true;
                break;
            }
        }

        // --- Update Right Cheek ---
        boolean rightFull = false;
        for (int i = 3; i < INVENTORY_SIZE; i++) {
            if (!this.items.get(i).isEmpty()) {
                rightFull = true;
                break;
            }
        }

        // --- Set Data Trackers ---
        if (this.isLeftCheekFull() != leftFull) this.setLeftCheekFull(leftFull);
        if (this.isRightCheekFull() != rightFull) this.setRightCheekFull(rightFull);

        // --- Trigger "Chipmunk Aspirations" Advancement ---
        if (!this.getWorld().isClient() && this.getOwner() instanceof ServerPlayerEntity serverPlayerOwner) {
            boolean allSlotsFilled = true;
            for (int i = 0; i < INVENTORY_SIZE; i++) {
                if (this.items.get(i).isEmpty()) {
                    allSlotsFilled = false;
                    break;
                }
            }
            if (allSlotsFilled) {
                ModCriteria.HAMSTER_POUCH_FILLED.trigger(serverPlayerOwner, this);
            }
        }
    }

    // --- NBT Saving/Loading ---
    @Override
    public void writeCustomDataToNbt(NbtCompound nbt) {
        // --- 1. Write Core Data & Flags ---
        super.writeCustomDataToNbt(nbt);
        nbt.putInt("HamsterVariant", this.getVariant());

        // For backward compatibility, write the flags out as individual booleans.
        if (this.isTamed()) {
            nbt.putBoolean("Sitting", getHamsterFlag(SITTING_FLAG));
        }
        nbt.putBoolean("KnockedOut", getHamsterFlag(KNOCKED_OUT_FLAG));
        nbt.putBoolean("CheekPouchUnlocked", getHamsterFlag(CHEEK_POUCH_UNLOCKED_FLAG));

        nbt.putLong("ThrowCooldownEnd", this.throwCooldownEndTick);
        nbt.putLong("GreenBeanBuffDuration", this.getDataTracker().get(GREEN_BEAN_BUFF_DURATION));
        nbt.putInt("AutoEatCooldown", this.autoEatCooldownTicks);
        nbt.putInt("EjectionCheckCooldown", this.ejectionCheckCooldown);
        nbt.putInt("PinkPetalType", this.dataTracker.get(PINK_PETAL_TYPE));
        nbt.putInt("AnimationPersonalityId", this.dataTracker.get(ANIMATION_PERSONALITY_ID));

        // --- 2. Write Sleep State Data ---
        nbt.putInt("DozingPhase", this.getDozingPhase().ordinal());
        nbt.putString("CurrentDeepSleepAnimId", this.dataTracker.get(CURRENT_DEEP_SLEEP_ANIM_ID));
        nbt.putInt("QuiescentSitTimer", this.quiescentSitDurationTimer);
        nbt.putInt("DriftingOffTimer", this.driftingOffTimer);
        nbt.putInt("SettleSleepCooldown", this.settleSleepAnimationCooldown);

        // --- 3. Write Inventory ---
        NbtCompound inventoryWrapperNbt = new NbtCompound();
        Inventories.writeNbt(inventoryWrapperNbt, this.items);
        nbt.put("Inventory", inventoryWrapperNbt);

        // --- 4. Write Seeking and Sulking Data ---
        nbt.putBoolean("IsPrimedToSeekDiamonds", this.isPrimedToSeekDiamonds);
        nbt.putLong("FoundOreCooldownEndTick", this.foundOreCooldownEndTick);
        if (this.currentOreTarget != null) {
            nbt.putInt("OreTargetX", this.currentOreTarget.getX());
            nbt.putInt("OreTargetY", this.currentOreTarget.getY());
            nbt.putInt("OreTargetZ", this.currentOreTarget.getZ());
        }
        nbt.putBoolean("IsSulking", getHamsterFlag(SULKING_FLAG));
        nbt.putBoolean("IsCelebratingDiamond", getHamsterFlag(CELEBRATING_DIAMOND_FLAG));

        // --- 5. Write Diamond Stealing Data ---
        if (this.isStealingDiamond()) {
            nbt.putBoolean("IsStealingDiamond", true);
            nbt.putInt("StealDurationTimer", this.getStealDurationTimer());
            // Save the stolen item stack using the 1.20.1 method
            if (!this.getStolenItemStack().isEmpty()) {
                nbt.put("StolenItemStack", this.getStolenItemStack().writeNbt(new NbtCompound()));
            }
        }

        // --- 6. Write Wander Mode Data if Relevant ---
        nbt.putBoolean("IsWanderModeActive", this.isWanderModeActive());
        this.linkedBedPos.ifPresent(globalPos -> {
            // In 1.20.1, use RegistryOps.of() and handle getOrThrow arguments
            DataResult<NbtElement> result = GlobalPos.CODEC.encodeStart(RegistryOps.of(NbtOps.INSTANCE, this.getWorld().getRegistryManager()), globalPos);
            result.result().ifPresent(tag -> nbt.put("LinkedBedPos", tag));
        });
        nbt.putBoolean("BypassNextSleepDelay", this.bypassNextSleepDelay);

        // --- 7. Write Flight Data ---
        nbt.putBoolean("HasPlayedIncomingSound", this.hasPlayedIncomingSound);

    }

    @Override
    public void readCustomDataFromNbt(NbtCompound nbt) {
        // --- 1. Read Core Data ---
        super.readCustomDataFromNbt(nbt);
        this.setVariant(nbt.getInt("HamsterVariant"));

        // --- Read individual booleans and set flags for backward compatibility ---
        boolean wasSittingNbt = this.isTamed() && nbt.getBoolean("Sitting");
        this.setSitting(wasSittingNbt, true); // This will correctly set the SITTING_FLAG
        setHamsterFlag(KNOCKED_OUT_FLAG, nbt.getBoolean("KnockedOut"));
        setHamsterFlag(CHEEK_POUCH_UNLOCKED_FLAG, nbt.getBoolean("CheekPouchUnlocked"));
        setHamsterFlag(SULKING_FLAG, nbt.getBoolean("IsSulking"));
        setHamsterFlag(CELEBRATING_DIAMOND_FLAG, nbt.getBoolean("IsCelebratingDiamond"));

        this.throwCooldownEndTick = nbt.getLong("ThrowCooldownEnd");
        this.getDataTracker().set(GREEN_BEAN_BUFF_DURATION, nbt.getLong("GreenBeanBuffDuration"));
        this.autoEatCooldownTicks = nbt.getInt("AutoEatCooldown");
        this.ejectionCheckCooldown = nbt.contains("EjectionCheckCooldown", NbtElement.INT_TYPE) ? nbt.getInt("EjectionCheckCooldown") : 20;
        this.dataTracker.set(PINK_PETAL_TYPE, nbt.getInt("PinkPetalType"));

        // If the NBT from a command or save file doesn't specify an ID, assign one.
        // This covers /summon and ensures the ID persists through saves.
        if (!nbt.contains("AnimationPersonalityId", NbtElement.INT_TYPE)) {
            int personalityId = this.random.nextBetween(1, 3);
            this.dataTracker.set(ANIMATION_PERSONALITY_ID, personalityId);
            AdorableHamsterPets.LOGGER.debug("[NBT READ] Hamster ID {}: NBT had no personality, assigned new ID {}", this.getId(), personalityId);
        } else {
            // If it does contain one (e.g., from a saved world), read it normally.
            this.dataTracker.set(ANIMATION_PERSONALITY_ID, nbt.getInt("AnimationPersonalityId"));
        }

        // --- 2. Read Sleep State Data ---
        if (nbt.contains("DozingPhase", NbtElement.INT_TYPE)) {
            int phaseOrdinal = nbt.getInt("DozingPhase");
            if (phaseOrdinal >= 0 && phaseOrdinal < DozingPhase.values().length) {
                this.setDozingPhase(DozingPhase.values()[phaseOrdinal]);
            } else {
                this.setDozingPhase(DozingPhase.NONE);
            }
        } else {
            this.setDozingPhase(DozingPhase.NONE);
        }
        this.dataTracker.set(CURRENT_DEEP_SLEEP_ANIM_ID, nbt.getString("CurrentDeepSleepAnimId"));
        this.quiescentSitDurationTimer = nbt.getInt("QuiescentSitTimer");
        this.driftingOffTimer = nbt.getInt("DriftingOffTimer");
        this.settleSleepAnimationCooldown = nbt.getInt("SettleSleepCooldown");

        // --- 3. Read Inventory ---
        this.items.clear();
        if (nbt.contains("Inventory", NbtElement.COMPOUND_TYPE)) {
            Inventories.readNbt(nbt.getCompound("Inventory"), this.items);
        }
        this.updateCheekTrackers();

        // --- 4. Read Seeking Data ---
        this.isPrimedToSeekDiamonds = nbt.getBoolean("IsPrimedToSeekDiamonds");
        this.foundOreCooldownEndTick = nbt.getLong("FoundOreCooldownEndTick");
        if (nbt.contains("OreTargetX") && nbt.contains("OreTargetY") && nbt.contains("OreTargetZ")) {
            this.currentOreTarget = new BlockPos(nbt.getInt("OreTargetX"), nbt.getInt("OreTargetY"), nbt.getInt("OreTargetZ"));
        } else {
            this.currentOreTarget = null;
        }

        // --- 5. Read Diamond Stealing Data ---
        this.setStealingDiamond(nbt.getBoolean("IsStealingDiamond"));
        if (this.isStealingDiamond()) {
            this.setStealDurationTimer(nbt.getInt("StealDurationTimer"));
            if (nbt.contains("StolenItemStack", NbtElement.COMPOUND_TYPE)) {
                // Use the 1.20.1 method to read the ItemStack from NBT
                this.setStolenItemStack(ItemStack.fromNbt(nbt.getCompound("StolenItemStack")));
            }
        } else {
            this.setStealDurationTimer(0);
            this.setStolenItemStack(ItemStack.EMPTY);
        }

        // --- 6. Read Wander Mode Data if Relevant ---
        setWanderModeActive(nbt.getBoolean("IsWanderModeActive"));
        if (nbt.contains("LinkedBedPos")) {
            // In 1.20.1, use RegistryOps.of() and handle getOrThrow arguments
            this.linkedBedPos = GlobalPos.CODEC.parse(RegistryOps.of(NbtOps.INSTANCE, this.getWorld().getRegistryManager()), nbt.get("LinkedBedPos")).result();
        } else {
            this.linkedBedPos = Optional.empty();
        }
        this.bypassNextSleepDelay = nbt.getBoolean("BypassNextSleepDelay");

        // --- 7. Read Flight Data ---
        this.hasPlayedIncomingSound = nbt.getBoolean("HasPlayedIncomingSound");
    }


    // --- Shoulder Riding Data Handling ---
    /**
     * Captures the current state of this hamster into a {@link HamsterShoulderData} record.
     * This record can then be serialized to NBT and stored on the player's DataTracker.
     *
     * @return A {@link HamsterShoulderData} record containing the hamster's current data.
     */
    public HamsterShoulderData saveToShoulderData() {
        // --- 1. Update Trackers and Prepare NBT ---
        this.updateCheekTrackers();
        NbtCompound inventoryNbt = new NbtCompound();
        // In 1.20.1, writeNbt does not take a registry manager.
        Inventories.writeNbt(inventoryNbt, this.items);

        // --- 2. Save Active Status Effects ---
        // In 1.20.1, the active_effects are stored directly in the NbtList, not a wrapper compound.
        NbtList effectsList = new NbtList();
        for (StatusEffectInstance effectInstance : this.getStatusEffects()) {
            effectsList.add(effectInstance.writeNbt(new NbtCompound()));
        }

        // --- 3. Get Custom Name ---
        Optional<String> nameOptional = Optional.ofNullable(this.getCustomName()).map(Text::getString);

        // --- 4. Create Inner Data Record Instances ---
        HamsterShoulderData.SeekingBehaviorData seekingData = new HamsterShoulderData.SeekingBehaviorData(
                this.isPrimedToSeekDiamonds,
                this.foundOreCooldownEndTick,
                Optional.ofNullable(this.currentOreTarget)
        );
        HamsterShoulderData.GreenBeanBuffData buffData = new HamsterShoulderData.GreenBeanBuffData(
                this.greenBeanBuffEndTick,
                this.getDataTracker().get(GREEN_BEAN_BUFF_DURATION),
                effectsList
        );
        HamsterShoulderData.WanderModeData wanderData = new HamsterShoulderData.WanderModeData(
                this.linkedBedPos,
                this.bypassNextSleepDelay
        );

        // --- 5. Create and Return the Main Data Record ---
        return new HamsterShoulderData(
                this.getUuid(),
                this.getVariant(),
                this.getHealth(),
                inventoryNbt,
                this.getBreedingAge(),
                this.throwCooldownEndTick,
                buffData,
                this.autoEatCooldownTicks,
                nameOptional,
                this.dataTracker.get(PINK_PETAL_TYPE),
                this.dataTracker.get(ANIMATION_PERSONALITY_ID),
                seekingData,
                wanderData,
                this.dataTracker.get(HAMSTER_FLAGS) // Pass the entire packed integer
        );
    }

    // --- Entity Behavior ---
    @Override
    public boolean handleFallDamage(float fallDistance, float damageMultiplier, DamageSource damageSource) { return false; }

    @Override
    public void changeLookDirection(double cursorX, double cursorY) {
        if (this.isSleeping()) return;
        super.changeLookDirection(cursorX, cursorY);
    }

    /**
     * Finds a safe spawn position for the hamster near an initial target position.
     * The search is performed in stages for efficiency and logical placement:
     * 1. Checks the initial target position itself.
     * 2. Checks a few blocks directly above the target.
     * 3. Performs a horizontal spiral search outwards on the same Y-level.
     *
     * @param initialTarget The desired starting point for the search.
     * @param world         The world where the search is performed.
     * @param searchRadius  The maximum horizontal radius for the spiral search.
     * @return An Optional containing the first safe BlockPos found, or an empty Optional if no safe spot is found within the search radius.
     */
    public Optional<BlockPos> findSafeSpawnPosition(BlockPos initialTarget, World world, int searchRadius) {
        return findSafeSpawnPosition(initialTarget, world, searchRadius, Collections.emptySet());
    }

    /**
     * Finds a safe, unoccupied spawn position for the hamster near an initial target position,
     * avoiding any positions present in the provided occupied set.
     *
     * @param initialTarget The desired starting point for the search.
     * @param world         The world where the search is performed.
     * @param searchRadius  The maximum horizontal radius for the spiral search.
     * @param occupiedPositions A set of positions that are already taken and should be avoided.
     * @return An Optional containing the first safe and unoccupied BlockPos found, or an empty Optional.
     */
    public Optional<BlockPos> findSafeSpawnPosition(BlockPos initialTarget, World world, int searchRadius, Set<BlockPos> occupiedPositions) {
        // --- Stage 1: Initial Target Check ---
        if (isSafeSpawnLocation(initialTarget, world) && !occupiedPositions.contains(initialTarget)) {
            return Optional.of(initialTarget);
        }

        // --- Stage 2: Vertical Vicinity Check (Upwards) ---
        for (int i = 1; i <= 3; i++) {
            BlockPos abovePos = initialTarget.up(i);
            if (isSafeSpawnLocation(abovePos, world) && !occupiedPositions.contains(abovePos)) {
                return Optional.of(abovePos);
            }
        }

        // --- Stage 3: Horizontal Spiral Search ---
        for (int r = 1; r <= searchRadius; r++) {
            for (int i = -r; i <= r; i++) {
                for (int j = -r; j <= r; j++) {
                    // Only check the "ring" of the spiral, not the inside which was already checked
                    if (Math.abs(i) != r && Math.abs(j) != r) {
                        continue;
                    }
                    BlockPos checkPos = initialTarget.add(i, 0, j);
                    if (isSafeSpawnLocation(checkPos, world) && !occupiedPositions.contains(checkPos)) {
                        return Optional.of(checkPos);
                    }
                }
            }
        }

        // --- Stage 4: Failure ---
        return Optional.empty();
    }

    /**
     * Overrides the vanilla {@link TameableEntity#setSitting(boolean)} method.
     * <p>
     * This method acts as an interceptor for any vanilla or external mod logic that
     * attempts to change the sitting state (e.g., the vanilla {@code SitGoal}). It redirects
     * the call to the custom overloaded {@link #setSitting(boolean, boolean)} method,
     * ensuring that all mod-specific logic (like sleep sequence resets and animation state)
     * is correctly handled.
     *
     * @param sitting {@code true} to make the hamster sit, {@code false} to make it stand.
     */
    @Override
    public void setSitting(boolean sitting) {
        // Calls the overload below. We want player-initiated sits to NOT play the sleep sound.
        // So, suppressSound should always be true when called from here.
        this.setSitting(sitting, true); // Always suppress sound for this basic toggle
    }

    // --- Overload for setSitting (ONLY controls IS_SITTING) ---
    /**
     * Sets the player-commanded sitting state of the hamster.
     * This method updates the {@code IS_SITTING} DataTracker and the vanilla sitting pose.
     * If the hamster is being told to stand up while it was in a dozing/sleep sequence,
     * the sleep sequence will be reset.
     *
     * @param sitting True to make the hamster sit, false to make it stand.
     * @param suppressSound True to suppress any sound normally associated with this action (parameter exists for API compatibility, not actively used for sound suppression within this method currently).
     */
    public void setSitting(boolean sitting, boolean suppressSound) {
        // --- 1. Play sound and trigger animation based on state change ---
        boolean wasSitting = this.isSitting();
        if (sitting && !wasSitting) { // Transitioning to sitting
            int personalityId = this.dataTracker.get(ANIMATION_PERSONALITY_ID);
            String animToTrigger = switch (personalityId) {
                case 2 -> "sit2";
                case 3 -> "sit3";
                default -> "sit1";
            };
            this.triggerAnimOnServer("mainController", animToTrigger);
            triggerSettleEffects(0.12f, 7, 0.2f); // Swish now, thump in 7 ticks when hamster lands
        } else if (!sitting && wasSitting) { // Transitioning from sitting
            if (!this.getWorld().isClient()) {
                this.getWorld().playSound(null, this.getBlockPos(), ModSounds.HAMSTER_SWISH.get(), SoundCategory.NEUTRAL, 0.1f, 1.0f + this.random.nextFloat() * 0.5f);
            }
            int personalityId = this.dataTracker.get(ANIMATION_PERSONALITY_ID);
            String animToTrigger = switch (personalityId) {
                case 2 -> "standup2";
                case 3 -> "standup3";
                default -> "standup1";
            };
            this.triggerAnimOnServer("mainController", animToTrigger);
        }

        // --- 2. Reset Sleep Sequence if Standing Up from a Doze/Sleep ---
        if (!sitting && this.isTamed() && this.getDozingPhase() != DozingPhase.NONE) {
            resetSleepSequence("Player commanded hamster to stand up.");
        }

        // --- 3. Update Core Sitting State ---
        setHamsterFlag(SITTING_FLAG, sitting);

        // --- 4. Update Vanilla State ---
        this.setInSittingPose(sitting);

        // --- 5. Manage Cleaning Timers and Quiescent Sit Timer on State Change ---
        if (sitting) {
            // When commanded to sit, ensure the cleaning timer is reset.
            this.cleaningTimer = 0;
            // quiescentSitDurationTimer will be set by the tick method when DozingPhase becomes QUIESCENT_SITTING.
        } else {
            // If standing up, reset the quiescent sit timer to prevent immediate re-entry into sleep sequence.
            this.quiescentSitDurationTimer = 0;
            // Also ensure cleaning stops if it was active.
            this.cleaningTimer = 0;
            // Explicitly set the cleaning state to false.
            if (getHamsterFlag(CLEANING_FLAG)) {
                setHamsterFlag(CLEANING_FLAG, false);
            }
        }
    }

    // --- Override isInAttackRange ---
    /**
     * Checks if the target entity is within the hamster's shorter melee attack range.
     * Overrides the default MobEntity check which uses a larger expansion.
     * @param entity The entity to check range against.
     * @return True if the entity is within the custom attack range, false otherwise.
     */
    @Override
    public boolean isInAttackRange(LivingEntity entity) {
        // --- Calculate and check intersection with a smaller attack box ---
        // Get the hamster's current bounding box
        Box hamsterBox = this.getBoundingBox();
        // Expand it horizontally by the custom smaller amount
        Box attackBox = hamsterBox.expand(HAMSTER_ATTACK_BOX_EXPANSION, 0.0D, HAMSTER_ATTACK_BOX_EXPANSION);
        // Check if this smaller attack box intersects the target's hitbox
        boolean intersects = attackBox.intersects(entity.getBoundingBox());
        return intersects;
    }

    // --- Target Exclusion Override ---
    @Override
    public boolean canAttackWithOwner(LivingEntity target, LivingEntity owner) {
        UUID ownerUuid = owner.getUuid();
        AdorableHamsterPets.LOGGER.trace("[canAttackWithOwner] Hamster: {}, Target: {}, Owner: {}", this.getName().getString(), target.getName().getString(), owner.getName().getString());

        // --- 1. Basic Exclusions (Self, Owner) ---
        if (target == this || target == owner) {
            return false;
        }
        if (target instanceof PlayerEntity && target.getUuid().equals(ownerUuid)) {
            return false;
        }

        // --- 2. Exclude Creepers and Armor Stands ---
        if (target instanceof CreeperEntity || target instanceof ArmorStandEntity) {
            return false;
        }

        // --- 3. Explicitly Check for TameableEntity ---
        if (target instanceof TameableEntity tameablePet) {
            UUID petOwnerUuid = tameablePet.getOwnerUuid();
            if (petOwnerUuid != null && petOwnerUuid.equals(ownerUuid)) {
                AdorableHamsterPets.LOGGER.trace("[canAttackWithOwner] Target is a TameableEntity owned by the same player. Preventing attack.");
                return false;
            }
        }

        // --- 4. Explicitly Check for AbstractHorseEntity ---
        else if (target instanceof net.minecraft.entity.passive.AbstractHorseEntity horsePet) {
            Entity horseOwnerEntity = horsePet.getOwner();
            if (horseOwnerEntity != null && horseOwnerEntity.getUuid().equals(ownerUuid)) {
                AdorableHamsterPets.LOGGER.trace("[canAttackWithOwner] Target is an AbstractHorseEntity owned by the same player. Preventing attack.");
                return false;
            }
        }

        // --- 5. General Ownable Check (Fallback) ---
        else if (target instanceof Ownable ownableFallback) {
            Entity fallbackOwnerEntity = ownableFallback.getOwner();
            if (fallbackOwnerEntity != null && fallbackOwnerEntity.getUuid().equals(ownerUuid)) {
                AdorableHamsterPets.LOGGER.trace("[canAttackWithOwner] Target is an Ownable (fallback) owned by the same player. Preventing attack.");
                return false;
            }
        }

        // --- 6. Default: Allow Attack ---
        return true;
    }

    // --- Interaction Logic ---
    @Override
    public ActionResult interactMob(PlayerEntity player, Hand hand) {
        // --- Initial Setup ---
        ItemStack stack = player.getStackInHand(hand);
        World world = this.getWorld();
        AdorableHamsterPets.LOGGER.trace("[InteractMob {} Tick {}] Interaction start. Player: {}, Hand: {}, Item: {}", this.getId(), world.getTime(), player.getName().getString(), hand, stack.getItem());

        // --- Interaction Cooldown Check ---
        if (this.interactionCooldown > 0) {
            AdorableHamsterPets.LOGGER.trace("[InteractMob {} Tick {}] Interaction cooldown active ({} ticks left). Passing.", this.getId(), world.getTime(), this.interactionCooldown);
            return ActionResult.PASS;
        }

        // --- Toggle Jade Debug with Guide Book ---
        if (player.isSneaking() && stack.isOf(ModItems.HAMSTER_GUIDE_BOOK.get())) {
            if (!world.isClient) { // Server-side logic
                AhpConfig currentConfig = AdorableHamsterPets.CONFIG;
                boolean currentSetting = currentConfig.enableJadeHamsterDebugInfo;
                boolean newSetting = !currentSetting;

                currentConfig.enableJadeHamsterDebugInfo = newSetting;
                currentConfig.save(); // Save the config to file

                Text message = Text.translatable(
                        newSetting ? "message.adorablehamsterpets.debug_overlay_enabled" : "message.adorablehamsterpets.debug_overlay_disabled"
                ).formatted(newSetting ? Formatting.GREEN : Formatting.RED);
                player.sendMessage(message, true); // Send to action bar

                AdorableHamsterPets.LOGGER.info("Player {} toggled Jade Hamster Debug Info via Guide Book to: {} for hamster {}", player.getName().getString(), newSetting, this.getId());
            }
            return ActionResult.success(world.isClient()); // Consume the action
        }

        // --- Hamster Bed Linking/Configuration ---
        if (this.isTamed() && this.isOwner(player) && stack.getItem() instanceof HamsterBedItem) {
            if (!world.isClient) {
                // 1.20.1 NBT read Logic
                UUID linkedUuid = null;
                if (stack.hasNbt() && stack.getNbt().contains(ModNbtKeys.LINKED_HAMSTER_UUID)) {
                    linkedUuid = stack.getNbt().getUuid(ModNbtKeys.LINKED_HAMSTER_UUID);
                }
                Text nameToSet;
                if (this.hasCustomName()) {
                    nameToSet = this.getName();
                } else {
                    nameToSet = this.getDisplayName().copy().append(" " + this.getId());
                }
                String nameJson = Text.Serializer.toJson(nameToSet);

                if (linkedUuid == null) {
                    // Case 1: Initial Linking (Unlinked Bed)
                    ItemStack newStack = stack.copy();
                    NbtCompound nbt = newStack.getOrCreateNbt();

                    nbt.putUuid(ModNbtKeys.LINKED_HAMSTER_UUID, this.getUuid());
                    nbt.putString(ModNbtKeys.LINKED_HAMSTER_NAME, nameJson);
                    nbt.putString(ModNbtKeys.WANDER_DISTANCE, Configs.AHP.defaultWanderDistance.get().asString());

                    player.setStackInHand(hand, newStack);

                    world.playSound(null, this.getBlockPos(), SoundEvents.BLOCK_BAMBOO_WOOD_PLACE, SoundCategory.PLAYERS, 1.0f, 1.2f);
                    ((ServerWorld) world).spawnParticles(ParticleTypes.HAPPY_VILLAGER, this.getX(), this.getBodyY(0.5), this.getZ(), 10, 0.5, 0.5, 0.5, 0.0);
                    player.sendMessage(Text.translatable("message.adorablehamsterpets.bed_linked", this.getName()), true);

                    // Trigger advancement
                    if (player instanceof ServerPlayerEntity serverPlayer) {
                        ModCriteria.HAMSTER_BED_LINKED.trigger(serverPlayer);
                    }

                } else if (linkedUuid.equals(this.getUuid())) {
                    // Case 2: Re-configuring Wander Distance of already linked bed
                    // 1.20.1 NBT logic
                    WanderDistance currentDistance = Configs.AHP.defaultWanderDistance.get();
                    NbtCompound stackNbt = stack.getOrCreateNbt();

                    if (stackNbt.contains(ModNbtKeys.WANDER_DISTANCE)) {
                        try {
                            currentDistance = WanderDistance.valueOf(stackNbt.getString(ModNbtKeys.WANDER_DISTANCE));
                        } catch (IllegalArgumentException ignored) {}
                    }

                    WanderDistance[] values = WanderDistance.values();
                    WanderDistance nextDistance = values[(currentDistance.ordinal() + 1) % values.length];

                    stackNbt.putString(ModNbtKeys.WANDER_DISTANCE, nextDistance.asString());

                    player.sendMessage(Text.translatable("message.adorablehamsterpets.wander_distance_set", this.getName(), nextDistance.asString()), true);
                    world.playSound(null, this.getBlockPos(), SoundEvents.UI_BUTTON_CLICK.value(), SoundCategory.PLAYERS, 0.5f, 1.0f);

                } else {
                    // Case 3: Re-linking a bed that was linked to a DIFFERENT hamster
                    ItemStack newStack = stack.copy();
                    NbtCompound nbt = newStack.getOrCreateNbt();

                    nbt.putUuid(ModNbtKeys.LINKED_HAMSTER_UUID, this.getUuid());
                    nbt.putString(ModNbtKeys.LINKED_HAMSTER_NAME, nameJson);
                    nbt.putString(ModNbtKeys.WANDER_DISTANCE, Configs.AHP.defaultWanderDistance.get().asString());  // Reset to default

                    player.setStackInHand(hand, newStack);

                    world.playSound(null, this.getBlockPos(), SoundEvents.BLOCK_BAMBOO_WOOD_PLACE, SoundCategory.PLAYERS, 1.0f, 1.2f);
                    ((ServerWorld) world).spawnParticles(ParticleTypes.HAPPY_VILLAGER, this.getX(), this.getBodyY(0.5), this.getZ(), 10, 0.5, 0.5, 0.5, 0.0);
                    player.sendMessage(Text.translatable("message.adorablehamsterpets.bed_linked", this.getName()), true);
                }
                // If UUID is present but doesn't match, do nothing.
            }
            return ActionResult.success(world.isClient);
        }

        // --- Taming Logic ---
        if (!this.isTamed()) {
            AdorableHamsterPets.LOGGER.trace("[InteractMob {} Tick {}] Hamster not tamed. Checking for taming attempt.", this.getId(), world.getTime());
            if (player.isSneaking() && ConfigDataCache.isTamingFood(stack)) {
                AdorableHamsterPets.LOGGER.trace("[InteractMob {} Tick {}] Taming attempt detected.", this.getId(), world.getTime());
                if (!world.isClient) { tryTame(player, stack); }
                return ActionResult.success(world.isClient());
            }
            AdorableHamsterPets.LOGGER.trace("[InteractMob {} Tick {}] Not a taming attempt. Calling super.interactMob for untamed.", this.getId(), world.getTime());
            return super.interactMob(player, hand);
        }

        // --- Owner Interaction Logic ---
        if (this.isOwner(player)) {
            AdorableHamsterPets.LOGGER.trace("[InteractMob {} Tick {}] Player is owner. Processing owner interactions.", this.getId(), world.getTime());
            boolean isSneaking = player.isSneaking();
            PlayerEntityAccessor playerAccessor = (PlayerEntityAccessor) player;

            // --- Wake Up From Bed if Sleeping In One ---
            if (this.isSleeping()) {
                if (!world.isClient()) {
                    this.wakeUpFromBed(true); // Manual wake-up
                }
                return ActionResult.success(world.isClient());
            }

            // --- Reset Sleep Sequence if Dozing (not in a bed) ---
            if (this.getDozingPhase() != DozingPhase.NONE) {
                resetSleepSequence("Player interacted with hamster.");
            }

            // --- Handle Diamond Stealing Interaction ---
            if (this.isStealingDiamond() && this.isOwner(player)) {
                AdorableHamsterPets.LOGGER.trace("[InteractMob-{}] Passed 'isStealingDiamond' check.", this.getId());
                if (!world.isClient) {
                    ItemStack retrievedStack = this.getStolenItemStack().copy();
                    player.getInventory().offerOrDrop(this.getStolenItemStack().copy());
                    this.setStolenItemStack(ItemStack.EMPTY);
                    this.setStealDurationTimer(0);
                    this.setStealingDiamond(false);
                    // Set the state flag and initialize the timer so the tick() method can handle the rotation.
                    this.setCelebratingChase(true);
                    this.celebrationChaseTicks = 30; // 1.5 second duration
                    this.triggerAnimOnServer("mainController", "anim_hamster_celebrate_chase");
                    // Play a happy/affectionate and diamond "tink" sound
                    world.playSound(null, this.getBlockPos(), ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_AFFECTION_SOUNDS, this.random), SoundCategory.NEUTRAL, 1.0f, this.getSoundPitch());
                    // Get and play the dynamic sound
                    if (!retrievedStack.isEmpty()) {
                        SoundEvent pounceSound = ModSounds.getDynamicItemSound(retrievedStack);
                        float volume = (pounceSound == SoundEvents.ENTITY_GENERIC_EAT) ? 0.35f : 1.0f;
                        world.playSound(null, this.getBlockPos(), pounceSound, SoundCategory.NEUTRAL, volume, 1.7f);
                    }
                    AdorableHamsterPets.LOGGER.trace("[InteractMob-{}] Diamond returned to player and goal stopped.", this.getId());
                }
                return ActionResult.success(world.isClient());
            }

            // --- Check for Knocked Out ---
            if (this.isKnockedOut()) {
                AdorableHamsterPets.LOGGER.trace("[InteractMob {} Tick {}] Hamster is knocked out. Waking up.", this.getId(), world.getTime());
                if (!world.isClient()) {
                    SoundEvent wakeUpSound = getRandomSoundFrom(ModSounds.HAMSTER_WAKE_UP_SOUNDS, this.random);
                    if (wakeUpSound != null) {
                        world.playSound(null, this.getBlockPos(), wakeUpSound, SoundCategory.NEUTRAL, 1.0F, 1.0F);
                    }
                    this.setKnockedOut(false); // Turn off knocked out
                    this.setSitting(false, true); // Make sure sitting doesn't get turned on
                    this.triggerAnimOnServer("mainController", "wakeup_from_ko");
                }
                return ActionResult.success(world.isClient());
            }

            // --- Check for Diamond Celebration ---
            if (this.isCelebratingDiamond()) {
                if (!world.isClient()) {
                    this.setCelebratingDiamond(false); // Turn off celebration
                    this.setSitting(false, true); // Make sure sitting doesn't get turned on
                    SoundEvent affectionSound = ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_AFFECTION_SOUNDS, this.random);
                    if (affectionSound != null) {
                        world.playSound(null, this.getBlockPos(), affectionSound, SoundCategory.NEUTRAL, 1.0f, this.getSoundPitch());
                    } else { // Fallback
                        world.playSound(null, this.getBlockPos(), SoundEvents.ENTITY_ITEM_PICKUP, SoundCategory.NEUTRAL, 0.5f, 1.5f);
                    }
                }
                return ActionResult.success(world.isClient()); // Consume the interaction
            }

            // --- Check for Sulking ---
            if (this.isSulking()) {
                if (!world.isClient()) {
                    this.setSulking(false); // Turn off sulking
                    this.setSitting(false, true); // Ensure sitting is also cleared
                    SoundEvent affectionSound = ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_AFFECTION_SOUNDS, this.random);
                    if (affectionSound != null) {
                        world.playSound(null, this.getBlockPos(), affectionSound, SoundCategory.NEUTRAL, 1.0f, this.getSoundPitch());
                    } else { // Fallback
                        world.playSound(null, this.getBlockPos(), SoundEvents.ENTITY_CHICKEN_STEP, SoundCategory.NEUTRAL, 0.5f, 1.5f);
                    }
                }
                return ActionResult.success(world.isClient()); // Consume interaction
            }

            // --- Pink Petal Application/Cycling ---
            if (stack.isOf(Items.PINK_PETALS) && !player.isSneaking()) {
                if (!world.isClient) {
                    int currentPetalType = this.dataTracker.get(PINK_PETAL_TYPE);
                    int nextPetalType = (currentPetalType % 3) + 1; // Cycles 0->1, 1->2, 2->3, 3->1
                    this.dataTracker.set(PINK_PETAL_TYPE, nextPetalType);
                    world.playSound(null, this.getBlockPos(), SoundEvents.BLOCK_PINK_PETALS_PLACE, SoundCategory.PLAYERS, 0.7f, 1.0f + random.nextFloat() * 0.2f);
                    if (world instanceof ServerWorld serverWorld) {
                        serverWorld.spawnParticles(ParticleTypes.FALLING_SPORE_BLOSSOM,
                                this.getX(), this.getY() + this.getHeight() * 0.75, this.getZ(),
                                7, (this.getWidth() / 2.0F), (this.getHeight() / 2.0F), (this.getWidth() / 2.0F), 0.0);
                    }
                    if (!player.getAbilities().creativeMode) {
                        stack.decrement(1);
                    }
                    AdorableHamsterPets.LOGGER.trace("[InteractMob {}] Cycled/Applied pink petal to type {}.", this.getId(), nextPetalType);
                    // Trigger advancement criterion
                    if (player instanceof ServerPlayerEntity serverPlayer) {
                        ModCriteria.APPLIED_PINK_PETAL.trigger(serverPlayer, this);
                    }
                }
                return ActionResult.success(world.isClient()); // Consume interaction
            }

            // --- Pink Petal Removal with Shears ---
            if (stack.isOf(Items.SHEARS) && !player.isSneaking()) {
                if (this.dataTracker.get(PINK_PETAL_TYPE) > 0) { // Only if petals are currently applied
                    if (!world.isClient) {
                        this.dataTracker.set(PINK_PETAL_TYPE, 0); // Remove petals
                        world.playSound(null, this.getBlockPos(), SoundEvents.ENTITY_SHEEP_SHEAR, SoundCategory.PLAYERS, 0.9f, 1.0f + random.nextFloat() * 0.1f);
                        if (world instanceof ServerWorld serverWorld) {
                            serverWorld.spawnParticles(new ItemStackParticleEffect(ParticleTypes.ITEM, new ItemStack(Items.PINK_PETALS)),
                                    this.getX(), this.getY() + this.getHeight() * 0.5, this.getZ(),
                                    5, (this.getWidth() / 2.0F), (this.getHeight() / 2.0F), (this.getWidth() / 2.0F), 0.05);
                        }
                        // Drop one pink petal
                        ItemScatterer.spawn(world, this.getX(), this.getY() + 0.5, this.getZ(), new ItemStack(Items.PINK_PETALS, 1));

                        if (!player.getAbilities().creativeMode) {
                            // For 1.20.1 - Determine EquipmentSlot based on the hand used.
                            stack.damage(1, player, (p) -> p.sendEquipmentBreakStatus(hand == Hand.MAIN_HAND ? EquipmentSlot.MAINHAND : EquipmentSlot.OFFHAND));
                        }
                        AdorableHamsterPets.LOGGER.trace("[InteractMob {}] Removed pink petals with shears.", this.getId());
                    }
                    return ActionResult.success(world.isClient()); // Consume interaction
                }
            }

            // --- Shoulder Mounting Logic ---
            boolean isUsingItem = ConfigDataCache.isLureItem(stack);

            // Only check item here. Force-Mount Keybind handled by client event + packet.
            if (ConfigDataCache.isLureItem(stack)) {
                if (!world.isClient) {
                    tryShoulderMount(player, stack);
                } else {
                    player.swingHand(hand);
                }
                return ActionResult.CONSUME; // Consume item interaction
            }

            // --- Inventory Access ---
            if (!world.isClient() && isSneaking) {
                // Check if pouch is unlocked OR if config disables the lock
                if (getHamsterFlag(CHEEK_POUCH_UNLOCKED_FLAG) || !AdorableHamsterPets.CONFIG.requireFoodMixToUnlockCheeks) {
                    // --- Use Architectury's openExtendedMenu with the factory ---
                    MenuRegistry.openExtendedMenu((ServerPlayerEntity) player, new HamsterScreenHandlerFactory(this));
                } else {
                    player.sendMessage(Text.translatable("message.adorablehamsterpets.cheek_pouch_locked").formatted(Formatting.WHITE), true);
                }
                return ActionResult.CONSUME; // Consume sneak action regardless of opening
            }

            // --- Feeding Logic ---
            boolean isPotentialFood = ConfigDataCache.isStandardFood(stack) || ConfigDataCache.isBuffFood(stack) || ConfigDataCache.isPouchUnlockFood(stack);
            if (!world.isClient() && !isSneaking && isPotentialFood) {
                AdorableHamsterPets.LOGGER.trace("[InteractMob {} Tick {}] Owner not sneaking, holding potential food. Checking refusal.", this.getId(), world.getTime());
                if (checkRepeatFoodRefusal(stack, player)) {
                    AdorableHamsterPets.LOGGER.trace("[InteractMob {} Tick {}] Food refused. Consuming interaction.", this.getId(), world.getTime());
                    return ActionResult.CONSUME; // Consume refusal action
                }
                AdorableHamsterPets.LOGGER.trace("[InteractMob {} Tick {}] Attempting feeding via tryFeedingAsTamed.", this.getId(), world.getTime());
                boolean feedingOccurred = tryFeedingAsTamed(player, stack); // Calls the method with detailed logging
                if (feedingOccurred) {
                    AdorableHamsterPets.LOGGER.trace("[InteractMob {} Tick {}] tryFeedingAsTamed returned true. Setting last food, decrementing stack.", this.getId(), world.getTime());
                    this.lastFoodItem = stack.copy(); // Track last food *only* if feeding was successful
                    if (!player.getAbilities().creativeMode) {
                        stack.decrement(1);
                    }
                    return ActionResult.CONSUME; // Consume successful feeding action
                } else {
                    // If tryFeedingAsTamed returned false (e.g., cooldown, full health+no breed),
                    // We might still want to allow vanilla interaction or sitting.
                    // Let's PASS for now to allow super.interactMob to run.
                    AdorableHamsterPets.LOGGER.trace("[InteractMob {} Tick {}] tryFeedingAsTamed returned false. Passing to vanilla/sitting.", this.getId(), world.getTime());
                }
            }

            // --- Vanilla Interaction Handling ---
            if (!isSneaking && !isPotentialFood && !ConfigDataCache.isLureItem(stack) && !stack.isOf(Items.PINK_PETALS)) {
                AdorableHamsterPets.LOGGER.trace("[InteractMob {} Tick {}] Not sneaking or holding handled food/petals. Calling super.interactMob.", this.getId(), world.getTime());
                ActionResult vanillaResult = super.interactMob(player, hand);
                AdorableHamsterPets.LOGGER.trace("[InteractMob {} Tick {}] super.interactMob returned: {}", this.getId(), world.getTime(), vanillaResult);
                if (vanillaResult.isAccepted()) {
                    return vanillaResult;
                }
            }

            // --- Sitting Logic ---
            if (!world.isClient() && !isSneaking) {
                AdorableHamsterPets.LOGGER.trace("[InteractMob {} Tick {}] Fallback: Toggling sitting state.", this.getId(), world.getTime());

                // The setSitting method handles all animations and sounds.
                this.setSitting(!this.isSitting());

                this.jumping = false;
                this.navigation.stop();
                this.setTarget(null);
                return ActionResult.CONSUME_PARTIAL; // Indicate partial consumption for state toggle
            }
            // Client-side success or fallback pass for owner
            AdorableHamsterPets.LOGGER.debug("[InteractMob {} Tick {}] Reached end of owner logic. Returning client-side success/pass.", this.getId(), world.getTime());
            return ActionResult.success(world.isClient());

        } else {
            // Interaction by a non-owner on a tamed hamster. Let vanilla handle it.
            AdorableHamsterPets.LOGGER.debug("[InteractMob {} Tick {}] Player is not owner. Calling super.interactMob.", this.getId(), world.getTime());
            return super.interactMob(player, hand);
        }
    }

    // --- Taming Override ---
    /**
     * Overrides the vanilla setTamed method. This is the method called by vanilla logic.
     * It delegates to our custom implementation, ensuring attributes are always updated.
     * @param tamed True if the entity is being tamed.
     */
    @Override
    public void setTamed(boolean tamed) {
        // Always update attributes when this vanilla method is called.
        this.setTamed(tamed, true);
    }

    /**
     * Custom implementation of setTamed that allows controlling the attribute update.
     * In 1.20.1, this is now a helper method for the mod's internal use.
     * @param tamed True if the entity is being tamed.
     * @param updateAttributes True to update the entity's attributes (e.g., max health).
     */
    public void setTamed(boolean tamed, boolean updateAttributes) {
        super.setTamed(tamed); // Call the parent method
        if (updateAttributes) {
            if (tamed) {
                this.getAttributeInstance(EntityAttributes.GENERIC_MAX_HEALTH).setBaseValue(Configs.AHP.tamedMaxHealth.get());
                this.setHealth(this.getMaxHealth());
                this.getAttributeInstance(EntityAttributes.GENERIC_ATTACK_DAMAGE).setBaseValue(Configs.AHP.meleeDamage.get());
            } else {
                this.getAttributeInstance(EntityAttributes.GENERIC_MAX_HEALTH).setBaseValue(Configs.AHP.wildMaxHealth.get());
                this.getAttributeInstance(EntityAttributes.GENERIC_ATTACK_DAMAGE).setBaseValue(Configs.AHP.meleeDamage.get());
            }
        }
    }

    // --- Breeding ---
    public boolean isInCustomLove() { return this.customLoveTimer > 0; }
    public void setCustomInLove(PlayerEntity player) {
        this.customLoveTimer = CUSTOM_LOVE_TICKS;
        if (!this.getWorld().isClient) { this.getWorld().sendEntityStatus(this, (byte) 18); }
    }

    @Override
    public void setBaby(boolean baby) {
        this.setBreedingAge(baby ? -24000 : 0); // Vanilla logic for setting age based on baby status
    }


    // --- Method to Synchronize Custom Sitting DataTracker with Vanilla Pose ---
    /** This method is called by vanilla logic (like SitGoal) when the sitting pose changes.
     * We override it to ensure our custom IS_SITTING DataTracker, which drives animations,
     * stays synchronized with the entity's actual sitting pose state.
     */
    @Override
    public void setInSittingPose(boolean inSittingPose) {
        // --- 1. Call Superclass Method ---
        super.setInSittingPose(inSittingPose);


        // --- 2. Synchronize Custom Flag ---
        if (this.getHamsterFlag(SITTING_FLAG) != inSittingPose) {
            setHamsterFlag(SITTING_FLAG, inSittingPose);
        }

        // --- 3. Additional State Reset if Standing Up ---
        if (!inSittingPose) {
            if (this.isSleeping()) {
                this.setSleeping(false);
            }
            if (this.isKnockedOut()) {
                this.setKnockedOut(false);
            }
        }
    }

    // --- Hamster Breeding and Baby Variant Logic ---
    /**
     * Gets the HamsterVariant enum constant corresponding to this entity's current variant ID.
     * @return The HamsterVariant enum.
     */
    public HamsterVariant getVariantEnum() {
        return HamsterVariant.byId(this.getVariant());
    }

    /**
     * Creates a baby hamster, inheriting traits from its parents.
     * <p>
     * The baby's base color is randomly chosen from one of its parents. The overlay (white markings)
     * follows specific inheritance rules to promote diversity:
     * <ul>
     *     <li>If both parents have an overlay, the baby is guaranteed to have one. The system first
     *         tries to assign an overlay pattern that is different from both parents. If no different
     *         overlay is available for the baby's inherited base color, it will pick any available
     *         overlay for that color, potentially matching a parent's pattern.</li>
     *     <li>If only one or neither parent has an overlay, the baby has a chance to inherit any
     *         eligible overlay for its base color or to have no overlay at all (just the base color).</li>
     *     <li>The {@code WHITE} base color is a special case and never receives an overlay.</li>
     * </ul>
     * The baby inherits the owner of the parent instance that initiated the breeding.
     *
     * @param world The server world where the child will be created.
     * @param mate The other parent entity.
     * @return A new {@code HamsterEntity} instance representing the baby, or {@code null} if creation fails.
     */
    @Nullable
    @Override
    public PassiveEntity createChild(ServerWorld world, PassiveEntity mate) {
        HamsterEntity baby = ModEntities.HAMSTER.get().create(world);
        if (baby == null) return null;

        if (!(mate instanceof HamsterEntity mother)) {
            int randomVariantId = this.random.nextInt(HamsterVariant.values().length);
            baby.setVariant(randomVariantId);
            baby.setBaby(true);
            AdorableHamsterPets.LOGGER.warn("Hamster breeding attempted with non-hamster mate. Assigning random variant to baby.");
            return baby;
        }

        HamsterEntity father = this;
        HamsterVariant parentProvidingBaseColor = this.random.nextBoolean() ? father.getVariantEnum() : mother.getVariantEnum();
        HamsterVariant babyBaseColorEnum = parentProvidingBaseColor.getBaseVariant();

        @Nullable String fatherOverlayName = father.getVariantEnum().getOverlayTextureName();
        @Nullable String motherOverlayName = mother.getVariantEnum().getOverlayTextureName();

        List<HamsterVariant> allVariantsForBabyBase = HamsterVariant.getVariantsForBase(babyBaseColorEnum);

        // Build a list of overlay names that are NOT used by either parent.
        List<@Nullable String> eligibleOverlayNames = new ArrayList<>();
        for (HamsterVariant variant : allVariantsForBabyBase) {
            @Nullable String candidateOverlay = variant.getOverlayTextureName();
            boolean matchesFather = fatherOverlayName != null && fatherOverlayName.equals(candidateOverlay);
            boolean matchesMother = motherOverlayName != null && motherOverlayName.equals(candidateOverlay);
            if (!matchesFather && !matchesMother) {
                eligibleOverlayNames.add(candidateOverlay);
            }
        }

        List<@Nullable String> finalSelectableOverlayNames = new ArrayList<>();
        boolean fatherHasOverlay = fatherOverlayName != null;
        boolean motherHasOverlay = motherOverlayName != null;

        if (fatherHasOverlay && motherHasOverlay) {
            // Baby MUST have an overlay. Prioritize overlays different from parents.
            for (@Nullable String overlayName : eligibleOverlayNames) {
                if (overlayName != null) {
                    finalSelectableOverlayNames.add(overlayName);
                }
            }
            // If no different overlay is available, relax the rule and allow any overlay for that base color.
            if (finalSelectableOverlayNames.isEmpty() && babyBaseColorEnum != HamsterVariant.WHITE) {
                for (HamsterVariant variant : allVariantsForBabyBase) {
                    if (variant.getOverlayTextureName() != null) {
                        finalSelectableOverlayNames.add(variant.getOverlayTextureName());
                    }
                }
            }
        } else {
            // If one or neither parent has an overlay, the baby can have no overlay.
            finalSelectableOverlayNames.addAll(eligibleOverlayNames);
        }

        HamsterVariant babyFinalVariant;
        if (!finalSelectableOverlayNames.isEmpty()) {
            @Nullable String chosenOverlayName = finalSelectableOverlayNames.get(this.random.nextInt(finalSelectableOverlayNames.size()));
            babyFinalVariant = HamsterVariant.getVariantByBaseAndOverlay(babyBaseColorEnum, chosenOverlayName);
        } else {
            // Fallback case
            babyFinalVariant = babyBaseColorEnum;
        }

        baby.setVariant(babyFinalVariant.getId());

        UUID ownerUUID = father.getOwnerUuid();
        if (ownerUUID != null) {
            baby.setOwnerUuid(ownerUUID);
            baby.setTamed(true, true);
        }
        baby.setBaby(true);

        return baby;
    }

    /**
     * Checks if the given ItemStack can be used to initiate breeding.
     * This check is now driven by the user-configurable {@code standardFoods} list
     * via the {@link ConfigDataCache#isStandardFood(ItemStack)} helper method.
     *
     * @param stack The ItemStack to check.
     * @return {@code true} if the item is a valid breeding food.
     */
    @Override
    public boolean isBreedingItem(ItemStack stack) {
        return ConfigDataCache.isStandardFood(stack);
    }

    // --- Tick Logic ---
    @Override
    public void tick() {
        // --- Triggerable Animation Cancellation Scheduler ---
        if (!this.getWorld().isClient()) {
            long currentTime = this.getWorld().getTime();
            // Use removeIf for safe concurrent modification while iterating
            scheduledTasks.removeIf(task -> {
                if (currentTime >= task.executionTick()) {
                    task.action().run();
                    return true; // Remove the task
                }
                return false;
            });
        }

        // --- 1. Decrement Simple Timers ---
        if (this.interactionCooldown > 0) this.interactionCooldown--;
        if (this.suffocationGracePeriod > 0) this.suffocationGracePeriod--;
        if (this.wakingUpTicks > 0) this.wakingUpTicks--;
        if (this.autoEatCooldownTicks > 0) this.autoEatCooldownTicks--;
        if (this.autoEatProgressTicks > 0) this.autoEatProgressTicks--;
        if (this.ejectionCheckCooldown > 0) this.ejectionCheckCooldown--;
        if (this.preAutoEatDelayTicks > 0) this.preAutoEatDelayTicks--;
        if (this.celebrationParticleTicks > 0) this.celebrationParticleTicks--;
        if (this.celebrationParticleTicks > 0) this.celebrationParticleTicks--;
        if (this.diamondCelebrationSoundTicks > 0) this.diamondCelebrationSoundTicks--;
        if (this.sulkOrchestraHitDelayTicks > 0) this.sulkOrchestraHitDelayTicks--;
        if (this.sulkFailParticleTicks > 0) this.sulkFailParticleTicks--;
        if (this.sulkEntityEffectTicks > 0) this.sulkEntityEffectTicks--;
        if (this.sulkShockedSoundDelayTicks > 0) this.sulkShockedSoundDelayTicks--;
        if (this.diamondSparkleSoundDelayTicks > 0) this.diamondSparkleSoundDelayTicks--;
        if (this.goToBedCooldown > 0) this.goToBedCooldown--;
        if (this.lureToBedTimer > 0) this.lureToBedTimer--;
        if (this.wakeUpFromBedDelay > 0) this.wakeUpFromBedDelay--;
        if (this.napInBedDurationTimer > 0) this.napInBedDurationTimer--;

        // --- Settle "Thump" Sound Effect ---
        if (this.thumpSoundDelayTicks > 0) {
            this.thumpSoundDelayTicks--;
            if (this.thumpSoundDelayTicks == 0 && !this.getWorld().isClient()) {
                this.getWorld().playSound(null, this.getBlockPos(), ModSounds.HAMSTER_THUMP.get(), SoundCategory.NEUTRAL, this.thumpSoundVolume, 1.5f);
            }
        }

        // --- Bed Leaf Particle Effect ---
        if (this.bedLeafParticleTicks > 0) {
            if (!this.getWorld().isClient()) {
                int particleCount = 0;
                // Check for specific moments in the 4-tick duration
                if (this.bedLeafParticleTicks == 3) { // Second burst
                    particleCount = 15;
                } else if (this.bedLeafParticleTicks == 2) { // Third burst
                    particleCount = 10;
                }else if (this.bedLeafParticleTicks == 1) { // Fourth burst
                    particleCount = 5;
                }

                if (particleCount > 0 && this.getLinkedBedPos().isPresent()) {
                    BlockPos bedPos = this.getLinkedBedPos().get().getPos();
                    BlockState bedState = this.getWorld().getBlockState(bedPos);
                    ((ServerWorld)this.getWorld()).spawnParticles(ModParticles.getForVariant(bedState.get(HamsterBedBlock.WOOD_VARIANT)),
                            bedPos.getX() + 0.5, bedPos.getY() + 0.3, bedPos.getZ() + 0.5,
                            particleCount, 0.2, 0.3, 0.2, 1);
                }
            }
            // Decrement the timer after processing the current tick's effect.
            this.bedLeafParticleTicks--;
        }

        // --- Cleaning Logic ---
        if (this.cleaningCooldownTimer > 0) this.cleaningCooldownTimer--;
        if (this.cleaningTimer > 0) {
            this.cleaningTimer--;
            if (this.cleaningTimer == 0) {
                if (!this.getWorld().isClient) {
                    setHamsterFlag(CLEANING_FLAG, false);
                }
                this.cleaningCooldownTimer = 200;
            }
        }
        if (this.isKnockedOut() && getHamsterFlag(CLEANING_FLAG)) {
            setHamsterFlag(CLEANING_FLAG, false);
            this.cleaningTimer = 0;
        }
        DozingPhase currentPhase = this.getDozingPhase();
        if (!this.getWorld().isClient() && this.isTamed() && this.isSitting() && !getHamsterFlag(CLEANING_FLAG) && this.cleaningCooldownTimer <= 0) {
            // Allow cleaning if the hamster is just sitting, but not if it's actively sleeping.
            if (currentPhase == DozingPhase.NONE || currentPhase == DozingPhase.QUIESCENT_SITTING) {
                int chanceDenominator = Configs.AHP.cleaningChanceDenominator.get();
                if (chanceDenominator > 0 && this.random.nextInt(chanceDenominator) == 0) {
                    this.cleaningTimer = this.random.nextBetween(30, 60);
                    setHamsterFlag(CLEANING_FLAG, true);
                }
            }
        }

        // --- Post-Chase Celebration Logic ---
        if (this.isCelebratingChase()) {
            if (this.celebrationChaseTicks > 0) {
                if (this.getOwner() != null) {
                    this.getLookControl().lookAt(this.getOwner(), FAST_YAW_CHANGE, FAST_PITCH_CHANGE);
                }
                this.celebrationChaseTicks--;
            } else {
                this.setCelebratingChase(false);
            }
        }

        // --- 2. Thrown State Logic ---
        if (this.isThrown()) {
            this.throwTicks++; // Increment throw timer

            Vec3d currentPos = this.getPos();
            Vec3d currentVel = this.getVelocity();
            Vec3d nextPos = currentPos.add(currentVel);
            World world = this.getWorld();

            HitResult blockHit = world.raycast(new RaycastContext(currentPos, nextPos, RaycastContext.ShapeType.COLLIDER, RaycastContext.FluidHandling.NONE, this));

            boolean stopped = false;

            if (blockHit.getType() == HitResult.Type.BLOCK) {
                // --- 2a. Block Collision Handling ---
                net.minecraft.util.hit.BlockHitResult blockHitResult = (net.minecraft.util.hit.BlockHitResult) blockHit;
                BlockPos adjacentPos = blockHitResult.getBlockPos().offset(blockHitResult.getSide());

                // Place the hamster in the air next to the impacted block face.
                this.setPosition(adjacentPos.getX() + 0.5, adjacentPos.getY(), adjacentPos.getZ() + 0.5);

                // Apply the "tumble" state immediately. Vanilla gravity will handle the fall.
                this.setVelocity(currentVel.multiply(0.6, 0.0, 0.6));
                this.setThrown(false);
                this.playSound(SoundEvents.ENTITY_GENERIC_SMALL_FALL, 1.0f, 1.2f);
                // Play faint sound for distant players
                broadcastDistantImpact(SoundEvents.ENTITY_GENERIC_SMALL_FALL, 1.2f);

                this.setKnockedOut(true);
                this.setInSittingPose(true);
                if (!world.isClient()) {
                    this.triggerAnimOnServer("mainController", "crash");
                }
                stopped = true;

            } else {
                EntityHitResult entityHit = ProjectileUtil.getEntityCollision(world, this, currentPos, nextPos, this.getBoundingBox().stretch(currentVel).expand(1.0), this::canHitEntity);

                if (entityHit != null && entityHit.getEntity() != null) {
                    // --- 2b. Entity Collision Handling ---
                    Entity hitEntity = entityHit.getEntity();
                    BlockPos impactPos = hitEntity.getBlockPos();
                    boolean playEffects = false;

                    if (hitEntity instanceof ArmorStandEntity) {
                        playEffects = true;
                    } else if (hitEntity instanceof LivingEntity livingHit) {

                        // --- THROW DAMAGE LOGIC ---
                        // 1. Create a DamageSource where the thrown hamster is the attacker.
                        DamageSource damageSource = this.getDamageSources().mobAttack(this);
                        // 2. Get the damage amount from the config.
                        float damageAmount = Configs.AHP.hamsterThrowDamage.get().floatValue();
                        // 3. Deal the damage to the target using the correct source.
                        boolean damaged = livingHit.damage(damageSource, damageAmount);

                        if (damaged) {
                            livingHit.addStatusEffect(new StatusEffectInstance(StatusEffects.NAUSEA, 20, 0, false, false, false));
                            playEffects = true;
                        }
                    } else {
                        playEffects = true;
                    }

                    if (playEffects) {
                        // For 1.20.1, call .get() on the RegistrySupplier
                        world.playSound(null, this.getX(), this.getY(), this.getZ(), ModSounds.HAMSTER_IMPACT.get(), SoundCategory.NEUTRAL, 1.0F, 1.0F);
                        // Play faint sound for distant players
                        broadcastDistantImpact(ModSounds.HAMSTER_IMPACT.get(), 1.0f);
                        if (!world.isClient()) {
                            ((ServerWorld)world).spawnParticles(ParticleTypes.POOF, this.getX(), this.getY() + this.getHeight() / 2.0, this.getZ(), 50, 0.4, 0.4, 0.4, 0.1);
                        }
                    }

                    // Find safe spot near the hit entity
                    Optional<BlockPos> safePosOpt = findSafeSpawnPosition(impactPos, world, 2);
                    safePosOpt.ifPresentOrElse(
                            safePos -> this.setPosition(safePos.getX() + 0.5, safePos.getY(), safePos.getZ() + 0.5),
                            () -> {
                                AdorableHamsterPets.LOGGER.warn("[HamsterThrow] Could not find safe landing spot after hitting entity. Using entity's position {} as fallback.", impactPos);
                                this.setPosition(impactPos.getX() + 0.5, impactPos.getY(), impactPos.getZ() + 0.5);
                            }
                    );

                    this.setVelocity(currentVel.multiply(0.1, 0.1, 0.1));
                    this.setThrown(false);
                    this.setKnockedOut(true);
                    this.setInSittingPose(true);
                    if (!world.isClient()) {
                        this.triggerAnimOnServer("mainController", "crash");
                    }
                    stopped = true;
                }
            }

            // Apply gravity, update position, simulate trajectory audio, and spawn trail particles if still thrown
            if (this.isThrown() && !stopped) {
                if (!this.getWorld().isClient() && !this.hasPlayedIncomingSound) {
                    simulateTrajectoryAndCheckSound();
                }

                if (!this.hasNoGravity()) {
                    this.setVelocity(this.getVelocity().add(0.0, THROWN_GRAVITY, 0.0));
                }

                Vec3d currentVelocity = this.getVelocity();
                if (Double.isNaN(currentVelocity.x) || Double.isNaN(currentVelocity.y) || Double.isNaN(currentVelocity.z)) {
                    this.setVelocity(Vec3d.ZERO);
                    this.setThrown(false);
                    AdorableHamsterPets.LOGGER.warn("Hamster velocity became NaN, resetting and stopping throw.");
                } else {
                    this.setPosition(this.getX() + currentVelocity.x, this.getY() + currentVelocity.y, this.getZ() + currentVelocity.z);
                    this.velocityDirty = true;

                    // Determine the delay before particles start spawning.
                    int particleDelay = this.hasGreenBeanBuff() ? 3 : 5;

                    if (!world.isClient() && this.throwTicks > particleDelay) {
                        // Define an offset to push the particle spawn point backwards along the velocity vector. Larger value pushes it back more.
                        double offsetMultiplier = 1.5;

                        // Calculate the spawn position based on the PREVIOUS position, offset backwards.
                        double spawnX = this.prevX - (currentVelocity.x * offsetMultiplier);
                        double spawnY = this.prevY + (this.getHeight() / 2.0) - (currentVelocity.y * offsetMultiplier);
                        double spawnZ = this.prevZ - (currentVelocity.z * offsetMultiplier);

                        ((ServerWorld)world).spawnParticles(
                                ParticleTypes.CLOUD,
                                spawnX, spawnY, spawnZ,
                                1, 0.1, 0.1, 0.1, 0.0
                        );
                    }
                }
            } else {
                if (this.throwTicks != 0) {
                    this.throwTicks = 0;
                }
            }
        }

        // --- 3. Tamed Hamster "Path to Slumber" State Machine ---
        // This logic only applies to tamed hamsters and runs on the server.
        if (!this.getWorld().isClient() && this.isTamed() && !this.isKnockedOut()) {
            boolean canInitiateDrowsiness = checkConditionsForInitiatingDrowsiness(); // Helper method call
            boolean canSustainSlumber = checkConditionsForSustainingSlumber();       // Helper method call

            switch (currentPhase) {
                case NONE:
                    // If commanded to sit and conditions are right, start Phase 1
                    if (this.isSitting() && canInitiateDrowsiness) {
                        // Check if quiescentSitDurationTimer is 0, meaning we can start a new cycle
                        if (this.quiescentSitDurationTimer == 0) {
                            this.setDozingPhase(DozingPhase.QUIESCENT_SITTING);

                            // Calculate random duration based on config
                            int minSeconds = Configs.AHP.tamedQuiescentSitMinSeconds.get();
                            int maxSeconds = Configs.AHP.tamedQuiescentSitMaxSeconds.get();

                            // Safety rail: ensure min is not greater than max
                            if (minSeconds > maxSeconds) {
                                AdorableHamsterPets.LOGGER.info("Config issue: tamedQuiescentSitMinSeconds ({}) > tamedQuiescentSitMaxSeconds ({}). Swapping.", minSeconds, maxSeconds);
                                int temp = minSeconds;
                                minSeconds = maxSeconds;
                                maxSeconds = temp;
                            }
                            // Safety rail: ensure max is not less than min after potential swap
                            if (maxSeconds < minSeconds) maxSeconds = minSeconds;

                            int durationTicks = this.random.nextBetween(minSeconds * 20, maxSeconds * 20 + 1);
                            this.quiescentSitDurationTimer = durationTicks;
                            AdorableHamsterPets.LOGGER.debug("Hamster {} entering QUIESCENT_SITTING for {} ticks.", this.getId(), durationTicks);
                        }
                    }
                    break;

                case QUIESCENT_SITTING:
                    if (!this.isSitting() || !canInitiateDrowsiness) {
                        // Interrupted (stood up, conditions changed, etc.)
                        resetSleepSequence("Quiescent sitting interrupted: no longer sitting or conditions unfavorable.");
                        break;
                    }
                    if (this.quiescentSitDurationTimer > 0) {
                        this.quiescentSitDurationTimer--;
                    } else {
                        // Timer expired, attempt to move to Drifting Off
                        this.setDozingPhase(DozingPhase.DRIFTING_OFF);
                        this.driftingOffTimer = 90 * 20; // 90 seconds for the animation
                        // Animation controller will pick up anim_hamster_drifting_off
                        AdorableHamsterPets.LOGGER.debug("Hamster {} entering DRIFTING_OFF for {} ticks.", this.getId(), this.driftingOffTimer);
                    }
                    break;

                case DRIFTING_OFF:
                    if (!canSustainSlumber) { // Check sustain conditions
                        resetSleepSequence("Drifting off interrupted: conditions for slumber no longer met.");
                        break;
                    }
                    if (this.driftingOffTimer > 0) {
                        this.driftingOffTimer--;
                    } else {
                        // Drifting off animation completed
                        this.setDozingPhase(DozingPhase.SETTLING_INTO_SLUMBER);
                        // Randomly select a settle animation and corresponding deep sleep pose
                        int choice = this.random.nextInt(3);
                        String settleAnimId;
                        String deepSleepAnimIdForTracker = switch (choice) {
                            case 0 -> {
                                settleAnimId = "anim_hamster_settle_sleep1";
                                yield "anim_hamster_sleep_pose1";
                            }
                            case 1 -> {
                                settleAnimId = "anim_hamster_settle_sleep2";
                                yield "anim_hamster_sleep_pose2";
                            }
                            default -> {
                                settleAnimId = "anim_hamster_settle_sleep3";
                                yield "anim_hamster_sleep_pose3";
                            }
                        }; // Temporary variable for clarity
                        this.dataTracker.set(CURRENT_DEEP_SLEEP_ANIM_ID, deepSleepAnimIdForTracker); // Set DataTracker
                        this.triggerAnimOnServer("mainController", settleAnimId);
                        this.settleSleepAnimationCooldown = 20;

                        // Trigger "swish" and set "thump" sound effect timer
                        triggerSettleEffects(0.22f, 5, 0.24f);

                        AdorableHamsterPets.LOGGER.debug("Hamster {} entering SETTLING_INTO_SLUMBER, triggering {}, target deep sleep anim ID: {}.", this.getId(), settleAnimId, deepSleepAnimIdForTracker);
                    }
                    break;

                case SETTLING_INTO_SLUMBER:
                    if (!canSustainSlumber) {
                        resetSleepSequence("Settling into slumber interrupted: conditions for slumber no longer met.");
                        break;
                    }
                    if (this.settleSleepAnimationCooldown > 0) {
                        this.settleSleepAnimationCooldown--;
                    } else {
                        // Settle animation finished, transition to deep sleep
                        this.setDozingPhase(DozingPhase.DEEP_SLEEP);
                        // Animation controller will now loop currentDeepSleepAnimationId
                        AdorableHamsterPets.LOGGER.debug("Hamster {} entering DEEP_SLEEP, playing {}.", this.getId(), this.dataTracker.get(CURRENT_DEEP_SLEEP_ANIM_ID));
                    }
                    break;

                case DEEP_SLEEP:
                    if (!canSustainSlumber) {
                        triggerWakeUpFromSleepAnimation(false); // Trigger natural wakeup animation and sound
                        resetSleepSequence("Deep sleep interrupted: conditions for slumber no longer met.");
                    }
                    // Hamster remains in deep sleep, looping animation, until interrupted
                    break;
            }
        }

        // Call super.tick() *after* processing thrown state and timers
        super.tick();

        // --- Dynamic Navigation Swapping ---
        if (!this.getWorld().isClient() && this.age % 20 == 0) { // Check once per second
            this.updateNavigation();
        }

        // --- Apply extra gravity during sulking jump ---
        // This runs on the server to ensure physics are authoritative.
        if (!this.getWorld().isClient()) {
            // If the hamster is sulking, not on the ground, and is currently falling (negative Y velocity)
            if (this.isSulking() && !this.isOnGround() && this.getVelocity().y < 0) {
                // Apply an extra downward force to make it fall faster.
                // -0.08 is the standard gravity value, so adding it again effectively doubles it.
                this.setVelocity(this.getVelocity().add(0.0, -1.0, 0.0));
                this.velocityDirty = true; // Ensure client sees the change
            }
        }

        // --- 4. Server-Side Logic ---
        World world = this.getWorld();
        if (!world.isClient()) {

            // --- Circadian Chaos Wake-Up Logic ---
            if (Configs.AHP.circadianChaos.get() &&
                    this.isSleeping() &&
                    this.getLinkedBedPos().isPresent() &&
                    this.napInBedDurationTimer == 0)
            {
                wakeUpFromBed(false); // Natural wake-up
            }

            // --- Day/Night Cycle Wake-Up Logic ---
            if (!Configs.AHP.circadianChaos.get() && this.isSleeping() && this.getLinkedBedPos().isPresent()) {
                boolean isSleepTime = Configs.AHP.sleepDuringDay.get() ? world.isDay() : world.isNight();
                if (!isSleepTime) {
                    // If it's wake-up time, and delay timer has not yet been started
                    if (this.wakeUpFromBedDelay == 0 && this.goToBedCooldown == 0) {
                        this.wakeUpFromBedDelay = this.random.nextBetween(5, 60); // Set the random 0.25s to 3s delay
                    }
                } else {
                    // If time flips back to sleep time while the timer is counting down, cancel the wake-up.
                    this.wakeUpFromBedDelay = 0;
                }
            }
            // Check if the wake-up timer has just expired
            if (this.wakeUpFromBedDelay == 1) {
                this.wakeUpFromBed(false); // Natural wake-up
            }

            // --- 4a. Suffocation Self-Rescue Logic ---
            if (this.suffocationGracePeriod > 0 && this.isInsideWall()) {
                // Search for a safe spot directly above the hamster
                for (int i = 1; i <= 5; i++) {
                    BlockPos checkPos = this.getBlockPos().up(i);
                    if (isSafeSpawnLocation(checkPos, world)) {
                        // Found a safe spot, teleport the hamster
                        this.teleport(checkPos.getX() + 0.5, checkPos.getY(), checkPos.getZ() + 0.5, false);
                        AdorableHamsterPets.LOGGER.debug("[HamsterSelfRescue] Hamster {} teleported from {} to safe location {}.",
                                this.getId(), this.getBlockPos().down(i), checkPos);
                        this.suffocationGracePeriod = 0; // End the grace period
                        break; // Stop searching
                    }
                }
            }

            // --- 4b. Ejection Logic ---
            if (this.ejectionCheckCooldown <= 0) {
                this.ejectionCheckCooldown = 100; // Reset cooldown (check every 5 seconds)
                boolean ejectedItem = false; // Flag to only eject one item per cycle

                for (int i = 0; i < this.items.size(); ++i) {
                    ItemStack stack = this.items.get(i);
                    if (!stack.isEmpty() && this.isItemDisallowed(stack)) {
                        AdorableHamsterPets.LOGGER.warn("[HamsterTick {}] Ejecting disallowed item {} from slot {}.", this.getId(), stack.getItem(), i);
                        // Drop the item at the hamster's feet
                        ItemScatterer.spawn(world, this.getX(), this.getY(), this.getZ(), stack.copy());
                        // Remove it from the inventory
                        this.items.set(i, ItemStack.EMPTY);
                        // Mark dirty and update visuals
                        this.markDirty(); // This calls updateCheekTrackers
                        ejectedItem = true;
                        break; // Eject only one item per check cycle
                    }
                }
            }

            // --- 4c. Auto Eating Logic ---
            // This section now handles the multi-stage auto-eating: considering, eating, healing.
            // --- Stage 1: Check Eligibility and Start "Considering" ---
            if (this.isTamed() && this.getHealth() < this.getMaxHealth() &&
                    !this.isAutoEating() && !this.isConsideringAutoEat() && // Not already eating or considering
                    this.autoEatCooldownTicks == 0 &&
                    !this.isThrown() && !this.isKnockedOut())
            {
                // Check inventory for eligible food
                for (int i = 0; i < this.items.size(); ++i) {
                    ItemStack stack = this.items.get(i);
                    if (!stack.isEmpty() && ConfigDataCache.isAutoHealFood(stack)) {
                        // Found food, start "considering" phase
                        setHamsterFlag(CONSIDERING_AUTO_EAT_FLAG, true);
                        this.preAutoEatDelayTicks = 40; // 2-second delay
                        AdorableHamsterPets.LOGGER.trace("[HamsterTick {}] Eligible to auto-eat. Starting 2s pre-eat delay.", this.getId());
                        break; // Stop searching for food once consideration starts
                    }
                }
            }

            // --- Stage 2: Process "Considering" Delay & Start Actual Eating ---
            if (this.isConsideringAutoEat() && this.preAutoEatDelayTicks == 0) {
                setHamsterFlag(CONSIDERING_AUTO_EAT_FLAG, false); // No longer just considering

                // Re-check for food in case it was removed during the delay
                boolean foodStillAvailable = false;
                ItemStack foodToEat = ItemStack.EMPTY;
                int foodSlot = -1;

                for (int i = 0; i < this.items.size(); ++i) {
                    ItemStack stack = this.items.get(i);
                    if (!stack.isEmpty() && ConfigDataCache.isAutoHealFood(stack)) {
                        foodStillAvailable = true;
                        foodToEat = stack;
                        foodSlot = i;
                        break;
                    }
                }

                if (foodStillAvailable) {
                    AdorableHamsterPets.LOGGER.trace("[HamsterTick {}] Pre-eat delay finished. Starting auto-eat on {} from slot {}", this.getId(), foodToEat.getItem(), foodSlot);
                    this.isAutoEating = true; // Use the boolean flag for the eating animation state
                    this.autoEatProgressTicks = 60; // 3 seconds eating time

                    this.playSound(SoundEvents.ENTITY_GENERIC_EAT, 0.7F, 1.3F);
                    if (world instanceof ServerWorld serverWorld) {
                        serverWorld.spawnParticles(
                                new ItemStackParticleEffect(ParticleTypes.ITEM, foodToEat.split(1)), // Consume one for particles
                                this.getX() + this.random.nextGaussian() * 0.1,
                                this.getY() + this.getHeight() / 2.0 + this.random.nextGaussian() * 0.1,
                                this.getZ() + this.random.nextGaussian() * 0.1,
                                5, 0.1, 0.1, 0.1, 0.02
                        );
                    }
                    if (foodToEat.isEmpty()) { // If split made it empty
                        this.items.set(foodSlot, ItemStack.EMPTY);
                    }
                    this.updateCheekTrackers();
                } else {
                    AdorableHamsterPets.LOGGER.trace("[HamsterTick {}] Pre-eat delay finished, but food no longer available.", this.getId());
                    // No food, so don't proceed to eating state. Cooldowns remain 0.
                }
            }

            // --- Stage 3: Apply Healing After Eating Progress Finishes ---
            if (this.isAutoEating() && this.autoEatProgressTicks == 0) {
                this.heal(Configs.AHP.hamsterFoodMixHealing.get());
                this.autoEatCooldownTicks = 60; // Set main cooldown (3 seconds)
                this.isAutoEating = false; // Reset eating animation flag
                AdorableHamsterPets.LOGGER.trace("[HamsterTick {}] Auto-eat finished. Healed. Cooldown set to 60.", this.getId());

                if (this.getOwner() instanceof ServerPlayerEntity serverPlayerOwner) {
                    ModCriteria.HAMSTER_AUTO_FED.trigger(serverPlayerOwner, this);
                }
            }
            // --- End 4b. Auto Eating Logic ---

            // --- 4c. Handle Continuous Diamond Celebration Effects ---
            if (!this.getWorld().isClient()) {
                if (this.isCelebratingDiamond()) {
                    // Delayed Diamond Sparkle Sound
                    if (this.diamondSparkleSoundDelayTicks == 1) { // Play when delay reaches 1
                        SoundEvent sparkleSound = ModSounds.getRandomSoundFrom(ModSounds.DIAMOND_SPARKLE_SOUNDS, this.random);
                        if (sparkleSound != null) {
                            // Play sound at the ORE'S location
                            if (this.currentOreTarget != null) {
                                this.getWorld().playSound(null, this.currentOreTarget, sparkleSound, SoundCategory.NEUTRAL, 1.0F, 1.0F);
                            } else { // Fallback to hamster pos if ore target is somehow null
                                this.getWorld().playSound(null, this.getBlockPos(), sparkleSound, SoundCategory.NEUTRAL, 1.0F, 1.0F);
                            }
                        }
                    }

                    // Particle Spawning
                    if (this.celebrationParticleTicks > 0) {
                            ((ServerWorld)this.getWorld()).spawnParticles(
                                    ParticleTypes.COMPOSTER,        // 1. Particle Type
                                    this.getX(),                    // 2. Center X-coordinate
                                    this.getY() + 1.8,              // 3. Center Y-coordinate
                                    this.getZ(),                    // 4. Center Z-coordinate
                                    2,                              // 5. Count
                                    0.12,                           // 6. Delta X (Spread X)
                                    0.25,                           // 7. Delta Y (Spread Y)
                                    0.12,                           // 8. Delta Z (Spread Z)
                                    0.15                            // 9. Speed
                            );

                        if (this.currentOreTarget != null && this.random.nextInt(4) == 0) {
                            BlockPos particlePos = this.currentOreTarget.up(); // Spawn above the diamond ore
                            ((ServerWorld)this.getWorld()).spawnParticles(
                                    ParticleTypes.FIREWORK,         // 1. Particle Type
                                    particlePos.getX() + 0.5,       // 2. Center X-coordinate
                                    particlePos.getY() + 0.5,       // 3. Center Y-coordinate
                                    particlePos.getZ() + 0.5,       // 4. Center Z-coordinate
                                    1,                              // 5. Count
                                    0.2,                            // 6. Delta X (Spread X)
                                    0.35,                           // 7. Delta Y (Spread Y)
                                    0.2,                            // 8. Delta Z (Spread Z)
                                    0.003                           // 9. Speed
                            );
                        }
                    }

                    //  Begging Sounds
                    if (this.diamondCelebrationSoundTicks <= 0) {
                        SoundEvent celebrationSound = ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_BEG_SOUNDS, this.random);
                        if (celebrationSound != null) {
                            this.getWorld().playSound(null, this.getBlockPos(), celebrationSound, SoundCategory.NEUTRAL, 0.8F, this.getSoundPitch());
                        }
                        this.diamondCelebrationSoundTicks = 30;
                    }
                }
            }

            // --- 4d. Handle Continuous Sulking Effects ---
            if (this.isSulking()) {
                // Delayed Orchestra Hit
                if (this.sulkOrchestraHitDelayTicks == 1) { // Play when delay reaches 1 (was 10, now 1 after 9 ticks)
                    this.getWorld().playSound(null, this.getBlockPos(), ModSounds.ALARM_ORCHESTRA_HIT.get(), SoundCategory.NEUTRAL, 1.0F, 1.0F);
                }

                // Delayed Single Shocked Sound
                if (this.sulkShockedSoundDelayTicks == 1) { // Play when this timer reaches 1
                    this.getWorld().playSound(null, this.getBlockPos(), ModSounds.HAMSTER_SHOCKED.get(), SoundCategory.NEUTRAL, 1.0F, 1.0F);
                }


                // Angry Smoke Particles above Gold Ore
                if (this.sulkFailParticleTicks > 0 && this.currentOreTarget != null) {
                    if (this.random.nextInt(3) == 0) {
                        BlockPos particlePos = this.currentOreTarget.up();
                        ((ServerWorld)this.getWorld()).spawnParticles(
                                ParticleTypes.SMOKE,          // 1. Particle Type
                                particlePos.getX() + 0.5,     // 2. Center X-coordinate
                                particlePos.getY() + 0.5,     // 3. Center Y-coordinate
                                particlePos.getZ() + 0.5,     // 4. Center Z-coordinate
                                2,                            // 5. Count
                                0.3,                          // 6. Delta X (Spread X)
                                0.3,                          // 7. Delta Y (Spread Y)
                                0.3,                          // 8. Delta Z (Spread Z)
                                0.005                         // 9. Speed
                        );
                    }
                }

                // Black Entity Effect Particles on Hamster
                if (this.sulkEntityEffectTicks > 0) {
                    if (this.random.nextInt(5) == 0) { // Spawn periodically
                        // In 1.20.1, colored ENTITY_EFFECT particles are spawned by setting count to 0
                        // and using the delta parameters for RGB color.
                        ((ServerWorld)this.getWorld()).spawnParticles(
                                ParticleTypes.ENTITY_EFFECT,             // The particle type
                                this.getParticleX(0.3),        // Center X (preserves main spread)
                                this.getRandomBodyY(),                   // Center Y (preserves main spread)
                                this.getParticleZ(0.3),        // Center Z (preserves main spread)
                                0,                                       // Count = 0 enables color mode
                                0.3,                                     // Red component (0.0 to 1.0)
                                0.3,                                     // Green component
                                0.3,                                     // Blue component
                                1.0                                      // Speed parameter is used for brightness/intensity
                        );
                    }
                }
            }
        }

        // --- 5. Client-Side Logic ---
        // --- 5.1 Buff Particle Logic ---
        if (world.isClient && this.hasGreenBeanBuff()) {
            // Only spawn particles if the hamster is actually moving.
            if (this.getVelocity().horizontalLengthSquared() > 1.0E-6) {
                // --- Constants for Particle Physics ---
                final double backwardsSpeed = 1.7;
                final double scatterStrength = 0.025;
                final double downwardVelocity = 0.17;
                final double positionOffsetMultiplier = 1.4;

                // Spawn particles frequently, but not every single tick, to avoid being overwhelming.
                if (this.random.nextInt(2) == 0) {
                    for (int i = 0; i < 3; ++i) {
                        // 1. Calculate the base spawn position using the hamster's PREVIOUS tick's location.
                        Vec3d currentVelocity = this.getVelocity();
                        double baseX = this.prevX - (currentVelocity.x * positionOffsetMultiplier);
                        double baseY = this.prevY + (this.getHeight() / 2.0) - (currentVelocity.y * positionOffsetMultiplier);
                        double baseZ = this.prevZ - (currentVelocity.z * positionOffsetMultiplier);

                        // 2. Apply the random spread to the base position.
                        // This maintains spread relative to the calculated "previous" point.
                        double spawnX = baseX + (this.random.nextDouble() - 0.5) * (this.getWidth() * 0.8);
                        double spawnY = baseY + (this.random.nextDouble() - 0.5) * (this.getHeight() * 0.05);
                        double spawnZ = baseZ + (this.random.nextDouble() - 0.5) * (this.getWidth() * 0.8);

                        // 3. Calculate the particle's velocity for the "zoomies" effect.
                        Vec3d hamsterMovementVec = this.getVelocity();
                        Vec3d backwardsBaseVel = hamsterMovementVec.multiply(-1.0 * backwardsSpeed);
                        double finalVelX = backwardsBaseVel.x + (this.random.nextGaussian() * scatterStrength);
                        double finalVelY = backwardsBaseVel.y + (this.random.nextGaussian() * scatterStrength) - downwardVelocity;
                        double finalVelZ = backwardsBaseVel.z + (this.random.nextGaussian() * scatterStrength);

                        // 4. Add the particle to the world with the calculated position and velocity.
                        world.addParticle(ParticleTypes.CLOUD, spawnX, spawnY, spawnZ, finalVelX, finalVelY, finalVelZ);
                    }
                }
            }
        }

        // --- 5.2 Taunting Particle Logic ---
        if (this.isTaunting()) {
            // Only spawn particles occasionally
            if (this.random.nextInt(7) == 0) { // Spawn roughly 2.86 times per second
                // Spawn energetic "instant effect" particles randomly around the hamster
                for (int i = 0; i < 2; ++i) { // Spawn three particles each time for a noticeable effect
                    world.addParticle(ParticleTypes.INSTANT_EFFECT,
                            this.getParticleX(0.6), // Spawn on the body
                            this.getRandomBodyY(),
                            this.getParticleZ(0.6),
                            (this.random.nextDouble() - 0.5) * 0.5, // dx (energetic outward motion)
                            (this.random.nextDouble() - 0.5) * 0.5, // dy
                            (this.random.nextDouble() - 0.5) * 0.5  // dz
                    );
                }
            }
        }
        // --- End 5. Client-Side Logic ---

        // --- 6. Other Non-Movement Tick Logic ---
        if (this.isRefusingFood() && refuseTimer > 0) { if (--refuseTimer <= 0) this.setRefusingFood(false); }
        if (tamingCooldown > 0) tamingCooldown--;
        if (customLoveTimer > 0) customLoveTimer--;
        if (customLoveTimer <= 0 && this.isInLove()) this.setInLove(false);
    }

    // --- Override onDeath to Drop Inventory ---
    @Override
    public void onDeath(DamageSource source) {
        // --- 1. Drop Cheek Pouch Inventory ---
        World world = this.getWorld(); // Get the world instance
        if (!world.isClient()) {
            // Iterate through the items list and drop each non-empty stack
            for (ItemStack stack : this.items) {
                if (!stack.isEmpty()) {
                    // Use ItemScatterer to drop the stack at the hamster's position
                    ItemScatterer.spawn(world, this.getX(), this.getY(), this.getZ(), stack);
                }
            }
            // Clear the internal list after dropping
            this.items.clear();
            // Update cheek trackers one last time
            this.updateCheekTrackers();
        }

        // Call the superclass method AFTER dropping items
        super.onDeath(source);
    }

    // --- Animation ---
    /**
     * Registers the animation controllers for the HamsterEntity.
     * This method defines the main animation state machine, prioritizing states like
     * knocked out, thrown, and the detailed "Path to Slumber" sequence for tamed hamsters.
     * It also handles animations for wild hamster sleep, player-commanded sitting (including cleaning),
     * movement, begging, and defaults to an idle animation.
     *
     * <p>The "Path to Slumber" for tamed hamsters involves several phases:
     * <ul>
     *     <li>{@link DozingPhase#DRIFTING_OFF}: Plays {@code anim_hamster_drifting_off}. Its completion is
     *         managed by {@code driftingOffTimer} in the {@link #tick()} method.</li>
     *     <li>{@link DozingPhase#SETTLING_INTO_SLUMBER}: A short, 1-second {@code anim_hamster_sit_settle_sleepX}
     *         animation is triggered from {@link #tick()}. During this brief transition, this controller
     *         defaults to {@code SITTING_ANIM}. The {@code settleSleepAnimationCooldown} in {@link #tick()}
     *         manages the progression to {@code DEEP_SLEEP}.</li>
     *     <li>{@link DozingPhase#DEEP_SLEEP}: Loops the chosen {@code anim_hamster_sleep_poseX} (e.g.,
     *         {@code SLEEP_POSE1_ANIM}), determined by {@code currentDeepSleepAnimationId}.</li>
     * </ul>
     * Wild hamsters use a simpler sleep mechanism: {@code anim_hamster_wild_settle_sleep} is triggered,
     * followed by looping {@code SLEEP_POSE1_ANIM} if {@link #isSleeping()} is true.
     * </p>
     *
     * <p>Several animations like attack, crash, wakeup_from_ko, and the settle animations are registered
     * as triggerable and will interrupt the main looping state when fired via {@link #triggerAnimOnServer}.</p>
     *
     * @param controllers The registrar for adding animation controllers.
     */
    @Override
    public void registerControllers(AnimatableManager.ControllerRegistrar controllers) {
        controllers.add(new AnimationController<>(this, "mainController", 2, event -> {

            // --- Initial Setup ---
            DozingPhase currentDozingPhase = this.getDozingPhase();
            int personality = this.dataTracker.get(ANIMATION_PERSONALITY_ID);

            // --- Animation Logic for Shoulder-Mounted Hamsters ---
            if (this.isShoulderPet()) {
                ShoulderAnimationState shoulderState = ShoulderAnimationState.values()[this.dataTracker.get(SHOULDER_ANIMATION_STATE)];
                return switch (shoulderState) {
                    case SITTING -> {
                        if (getHamsterFlag(CLEANING_FLAG)) {
                            yield event.setAndContinue(CLEANING_ANIM);
                        }
                        yield event.setAndContinue(switch (personality) {
                            case 2 -> SITTING_POSE2_ANIM;
                            case 3 -> SITTING_POSE3_ANIM;
                            default -> SITTING_POSE1_ANIM;
                        });
                    }
                    case LAYING_DOWN -> // Location-Specific Logic
                            switch (this.shoulderLocation) {
                                case LEFT_SHOULDER -> event.setAndContinue(LAYING_DOWN_LEFT_SHOULDER_ANIM);
                                case HEAD -> event.setAndContinue(LAYING_DOWN_HEAD_ANIM);
                                default -> event.setAndContinue(LAYING_DOWN_RIGHT_SHOULDER_ANIM);
                            };
                    default -> { // STANDING
                        // "Sticky" logic: If already playing an idle anim, keep it. Otherwise, pick a new one.
                        RawAnimation current = event.getController().getCurrentRawAnimation();
                        if (current != null && (current.equals(IDLE1_ANIM) || current.equals(IDLE2_ANIM))) {
                            yield event.setAndContinue(current);
                        }
                        yield event.setAndContinue(this.random.nextBoolean() ? IDLE1_ANIM : IDLE2_ANIM);
                    }
                };
            }

            // --- Animation Logic for In-World Hamsters ---
            // --- Knocked Out State ---
            if (this.isKnockedOut()) {return event.setAndContinue(KNOCKED_OUT_ANIM);}
            // --- Sulking State ---
            if (this.isSulking()) {return event.setAndContinue(SULKING_ANIM);}
            // --- Thrown State ---
            if (this.isThrown()) {return event.setAndContinue(FLYING_ANIM);}
            // --- Diamond Stealing / Taunting State ---
            if (this.isTaunting()) return event.setAndContinue(DIAMOND_TAUNT_ANIM);
            // --- Seeking/Wanting to Seek Diamond/Ore State ---
            boolean isSeekingGoalActive = false;
            String activeGoalName = this.getActiveCustomGoalDebugName();
            if (activeGoalName.startsWith(HamsterSeekDiamondGoal.class.getSimpleName())) {
                isSeekingGoalActive = true;
            }
            if (isSeekingGoalActive) {
                double horizontalSpeedSquared = this.getVelocity().horizontalLengthSquared();
                if (horizontalSpeedSquared > 1.0E-6) { // Use a very small threshold to detect any movement
                    return event.setAndContinue(SEEKING_DIAMOND_ANIM); // Hamster is moving
                } else {
                    return event.setAndContinue(WANTS_TO_SEEK_DIAMOND_ANIM); // Hamster is not moving
                }
            }

            // --- Found Diamond Celebration ---
            if (this.isCelebratingDiamond()) {
                return event.setAndContinue(BEGGING_ANIM); // Reuse begging animation for celebration
            }

            // --- Sleeping States ---
            // 1. Tamed Sleep Sequence
            if (this.isTamed()) {
                switch (currentDozingPhase) {
                    case DRIFTING_OFF:
                        return event.setAndContinue(switch (personality) {
                            case 2 -> DRIFTING_OFF_POSE2_ANIM;
                            case 3 -> DRIFTING_OFF_POSE3_ANIM;
                            default -> DRIFTING_OFF_POSE1_ANIM;
                        });

                    case SETTLING_INTO_SLUMBER:
                        String targetDeepSleepId = this.dataTracker.get(CURRENT_DEEP_SLEEP_ANIM_ID);
                        if (!targetDeepSleepId.isEmpty()) {
                            RawAnimation targetDeepSleepAnim = switch (targetDeepSleepId) {
                                case "anim_hamster_sleep_pose1" -> SLEEP_POSE1_ANIM;
                                case "anim_hamster_sleep_pose2" -> SLEEP_POSE2_ANIM;
                                case "anim_hamster_sleep_pose3" -> SLEEP_POSE3_ANIM;
                                default -> SITTING_POSE1_ANIM; // Fallback
                            };
                            return event.setAndContinue(targetDeepSleepAnim);
                        } else if (this.isSitting()) {
                            // If interrupted, return to the correct personality-based sitting pose
                            return event.setAndContinue(switch (personality) {
                                case 2 -> SITTING_POSE2_ANIM;
                                case 3 -> SITTING_POSE3_ANIM;
                                default -> SITTING_POSE1_ANIM;
                            });
                        }
                        break;

                    case DEEP_SLEEP:
                        String deepSleepId = this.dataTracker.get(CURRENT_DEEP_SLEEP_ANIM_ID);
                        RawAnimation deepSleepAnimToPlay = switch (deepSleepId) {
                            case "anim_hamster_sleep_pose1" -> SLEEP_POSE1_ANIM;
                            case "anim_hamster_sleep_pose2" -> SLEEP_POSE2_ANIM;
                            case "anim_hamster_sleep_pose3" -> SLEEP_POSE3_ANIM;
                            // If interrupted, return to the correct personality-based sitting pose
                            default -> switch (personality) {
                                case 2 -> SITTING_POSE2_ANIM;
                                case 3 -> SITTING_POSE3_ANIM;
                                default -> SITTING_POSE1_ANIM;
                            };
                        };
                        return event.setAndContinue(deepSleepAnimToPlay);
                }
            }

            // 2. Wild Hamster Sleeping
            if (!this.isTamed() && this.isSleeping()) {
                // Read the target deep sleep animation from the DataTracker
                String deepSleepId = this.dataTracker.get(CURRENT_DEEP_SLEEP_ANIM_ID);
                RawAnimation deepSleepAnimToPlay = switch (deepSleepId) {
                    case "anim_hamster_sleep_pose2" -> SLEEP_POSE2_ANIM;
                    case "anim_hamster_sleep_pose3" -> SLEEP_POSE3_ANIM;
                    default -> SLEEP_POSE1_ANIM; // Fallback to pose 1
                };
                return event.setAndContinue(deepSleepAnimToPlay);
            }

            // --- Player-Commanded Sitting / Tamed Quiescent Sitting ---
            if (this.isSitting() && !this.isKnockedOut()) {
                if (getHamsterFlag(CLEANING_FLAG)) {
                    return event.setAndContinue(CLEANING_ANIM);
                } else {
                    // The logic to start cleaning lives in the tick() method.
                    // The animation controller only reacts to the state.
                    return event.setAndContinue(switch (personality) {
                        case 2 -> SITTING_POSE2_ANIM;
                        case 3 -> SITTING_POSE3_ANIM;
                        default -> SITTING_POSE1_ANIM;
                    });
                }
            }

            // --- Movement State ---
            double horizontalSpeedSquared = this.getVelocity().horizontalLengthSquared();
            if (horizontalSpeedSquared > 1.0E-6) { // Check if moving at all
                if (horizontalSpeedSquared > RUN_TO_SPRINT_THRESHOLD_SQUARED) {
                    return event.setAndContinue(SPRINTING_ANIM);
                } else if (horizontalSpeedSquared > WALK_TO_RUN_THRESHOLD_SQUARED) {
                    return event.setAndContinue(RUNNING_ANIM);
                } else {
                    return event.setAndContinue(WALKING_ANIM);
                }
            }

             // --- Begging State ---
            if (this.isBegging()) {
                 return event.setAndContinue(BEGGING_ANIM);
            }

            // --- Idle Looking Up State ---
             if (activeGoalName.equals(HamsterLookAtEntityGoal.class.getSimpleName())) {
                 return switch (this.dataTracker.get(CURRENT_LOOK_UP_ANIM_ID)) {
            case 2 -> event.setAndContinue(IDLE_LOOKING_UP2_ANIM);
            case 3 -> event.setAndContinue(IDLE_LOOKING_UP3_ANIM);
            default -> event.setAndContinue(IDLE_LOOKING_UP1_ANIM);
                 };
             }

            // --- Default Idle State ---
            // "Sticky" logic: If already playing an idle anim, keep it. Otherwise, pick a new one.
            RawAnimation current = event.getController().getCurrentRawAnimation();
            if (current != null && (current.equals(IDLE1_ANIM) || current.equals(IDLE2_ANIM))) {
                return event.setAndContinue(current);
            }
            return event.setAndContinue(this.random.nextBoolean() ? IDLE1_ANIM : IDLE2_ANIM);
            })
            .triggerableAnim("crash", CRASH_ANIM)
            .triggerableAnim("wakeup_from_ko", WAKE_UP_FROM_KO_ANIM)
            .triggerableAnim("stationary_headshake", STATIONARY_HEADSHAKE_ANIM)
            .triggerableAnim("moving_headshake", MOVING_HEADSHAKE_ANIM)
            .triggerableAnim("attack", ATTACK_ANIM)
            .triggerableAnim("sit1", SIT1_ANIM)
            .triggerableAnim("sit2", SIT2_ANIM)
            .triggerableAnim("sit3", SIT3_ANIM)
            .triggerableAnim("standup1", STANDUP1_ANIM)
            .triggerableAnim("standup2", STANDUP2_ANIM)
            .triggerableAnim("standup3", STANDUP3_ANIM)
            .triggerableAnim("wakeup1", WAKE_UP_1_ANIM)
            .triggerableAnim("wakeup2", WAKE_UP_2_ANIM)
            .triggerableAnim("wakeup3", WAKE_UP_3_ANIM)
            .triggerableAnim("anim_hamster_sit_settle_sleep1", SIT_SETTLE_SLEEP1_ANIM)
            .triggerableAnim("anim_hamster_sit_settle_sleep2", SIT_SETTLE_SLEEP2_ANIM)
            .triggerableAnim("anim_hamster_sit_settle_sleep3", SIT_SETTLE_SLEEP3_ANIM)
            .triggerableAnim("anim_hamster_stand_settle_sleep1", STAND_SETTLE_SLEEP1_ANIM)
            .triggerableAnim("anim_hamster_stand_settle_sleep2", STAND_SETTLE_SLEEP2_ANIM)
            .triggerableAnim("anim_hamster_stand_settle_sleep3", STAND_SETTLE_SLEEP3_ANIM)
            .triggerableAnim("anim_hamster_sulk", SULK_ANIM)
            .triggerableAnim("anim_hamster_diamond_pounce", DIAMOND_POUNCE_ANIM)
            .triggerableAnim("anim_hamster_celebrate_chase", CELEBRATE_CHASE_ANIM)

            // --- Handle Keyframe Particles ---
            .setParticleKeyframeHandler(event -> {
                // Sets a transient flag on the entity with the particle effect's ID.
                // The renderer polls this flag each frame to spawn particles on the client.
                this.particleEffectId = event.getKeyframeData().getEffect();
            })

            // --- Handle Keyframe Sounds ---
            .setSoundKeyframeHandler(event -> {
                // This just sets a flag. The renderer will handle it on the client.
                this.soundEffectId = event.getKeyframeData().getSound();
            })
        );
    }

    @Override
    public AnimatableInstanceCache getAnimatableInstanceCache() {
        return this.cache;
    }

    /**
     * Triggers a one-shot animation on the server, which is then synced to clients.
     * This method also schedules a follow-up task to stop the triggered animation after its
     * expected duration. This serves as a failsafe to prevent animations that were triggered
     * while the entity was off-screen from playing belatedly when the entity is rendered again.
     *
     * @param controllerName The name of the animation controller.
     * @param animName The internal name of the triggerable animation (e.g., "crash").
     */
    public void triggerAnimOnServer(String controllerName, String animName) {
        if (!this.getWorld().isClient()) { // Ensure we're on the server
            // --- 1. Immediately trigger the animation ---
            // Use the GeoAnimatable's built-in method for triggering server-side
            this.triggerAnim(controllerName, animName);
            AdorableHamsterPets.LOGGER.trace("[HamsterEntity {}] Triggered server-side animation: Controller='{}', Anim='{}'", this.getId(), controllerName, animName);

            // --- 2. Schedule the cancellation task ---
            Integer duration = TRIGGERABLE_ANIM_DURATIONS.get(animName);
            if (duration != null) {
                long executionTick = this.getWorld().getTime() + duration;
                // Lambda that calls stopTriggeredAnim for the specific animation.
                Runnable cancellationAction = () -> {
                    // On 1.20.1 stopTriggeredAnim is stopTriggeredAnimation
                    this.stopTriggeredAnimation(controllerName, animName);
                    AdorableHamsterPets.LOGGER.trace("[HamsterEntity {}] Executed scheduled stop for animation: '{}'", this.getId(), animName);
                };
                scheduledTasks.add(new ScheduledTask(executionTick, animName, cancellationAction));
                AdorableHamsterPets.LOGGER.trace("[HamsterEntity {}] Scheduled stop for animation '{}' in {} ticks (at tick {}).", this.getId(), animName, duration, executionTick);
            } else {
                AdorableHamsterPets.LOGGER.warn("[HamsterEntity {}] No duration found for triggerable animation '{}'. Cancellation not scheduled.", this.getId(), animName);
            }
        }
    }



    /* ──────────────────────────────────────────────────────────────────────────────
     *                           5. Protected Methods
     * ────────────────────────────────────────────────────────────────────────────*/

    // --- Data Tracker Initialization ---
    @Override
    protected void initDataTracker() {
        super.initDataTracker();
        this.dataTracker.startTracking(HAMSTER_FLAGS, 0);
        this.dataTracker.startTracking(VARIANT, 0);
        this.dataTracker.startTracking(PINK_PETAL_TYPE, 0);
        this.dataTracker.startTracking(DOZING_PHASE, DozingPhase.NONE.ordinal());
        this.dataTracker.startTracking(CURRENT_DEEP_SLEEP_ANIM_ID, "");
        this.dataTracker.startTracking(ACTIVE_CUSTOM_GOAL_NAME_DEBUG, "None");
        this.dataTracker.startTracking(ANIMATION_PERSONALITY_ID, 1);
        this.dataTracker.startTracking(STEAL_DURATION_TIMER, 0);
        this.dataTracker.startTracking(STOLEN_ITEM_STACK, ItemStack.EMPTY);
        this.dataTracker.startTracking(GREEN_BEAN_BUFF_DURATION, 0L);
        this.dataTracker.startTracking(CURRENT_LOOK_UP_ANIM_ID, 1);
        this.dataTracker.startTracking(SHOULDER_ANIMATION_STATE, ShoulderAnimationState.STANDING.ordinal());
    }

    // --- AI Goals ---
    @Override
    protected void initGoals() {
        AdorableHamsterPets.LOGGER.trace("[AI Init {} Tick {}] Initializing goals. Current State: isSleeping={}, isSittingPose={}",
                this.getId(), this.getWorld().isClient ? "ClientTick?" : this.getWorld().getTime(), this.isSleeping(), this.isInSittingPose());
        // --- 1. Initialize Goals ---
        this.goalSelector.add(0, new SwimGoal(this));
        this.goalSelector.add(1, new HamsterSeekDiamondGoal(this));
        this.goalSelector.add(1, new HamsterStealDiamondGoal(this));
        this.goalSelector.add(2, new HamsterGoToBedAndSleepGoal(this));
        this.goalSelector.add(2, new HamsterMeleeAttackGoal(this, 1.5D, true));
        this.goalSelector.add(3, new HamsterMateGoal(this, 0.75D));
        this.goalSelector.add(4, new HamsterFollowOwnerGoal(this, 1.0D, 4.0F, 16.0F));
        this.goalSelector.add(5, new HamsterFleeGoal<>(this, LivingEntity.class, 8.0F, 0.75D, 1.5D));
        this.goalSelector.add(6, new HamsterTemptGoal(this, 1.0D, false));
        this.goalSelector.add(7, new HamsterSitGoal(this));
        this.goalSelector.add(8, new HamsterSleepGoal(this));
        this.goalSelector.add(9, new HamsterWanderAroundFarGoal(this, 0.75D));
        this.goalSelector.add(10, new HamsterLookAtEntityGoal(this, PlayerEntity.class, 2.0F, 0.15F));
        this.goalSelector.add(11, new HamsterLookAroundGoal(this));

        // --- Target Selector Goals ---
        this.targetSelector.add(1, new TrackOwnerAttackerGoal(this));
        this.targetSelector.add(2, new AttackWithOwnerGoal(this));
        this.targetSelector.add(3, new RevengeGoal(this).setGroupRevenge());
        // --- End 1. Initialize Goals ---
        AdorableHamsterPets.LOGGER.trace("[AI Init {} Tick {}] Finished initializing goals.",
                this.getId(), this.getWorld().isClient ? "ClientTick?" : this.getWorld().getTime());
    }

    // --- Prevent walking over un-linked Hamster Beds ---
    @Override
    protected EntityNavigation createNavigation(World world) {
        if (Configs.AHP.avoidUnlinkedBeds) {
            return new HamsterNavigation(this, world);
        } else {
            return new MobNavigation(this, world);
        }
    }

    // --- Retaliation Against Other Pets Prevention ---
    /**
    * This method is overridden to prevent the hamster from targeting (e.g., retaliating against)
    * other pets owned by its own owner.
    */
    @Override
    public void setTarget(@Nullable LivingEntity target) {
        if (target == null) {
            super.setTarget(null);
            return;
        }

        // --- 1. Check if Tamed and Has Owner ---
        if (this.isTamed() && this.getOwner() != null) {
            LivingEntity owner = this.getOwner();
            UUID ownerUuid = owner.getUuid();

            boolean preventTargeting = false;

            // Check TameableEntity
            if (target instanceof TameableEntity tameablePet) {
                UUID petOwnerUuid = tameablePet.getOwnerUuid();
                if (petOwnerUuid != null && petOwnerUuid.equals(ownerUuid) && tameablePet != this) {
                    // AdorableHamsterPets.LOGGER.debug("[setTarget] Proposed target is a TameableEntity owned by the same player. Preventing targeting.");
                    preventTargeting = true;
                }
            }
            // Check AbstractHorseEntity
            else if (target instanceof net.minecraft.entity.passive.AbstractHorseEntity horsePet) {
                Entity horseOwnerEntity = horsePet.getOwner();
                if (horseOwnerEntity != null && horseOwnerEntity.getUuid().equals(ownerUuid)) {
                    // AdorableHamsterPets.LOGGER.debug("[setTarget] Proposed target is an AbstractHorseEntity owned by the same player. Preventing targeting.");
                    preventTargeting = true;
                }
            }
            // General Ownable Check (fallback)
            else if (target instanceof Ownable ownableFallback) {
                Entity fallbackOwnerEntity = ownableFallback.getOwner();
                if (fallbackOwnerEntity != null && fallbackOwnerEntity.getUuid().equals(ownerUuid) && ownableFallback != this) {
                    // AdorableHamsterPets.LOGGER.debug("[setTarget] Proposed target is an Ownable (fallback) owned by the same player. Preventing targeting.");
                    preventTargeting = true;
                }
            }

            if (preventTargeting) {
                super.setTarget(null);
                return;
            }
        }

        // --- 3. Default Behavior ---
        super.setTarget(target);
    }

    // --- Sounds / Effects ---
    /**
     * Initiates the sound and particle effects for when a hamster settles into its bed.
     * This is called by the AI goal when the hamster's state officially changes to sleeping in the bed.
     */
    public void startBedSleepEffects() {
        if (this.getWorld().isClient()) return;

        // --- 1. Spawn the first burst of particles immediately ---
        this.getLinkedBedPos().ifPresent(globalPos -> {
            if (this.getWorld().getRegistryKey() == globalPos.getDimension()) {
                BlockPos bedPos = globalPos.getPos();
                BlockState bedState = this.getWorld().getBlockState(bedPos);
                ((ServerWorld)this.getWorld()).spawnParticles(ModParticles.getForVariant(bedState.get(HamsterBedBlock.WOOD_VARIANT)),
                        bedPos.getX() + 0.5, bedPos.getY() + 0.3, bedPos.getZ() + 0.5,
                        70, 0.2, 0.5, 0.2, 1);
            }
        });

        // --- 2. Set the timer for the remaining bursts ---
        this.bedLeafParticleTicks = 4;

        // --- 3. Play Sounds ---
        SoundEvent rustleSound = ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_BED_LEAVES_RUSTLE_SOUNDS, this.random);
        if (rustleSound != null) {
            this.getWorld().playSound(null, this.getBlockPos(), rustleSound, SoundCategory.NEUTRAL, 0.5f, 1.0f);
        }
        this.getWorld().playSound(null, this.getBlockPos(), ModSounds.HAMSTER_THUMP.get(), SoundCategory.NEUTRAL, 1.0f, 1.0f);

        // --- Trigger Advancement ---
        if (this.getOwner() instanceof ServerPlayerEntity serverPlayerOwner) {
            ModCriteria.HAMSTER_SLEPT_IN_BED.trigger(serverPlayerOwner);
        }
    }

    @Override
    protected SoundEvent getAmbientSound() {
        // --- 0. Knocked Out Check (Silence) ---
        if (this.isKnockedOut()) {
            return null; // Knocked out hamsters make no ambient sounds
        }
        // --- 1. Begging/Taunting Sounds ---
        if (this.isBegging() || this.isTaunting()) {
            return getRandomSoundFrom(ModSounds.HAMSTER_BEG_SOUNDS, this.random);
        }
        // --- 2. Sleep Sounds ---
        boolean playSleepSounds = false;
        if (this.isTamed()) {
            DozingPhase phase = this.getDozingPhase();
            // Play sleep sounds if drifting, settling, or in deep sleep
            if (phase == DozingPhase.DRIFTING_OFF || phase == DozingPhase.SETTLING_INTO_SLUMBER || phase == DozingPhase.DEEP_SLEEP) {
                playSleepSounds = true;
            }
        } else { // Wild hamster
            if (this.isSleeping()) { // Checks the IS_SLEEPING DataTracker for wild hamsters
                playSleepSounds = true;
            }
        }
        if (playSleepSounds) {
            return getRandomSoundFrom(ModSounds.HAMSTER_SLEEP_SOUNDS, this.random);
        }
        // --- 3. Idle Sounds (Default) ---
        return getRandomSoundFrom(ModSounds.HAMSTER_IDLE_SOUNDS, this.random);
    }

    @Override
    public void playAmbientSound() {
        SoundEvent soundEvent = this.getAmbientSound();
        // Check if the selected sound is a begging sound
        if (soundEvent != null && Arrays.asList(ModSounds.HAMSTER_BEG_SOUNDS).contains(soundEvent)) {
            // If it's a begging sound, play it with lower volume
            this.playSound(soundEvent, 0.8F, this.getSoundPitch());
        } else {
            // For all other sounds, use the default behavior
            super.playAmbientSound();
        }
    }

    @Override protected SoundEvent getHurtSound(DamageSource source) { return getRandomSoundFrom(ModSounds.HAMSTER_HURT_SOUNDS, this.random); }

    @Override protected SoundEvent getDeathSound() { return getRandomSoundFrom(ModSounds.HAMSTER_DEATH_SOUNDS, this.random); }

    @Override
    protected void playStepSound(BlockPos pos, BlockState state) {
        if (this.getWorld().isClient()) {
            return; // Server-side only
        }
        // Query the tracker to see if any player is rendering this hamster
        if (!HamsterRenderTracker.isBeingRendered(this.getId())) {
            try {
                BlockSoundGroup group = state.getSoundGroup();
                float volume = state.isOf(Blocks.GRAVEL)
                        ? (DEFAULT_FOOTSTEP_VOLUME * GRAVEL_VOLUME_MODIFIER)
                        : DEFAULT_FOOTSTEP_VOLUME;
                this.playSound(group.getStepSound(), volume, group.getPitch() * 1.5F);
            } catch (Exception ex) {
                AdorableHamsterPets.LOGGER.warn("Error playing fallback step sound", ex);
            }
        }
    }

    protected boolean canHitEntity(Entity entity) {
        // --- 1. Check if Entity Can Be Hit ---
        // Allow hitting armor stands specifically
        if (entity instanceof net.minecraft.entity.decoration.ArmorStandEntity) {
            return !entity.isSpectator(); // Can hit non-spectator armor stands
        }

        // Original logic for other entities
        if (!entity.isSpectator() && entity.isAlive() && entity.canHit()) {
            Entity owner = this.getOwner();
            // Prevent hitting self or owner or entities owner is riding
            return entity != this && (owner == null || !owner.isConnectedThroughVehicle(entity));
        }
        return false;
    }

    @Nullable
    @Override
    public EntityData initialize(ServerWorldAccess world, LocalDifficulty difficulty, SpawnReason spawnReason, @Nullable EntityData entityData, @Nullable NbtCompound nbt) {
        AdorableHamsterPets.LOGGER.debug("[AHP Spawn Debug] HamsterEntity.initialize called. SpawnReason: {}", spawnReason);

        // --- Assign Animation Personality ID ---
        if (!world.isClient()) {
            int personalityId = this.random.nextBetween(1, 3);
            this.dataTracker.set(ANIMATION_PERSONALITY_ID, personalityId);
            AdorableHamsterPets.LOGGER.trace("[INITIALIZE] Hamster ID {}: Assigned Personality ID {}", this.getId(), personalityId);
        }

        // Apply biome variants for natural spawns, spawn eggs, AND chunk generation
        if (spawnReason == SpawnReason.NATURAL || spawnReason == SpawnReason.SPAWN_EGG || spawnReason == SpawnReason.CHUNK_GENERATION) {
            RegistryEntry<Biome> biomeEntry = world.getBiome(this.getBlockPos());
            String biomeKeyStr = biomeEntry.getKey().map(key -> key.getValue().toString()).orElse("UNKNOWN");
            AdorableHamsterPets.LOGGER.trace("[HamsterInit] SpawnReason: {}, BiomeKey: {}", spawnReason, biomeKeyStr);

            HamsterVariant chosenVariant = determineVariantForBiome(biomeEntry, this.random);
            this.setVariant(chosenVariant.getId());
            AdorableHamsterPets.LOGGER.trace("[HamsterInit] Assigned variant: {}", chosenVariant.name());

        } else {
            // Fallback for other spawns (command, breeding, structure, etc.)
            int randomVariantId = this.random.nextInt(HamsterVariant.values().length);
            this.setVariant(randomVariantId);
            AdorableHamsterPets.LOGGER.trace("[HamsterInit] SpawnReason: {}, Assigned random variant: {}",
                    spawnReason, HamsterVariant.byId(randomVariantId).name());
        }

        // --- Apply Configured Health on Spawn ---
        // This ensures the entity instance uses the live config value, overriding any
        // stale value that might have been baked in during static attribute registration.
        if (!this.isTamed()) {
            this.getAttributeInstance(EntityAttributes.GENERIC_MAX_HEALTH).setBaseValue(Configs.AHP.wildMaxHealth.get());
            this.setHealth(this.getMaxHealth()); // Set current health to the new max
        }

        // Always update cheek trackers on initialization
        this.updateCheekTrackers();

        // Call and return the super method's result with the added nbt parameter for 1.20.1
        return super.initialize(world, difficulty, spawnReason, entityData, nbt);
    }

    @Override
    protected BodyControl createBodyControl() {
        return new HamsterBodyControl(this);
    }



    /* ──────────────────────────────────────────────────────────────────────────────
     *                       6. Private Helper Methods
     * ────────────────────────────────────────────────────────────────────────────*/

    /**
     * Plays a faint impact sound for players who are too far away to hear the standard sound (16 blocks)
     * but close enough that they should still hear *something* (50 blocks).
     * The volume is dynamically scaled based on distance: 0.18 at 16 blocks down to 0.10 at 50 blocks.
     *
     * @param sound The sound event to play.
     * @param pitch The pitch at which to play the sound.
     */
    private void broadcastDistantImpact(SoundEvent sound, float pitch) {
        if (this.getWorld().isClient()) return;

        double impactX = this.getX();
        double impactY = this.getY();
        double impactZ = this.getZ();

        for (ServerPlayerEntity player : ((ServerWorld) this.getWorld()).getPlayers()) {
            double distSq = player.squaredDistanceTo(impactX, impactY, impactZ);

            if (distSq > 256 && distSq <= 2500) {
                double distance = Math.sqrt(distSq);

                float volume = 0.18F - 0.10F * ((float) (distance - 16.0) / 34.0F);

                // Play sound AT THE PLAYER'S LOCATION to ensure they hear it at the calculated volume,
                // bypassing vanilla's distance attenuation which would silence it.
                // Send packet using 1.20.1 channel
                ModPackets.CHANNEL.sendToPlayer(player, new ModPackets.PlayDistantSoundS2CPacket(sound.getId(), volume, pitch));
            }
        }
    }

    /**
     * Simulates the hamster's trajectory 1 second (20 ticks) into the future.
     * If an impact (block or entity) is predicted within that window, and the total
     * throw time will have been at least 1 second, it plays the "Incoming" sound
     * at the target location.
     */
    private void simulateTrajectoryAndCheckSound() {
        Vec3d simPos = this.getPos();
        Vec3d simVel = this.getVelocity();

        // Simulate up to 20 ticks ahead
        for (int i = 1; i <= 20; i++) {
            // Apply physics matching the actual tick logic
            if (!this.hasNoGravity()) {
                simVel = simVel.add(0.0, THROWN_GRAVITY, 0.0);
            }

            Vec3d nextPos = simPos.add(simVel);

            // 1. Block Collision Check
            HitResult blockHit = this.getWorld().raycast(new RaycastContext(
                    simPos,
                    nextPos,
                    RaycastContext.ShapeType.COLLIDER,
                    RaycastContext.FluidHandling.NONE,
                    this
            ));

            // 2. Entity Collision Check
            // We use the same logic as ProjectileUtil to check for entities along the path segment
            EntityHitResult entityHit = ProjectileUtil.getEntityCollision(
                    this.getWorld(),
                    this,
                    simPos,
                    nextPos,
                    this.getBoundingBox().stretch(simVel).expand(1.0),
                    this::canHitEntity
            );

            Vec3d impactPos = null;

            if (entityHit != null) {
                impactPos = entityHit.getPos();
            } else if (blockHit.getType() != HitResult.Type.MISS) {
                impactPos = blockHit.getPos();
            }

            if (impactPos != null) {
                // Collision predicted in 'i' ticks.
                // Only play sound if the TOTAL time (elapsed + future) is >= 20 ticks.
                if (this.throwTicks + i >= 20) {
                    this.getWorld().playSound(null, impactPos.x, impactPos.y, impactPos.z, ModSounds.HAMSTER_INCOMING.get(), SoundCategory.NEUTRAL, 1.0f, 1.0f);
                    AdorableHamsterPets.LOGGER.debug("Played Incoming sound at target: {}", impactPos);
                }
                // Mark as handled regardless of whether we played it (to prevent spamming checks for short throws)
                this.hasPlayedIncomingSound = true;
                return;
            }

            // Update simulation position for next tick
            simPos = nextPos;
        }
    }

    /**
     * A simple server-side task scheduler to handle delayed actions, primarily for animation cleanup.
     * When a triggerable animation is fired, a corresponding "stop" task is scheduled to run
     * after the animation's expected duration. This prevents animations that were triggered while
     * the entity was off-screen from playing belatedly when the entity is rendered again.
     */
    // --- Animation Cancellation Scheduler ---
    private record ScheduledTask(long executionTick, String animName, Runnable action) {}
    private final List<ScheduledTask> scheduledTasks = new ArrayList<>();

    private static final Map<String, Integer> TRIGGERABLE_ANIM_DURATIONS = new HashMap<>();
    static {
        // Durations are in ticks (Animation Length + small 3 tick buffer)
        TRIGGERABLE_ANIM_DURATIONS.put("crash", 18);
        TRIGGERABLE_ANIM_DURATIONS.put("wakeup_from_ko", 15);
        TRIGGERABLE_ANIM_DURATIONS.put("stationary_headshake", 25);
        TRIGGERABLE_ANIM_DURATIONS.put("moving_headshake", 25);
        TRIGGERABLE_ANIM_DURATIONS.put("attack", 23);
        TRIGGERABLE_ANIM_DURATIONS.put("sit1", 13);
        TRIGGERABLE_ANIM_DURATIONS.put("sit2", 13);
        TRIGGERABLE_ANIM_DURATIONS.put("sit3", 13);
        TRIGGERABLE_ANIM_DURATIONS.put("standup1", 13);
        TRIGGERABLE_ANIM_DURATIONS.put("standup2", 13);
        TRIGGERABLE_ANIM_DURATIONS.put("standup3", 13);
        TRIGGERABLE_ANIM_DURATIONS.put("wakeup1", 13);
        TRIGGERABLE_ANIM_DURATIONS.put("wakeup2", 13);
        TRIGGERABLE_ANIM_DURATIONS.put("wakeup3", 13);
        TRIGGERABLE_ANIM_DURATIONS.put("anim_hamster_sit_settle_sleep1", 23);
        TRIGGERABLE_ANIM_DURATIONS.put("anim_hamster_sit_settle_sleep2", 23);
        TRIGGERABLE_ANIM_DURATIONS.put("anim_hamster_sit_settle_sleep3", 23);
        TRIGGERABLE_ANIM_DURATIONS.put("anim_hamster_stand_settle_sleep1", 35);
        TRIGGERABLE_ANIM_DURATIONS.put("anim_hamster_stand_settle_sleep2", 35);
        TRIGGERABLE_ANIM_DURATIONS.put("anim_hamster_stand_settle_sleep3", 35);
        TRIGGERABLE_ANIM_DURATIONS.put("anim_hamster_sulk", 63);
        TRIGGERABLE_ANIM_DURATIONS.put("anim_hamster_diamond_pounce", 23);
        TRIGGERABLE_ANIM_DURATIONS.put("anim_hamster_celebrate_chase", 33);
    }


    /**
     * Gets the value of a specific boolean flag from the packed integer.
     * @param flag The bitmask of the flag to check (e.g., SLEEPING_FLAG).
     * @return True if the bit for the flag is set, false otherwise.
     */
    private boolean getHamsterFlag(int flag) {
        return (this.dataTracker.get(HAMSTER_FLAGS) & flag) != 0;
    }

    /**
     * Sets or clears a specific boolean flag in the packed integer.
     * @param flag The bitmask of the flag to modify (e.g., SLEEPING_FLAG).
     * @param value True to set the bit, false to clear it.
     */
    private void setHamsterFlag(int flag, boolean value) {
        int currentFlags = this.dataTracker.get(HAMSTER_FLAGS);
        if (value) {
            this.dataTracker.set(HAMSTER_FLAGS, currentFlags | flag);
        } else {
            this.dataTracker.set(HAMSTER_FLAGS, currentFlags & ~flag);
        }
    }

    /**
     * Checks if a given block position is a safe location for a hamster to spawn.
     * A location is safe if:
     * 1. The block below is not a hazard (checked via PathNodeType).
     * 2. The block below has a collision shape to stand on.
     * 3. The two blocks at the spawn position (for feet and head) have no collision shape *for this specific hamster*.
     *
     * @param pos   The block position to check.
     * @param world The world to check in.
     * @return True if the location is safe, false otherwise.
     */
    private boolean isSafeSpawnLocation(BlockPos pos, World world) {
        // --- 1. Check for a valid, non-hazardous floor ---
        BlockPos floorPos = pos.down();
        BlockState floorState = world.getBlockState(floorPos);

        // Use invoker to get the pathfinding node type of the floor.
        PathNodeType floorType = LandPathNodeMakerInvoker.callGetCommonNodeType(world, floorPos);
        if (HAZARDOUS_FLOOR_TYPES.contains(floorType)) {
            return false; // Floor is a known hazard.
        }

        // Ensure there is a physical surface to stand on (not just air or grass).
        if (floorState.getCollisionShape(world, floorPos).isEmpty()) {
            return false;
        }

        // --- 2. Check for empty body/head space using entity-specific context ---
        // The block is considered safe if it has no collision for the HamsterEntity.
        ShapeContext entityContext = ShapeContext.of(this);
        return world.getBlockState(pos).getCollisionShape(world, pos, entityContext).isEmpty() &&
                world.getBlockState(pos.up()).getCollisionShape(world, pos.up(), entityContext).isEmpty();
    }

    /**
     * Checks if the given item stack is disallowed in the hamster's inventory.
     * The logic follows a clear priority:
     * 1. If the item is on the `pouchAllowedItems` config list, it is ALWAYS allowed.
     * 2. If the item is on the `pouchDisallowedItems` or `pouchDisallowedTags` config lists, it is disallowed.
     * 3. If the item is a `BlockItem` (and wasn't on the allow list), it is disallowed.
     * 4. If the item is a `SpawnEggItem`, it is disallowed.
     *
     * @param stack The ItemStack to check.
     * @return True if the item is disallowed, false otherwise.
     */
    public boolean isItemDisallowed(ItemStack stack) {
        if (stack.isEmpty()) return false;

        // 1. Explicit ALLOW list has highest priority.
        if (ConfigDataCache.isPouchAllowed(stack)) {
            return false; // It's allowed, so it's NOT disallowed.
        }

        // 2. Check the new DISALLOW lists from config.
        if (ConfigDataCache.isPouchDisallowed(stack)) {
            return true;
        }

        // 3. Allow any item that is considered food.
        if (stack.getItem().isFood()) { // Use isFood() method for 1.20.1
            return false; // It's food, so it's NOT disallowed.
        }

        Item item = stack.getItem();

        // 4. Global block-item rule (a general disallow).
        if (item instanceof BlockItem) {
            // Any block is disallowed by default unless it was on the allowlist.
            return true;
        }

        // 5. Spawn eggs are always disallowed.
        return item instanceof SpawnEggItem;
    }

    private RegistryWrapper.WrapperLookup getRegistryLookup() {
        return this.getWorld().getRegistryManager();
    }

    private boolean tryTame(PlayerEntity player, ItemStack itemStack) {
        // --- 1. Taming Attempt ---
        if (!player.getAbilities().creativeMode) {
            itemStack.decrement(1);
        }

        // --- Use Config Value for Taming Chance ---
        final AhpConfig config = AdorableHamsterPets.CONFIG;
        int denominator = Math.max(1, config.tamingChanceDenominator.get()); // Ensure denominator is at least 1
        if (this.random.nextInt(denominator) == 0) {
            this.setOwnerUuid(player.getUuid());
            this.setTamed(true, true);
            this.navigation.stop();
            this.setSitting(false);
            this.setSleeping(false);
            this.setTarget(null);
            this.getWorld().sendEntityStatus(this, (byte) 7);

            // Play celebrate sound only on success
            SoundEvent celebrateSound = getRandomSoundFrom(HAMSTER_CELEBRATE_SOUNDS, this.random);
            this.getWorld().playSound(null, this.getBlockPos(), celebrateSound, SoundCategory.NEUTRAL, 0.7F, 1.0F);

            if (player instanceof ServerPlayerEntity serverPlayer) {
                Criteria.TAME_ANIMAL.trigger(serverPlayer, this);
            }

            return true;
        } else {
            this.getWorld().sendEntityStatus(this, (byte) 6);
            return false;
        }
    }

    // --- Check for Repeatable Foods ---
    /**
     * Checks if the hamster should refuse being fed the same item twice consecutively.
     * <p>
     * If a refusal occurs, this method also triggers a context-aware headshake animation:
     * {@code anim_hamster_moving_headshake} if the hamster is walking, or
     * {@code anim_hamster_stationary_headshake} if it is still.
     * <p>
     * An item is exempt from this check if it is included in the user-configurable
     * {@code repeatableFoods} list, managed by {@link ConfigDataCache#isRepeatableFood(ItemStack)}.
     *
     * @param currentStack The ItemStack the player is attempting to feed.
     * @param player The player performing the action.
     * @return {@code true} if the food was refused, {@code false} otherwise.
     */
    private boolean checkRepeatFoodRefusal(ItemStack currentStack, PlayerEntity player) {
        // --- 1. Check Repeat Food Refusal ---
        if (ConfigDataCache.isRepeatableFood(currentStack)) return false;

        if (!this.lastFoodItem.isEmpty() && ItemStack.areItemsEqual(this.lastFoodItem, currentStack)) {
            this.setRefusingFood(true);
            this.refuseTimer = REFUSE_FOOD_TIMER_TICKS;
            player.sendMessage(Text.translatable("message.adorablehamsterpets.food_refusal"), true);

            // --- Conditional Animation Trigger ---
            if (!this.getWorld().isClient()) {
                // Check if the hamster has significant horizontal velocity.
                boolean isMoving = this.getVelocity().horizontalLengthSquared() > 1.0E-6;
                if (isMoving) {
                    this.triggerAnimOnServer("mainController", "moving_headshake");
                } else {
                    this.triggerAnimOnServer("mainController", "stationary_headshake");
                }
            }
            return true;
        }
        return false;
    }

    /**
     * Attempts to feed the hamster, handling healing, breeding, buffs, and pouch unlocking.
     * This logic is driven by user-configurable item lists from {@link ConfigDataCache},
     * such as {@code standardFoods}, {@code buffFoods}, and {@code pouchUnlockFoods}.
     *
     * @param player The player feeding the hamster.
     * @param stack  The ItemStack being used.
     * @return {@code true} if a feeding action was successfully processed.
     */
    private boolean tryFeedingAsTamed(PlayerEntity player, ItemStack stack) {
        // --- 1. Initial Setup & Logging ---
        boolean isFood = ConfigDataCache.isStandardFood(stack);
        boolean isBuffItem = ConfigDataCache.isBuffFood(stack);
        boolean isPouchUnlockFood = ConfigDataCache.isPouchUnlockFood(stack);
        boolean canHeal = this.getHealth() < this.getMaxHealth();
        boolean readyToBreed = this.getBreedingAge() == 0 && !this.isInCustomLove(); // Check custom love timer
        World world = this.getWorld();
        final AhpConfig config = AdorableHamsterPets.CONFIG;
        boolean actionTaken = false; // Initialize return value

        AdorableHamsterPets.LOGGER.debug("[FeedAttempt {} Tick {}] Entering tryFeedingAsTamed. Item: {}, isFood={}, isBuff={}, canHeal={}, breedingAge={}, isInCustomLove={}, readyToBreed={}",
                this.getId(), world.getTime(), stack.getItem(), isFood, isBuffItem, canHeal, this.getBreedingAge(), this.isInCustomLove(), readyToBreed);

        // --- 2. Check for Pouch Unlock First (Highest Priority Feeding Action) ---
        if (isPouchUnlockFood && !getHamsterFlag(CHEEK_POUCH_UNLOCKED_FLAG)) {
            setHamsterFlag(CHEEK_POUCH_UNLOCKED_FLAG, true);
            AdorableHamsterPets.LOGGER.debug("Hamster {} cheek pouch unlocked by {}.", this.getId(), stack.getItem());
            if (player instanceof ServerPlayerEntity serverPlayer) {
                ModCriteria.CHEEK_POUCH_UNLOCKED.trigger(serverPlayer, this);
            }
            world.playSound(null, this.getBlockPos(), SoundEvents.ENTITY_PLAYER_LEVELUP, SoundCategory.NEUTRAL, 0.5f, 1.5f);
            if (!world.isClient) {
                ((ServerWorld) world).spawnParticles(
                        new ItemStackParticleEffect(ParticleTypes.ITEM, stack.copy()),
                        this.getX(), this.getBodyY(0.2D), this.getZ(),
                        25, 0.25D, 0.15D, 0.25D, 0.0D
                );
            }
            return true;
        }

        // --- 3. Check for Buff Food (Steamed Green Beans Logic) ---
        if (isBuffItem) {
            long currentTime = world.getTime();
            if (this.greenBeanBuffEndTick > currentTime) {
                // Still on cooldown
                long remainingTicks = this.greenBeanBuffEndTick - currentTime;
                long totalSecondsRemaining = remainingTicks / 20;
                long minutes = totalSecondsRemaining / 60;
                long seconds = totalSecondsRemaining % 60;
                player.sendMessage(Text.translatable("message.adorablehamsterpets.beans_cooldown", minutes, seconds).formatted(Formatting.RED), true);
                AdorableHamsterPets.LOGGER.debug("[FeedAttempt {} Tick {}] Buff item used, but on cooldown ({} ticks remaining). Returning false.", this.getId(), world.getTime(), remainingTicks);
                return false; // Action failed due to cooldown
            } else {
                // Apply Buffs
                int duration = config.greenBeanBuffDuration.get();
                int speedAmplifier = config.greenBeanBuffAmplifierSpeed.get();
                int strengthAmplifier = config.greenBeanBuffAmplifierStrength.get();
                int absorptionAmplifier = config.greenBeanBuffAmplifierAbsorption.get();
                int regenAmplifier = config.greenBeanBuffAmplifierRegen.get();

                // --- Set "zoomies" state ---
                this.zoomiesIsClockwise = this.random.nextBoolean();
                this.lastZoomiesAngle = 0.0; // Reset angle on new buff application

                // Set Status Effects
                this.addStatusEffect(new StatusEffectInstance(StatusEffects.SPEED, duration, speedAmplifier));
                this.addStatusEffect(new StatusEffectInstance(StatusEffects.STRENGTH, duration, strengthAmplifier));
                this.addStatusEffect(new StatusEffectInstance(StatusEffects.ABSORPTION, duration, absorptionAmplifier));
                this.addStatusEffect(new StatusEffectInstance(StatusEffects.REGENERATION, duration, regenAmplifier));

                // --- Set up zoomies state ---
                this.zoomiesIsClockwise = this.random.nextBoolean();
                this.zoomiesRadiusModifier = this.random.nextBetween(-2, 4);
                // Calculate and set the initial angle.
                double dx = this.getX() - player.getX();
                double dz = this.getZ() - player.getZ();
                this.lastZoomiesAngle = Math.atan2(dz, dx);

                // Play sound
                SoundEvent buffSound = getRandomSoundFrom(HAMSTER_CELEBRATE_SOUNDS, this.random);
                world.playSound(null, this.getBlockPos(), buffSound, SoundCategory.NEUTRAL, 1.0F, 1.0F);

                // Set cooldown and duration
                long buffDurationEnd = currentTime + config.greenBeanBuffDuration.get();
                this.getDataTracker().set(GREEN_BEAN_BUFF_DURATION, buffDurationEnd);
                this.greenBeanBuffEndTick = currentTime + config.steamedGreenBeansBuffCooldown.get();

                actionTaken = true; // Action was successful
                AdorableHamsterPets.LOGGER.trace("[FeedAttempt {} Tick {}] Applied buffs. Duration ends at tick {}. Cooldown ends at tick {}.", this.getId(), world.getTime(), buffDurationEnd, this.greenBeanBuffEndTick);

                // Trigger Fed Steamed Beans Criterion
                if (player instanceof ServerPlayerEntity serverPlayer) {
                    ModCriteria.FED_HAMSTER_STEAMED_BEANS.trigger(serverPlayer, this);
                }
            }
        }

        // --- 4. Handle Standard Food (Healing/Breeding) ---
        else if (ConfigDataCache.isStandardFood(stack)) {
            if (canHeal) {
                this.heal(config.standardFoodHealing.get());
                actionTaken = true;
                AdorableHamsterPets.LOGGER.debug("[FeedAttempt {}] Healed with standard food.", this.getId());
            } else if (readyToBreed) {
                this.setSitting(false, true);
                this.setCustomInLove(player);
                this.setInLove(true);
                actionTaken = true;
                AdorableHamsterPets.LOGGER.debug("[FeedAttempt {}] Entered love mode with standard food.", this.getId());
            }
        }
        // If no other action was taken, it wasn't a valid feeding interaction in this context.
        if (!actionTaken) {
            AdorableHamsterPets.LOGGER.debug("[FeedAttempt {} Tick {}] Item {} was not a valid food for any action.",
                    this.getId(), world.getTime(), stack.getItem());
        }
        return actionTaken;
    }

    // --- Tamed Sleep Sequence Helper Methods ---
    /**
     * Checks if the conditions are met for a tamed, sitting hamster to potentially start becoming drowsy.
     * Conditions: Daytime (if configured), no nearby hostile entities, on solid ground, not in love mode.
     * @return True if conditions are met, false otherwise.
     */
    @Unique
    private boolean checkConditionsForInitiatingDrowsiness() {
        if (!this.isSitting()) return false; // Must be player-commanded to sit

        World world = this.getWorld();
        if (Configs.AHP.requireDaytimeForTamedSleep && !world.isDay()) {
            return false; // Must be daytime if config requires it
        }
        if (this.isInLove()) return false; // Cannot sleep if in love mode

        // Check for nearby hostile entities
        double threatRadius = Configs.AHP.tamedSleepThreatDetectionRadiusBlocks.get();
        List<LivingEntity> nearbyHostiles = world.getEntitiesByClass(
                LivingEntity.class,
                this.getBoundingBox().expand(threatRadius),
                entity -> entity instanceof HostileEntity && entity.isAlive() && !entity.isSpectator()
        );
        return nearbyHostiles.isEmpty(); // No hostiles nearby
    }

    /**
     * Checks if the conditions are met to sustain any phase of the slumber sequence (Drifting, Settling, Deep Sleep).
     * These are generally the same as initiating, but crucially, the hamster must *remain* sitting.
     * @return True if conditions are met, false otherwise.
     */
    @Unique
    private boolean checkConditionsForSustainingSlumber() {
        // Includes all checks from initiating, plus ensures it's still in a sitting pose.
        // The IS_SITTING datatracker is the primary driver for player-commanded sitting.
        return this.isSitting() && checkConditionsForInitiatingDrowsiness();
    }

    /**
     * Resets the hamster's sleep sequence state to NONE and clears associated timers.
     * Called when the sleep sequence is interrupted.
     * @param reason A debug message explaining why the sequence was reset.
     */
    @Unique
    private void resetSleepSequence(String reason) {
        AdorableHamsterPets.LOGGER.debug("Hamster {} resetting sleep sequence: {}. Current phase was: {}", this.getId(), reason, this.getDozingPhase());
        this.setDozingPhase(DozingPhase.NONE);
        this.quiescentSitDurationTimer = 0;
        this.driftingOffTimer = 0;
        this.settleSleepAnimationCooldown = 0;
    }

    /**
     * Called when this entity is removed from the world.
     * This override ensures that any server-side tracking or client-side sounds
     * associated with this specific hamster instance are properly cleaned up to prevent memory leaks.
     */
    @Override
    public void onRemoved() {
        // --- 1. Call Superclass Method ---
        super.onRemoved();

        // --- 2. Clean Up Trackers ---
        if (!this.getWorld().isClient()) {
            net.dawson.adorablehamsterpets.util.HamsterRenderTracker.onEntityUnload(this.getId());
        }
    }
}
```

`HamsterVariant.java`
```java
package net.dawson.adorablehamsterpets.entity.custom;

// (Imports omitted to save token count)

public enum HamsterVariant {

    // --- BLACK Variants (Base + Overlays) ---
    BLACK(1, "black", null),
    BLACK_OVERLAY1(15, "black", "overlay1"),
    BLACK_OVERLAY2(16, "black", "overlay2"),
    BLACK_OVERLAY3(17, "black", "overlay3"),
    BLACK_OVERLAY4(18, "black", "overlay4"),
    BLACK_OVERLAY5(19, "black", "overlay5"),
    BLACK_OVERLAY6(20, "black", "overlay6"),
    BLACK_OVERLAY7(21, "black", "overlay7"),
    BLACK_OVERLAY8(22, "black", "overlay8"),

    // --- BLUE Variants (Base + Overlays) ---
    BLUE(55, "blue", null),
    BLUE_OVERLAY1(57, "blue", "overlay1"),
    BLUE_OVERLAY2(58, "blue", "overlay2"),
    BLUE_OVERLAY3(59, "blue", "overlay3"),
    BLUE_OVERLAY4(60, "blue", "overlay4"),
    BLUE_OVERLAY5(61, "blue", "overlay5"),
    BLUE_OVERLAY6(62, "blue", "overlay6"),
    BLUE_OVERLAY7(63, "blue", "overlay7"),
    BLUE_OVERLAY8(64, "blue", "overlay8"),

    // --- CHOCOLATE Variants (Base + Overlays) ---
    CHOCOLATE(2, "chocolate", null),
    CHOCOLATE_OVERLAY1(23, "chocolate", "overlay1"),
    CHOCOLATE_OVERLAY2(24, "chocolate", "overlay2"),
    CHOCOLATE_OVERLAY3(25, "chocolate", "overlay3"),
    CHOCOLATE_OVERLAY4(26, "chocolate", "overlay4"),
    CHOCOLATE_OVERLAY5(27, "chocolate", "overlay5"),
    CHOCOLATE_OVERLAY6(28, "chocolate", "overlay6"),
    CHOCOLATE_OVERLAY7(29, "chocolate", "overlay7"),
    CHOCOLATE_OVERLAY8(30, "chocolate", "overlay8"),

    // --- CREAM Variants (Base + Overlays) ---
    CREAM(3, "cream", null),
    CREAM_OVERLAY1(31, "cream", "overlay1"),
    CREAM_OVERLAY2(32, "cream", "overlay2"),
    CREAM_OVERLAY3(33, "cream", "overlay3"),
    CREAM_OVERLAY4(34, "cream", "overlay4"),
    CREAM_OVERLAY5(35, "cream", "overlay5"),
    CREAM_OVERLAY6(36, "cream", "overlay6"),
    CREAM_OVERLAY7(37, "cream", "overlay7"),
    CREAM_OVERLAY8(38, "cream", "overlay8"),

    // --- DARK_GRAY Variants (Base + Overlays) ---
    DARK_GRAY(4, "dark_gray", null),
    DARK_GRAY_OVERLAY1(39, "dark_gray", "overlay1"),
    DARK_GRAY_OVERLAY2(40, "dark_gray", "overlay2"),
    DARK_GRAY_OVERLAY3(41, "dark_gray", "overlay3"),
    DARK_GRAY_OVERLAY4(42, "dark_gray", "overlay4"),
    DARK_GRAY_OVERLAY5(43, "dark_gray", "overlay5"),
    DARK_GRAY_OVERLAY6(44, "dark_gray", "overlay6"),
    DARK_GRAY_OVERLAY7(45, "dark_gray", "overlay7"),
    DARK_GRAY_OVERLAY8(46, "dark_gray", "overlay8"),

    // --- LAVENDER Variants (Base + Overlays) ---
    LAVENDER(56, "lavender", null),
    LAVENDER_OVERLAY1(65, "lavender", "overlay1"),
    LAVENDER_OVERLAY2(66, "lavender", "overlay2"),
    LAVENDER_OVERLAY3(67, "lavender", "overlay3"),
    LAVENDER_OVERLAY4(68, "lavender", "overlay4"),
    LAVENDER_OVERLAY5(69, "lavender", "overlay5"),
    LAVENDER_OVERLAY6(70, "lavender", "overlay6"),
    LAVENDER_OVERLAY7(71, "lavender", "overlay7"),
    LAVENDER_OVERLAY8(72, "lavender", "overlay8"),

    // --- LIGHT_GRAY Variants (Base + Overlays) ---
    LIGHT_GRAY(5, "light_gray", null),
    LIGHT_GRAY_OVERLAY1(47, "light_gray", "overlay1"),
    LIGHT_GRAY_OVERLAY2(48, "light_gray", "overlay2"),
    LIGHT_GRAY_OVERLAY3(49, "light_gray", "overlay3"),
    LIGHT_GRAY_OVERLAY4(50, "light_gray", "overlay4"),
    LIGHT_GRAY_OVERLAY5(51, "light_gray", "overlay5"),
    LIGHT_GRAY_OVERLAY6(52, "light_gray", "overlay6"),
    LIGHT_GRAY_OVERLAY7(53, "light_gray", "overlay7"),
    LIGHT_GRAY_OVERLAY8(54, "light_gray", "overlay8"),

    // --- ORANGE Variants (Base + Overlays) ---
    ORANGE(0, "orange", null),
    ORANGE_OVERLAY1(7, "orange", "overlay1"),
    ORANGE_OVERLAY2(8, "orange", "overlay2"),
    ORANGE_OVERLAY3(9, "orange", "overlay3"),
    ORANGE_OVERLAY4(10, "orange", "overlay4"),
    ORANGE_OVERLAY5(11, "orange", "overlay5"),
    ORANGE_OVERLAY6(12, "orange", "overlay6"),
    ORANGE_OVERLAY7(13, "orange", "overlay7"),
    ORANGE_OVERLAY8(14, "orange", "overlay8"),

    // --- WHITE (Base Only) ---
    WHITE(6, "white", null); // White has no overlay by design


    private static final HamsterVariant[] BY_ID = Arrays.stream(values())
            .sorted(Comparator.comparingInt(HamsterVariant::getId))
            .toArray(HamsterVariant[]::new);

    private final int id;
    private final String baseTextureName;
    @Nullable
    private final String overlayTextureName;

    // --- Caches for helper methods ---
    private static final Map<HamsterVariant, List<HamsterVariant>> VARIANTS_BY_BASE_CACHE = new EnumMap<>(HamsterVariant.class);
    private record BaseOverlayPair(HamsterVariant base, @Nullable String overlay) {}
    private static final Map<BaseOverlayPair, HamsterVariant> VARIANT_BY_BASE_OVERLAY_CACHE = new HashMap<>();

    static {
        // Populate VARIANTS_BY_BASE_CACHE
        // Ensure this list matches the alphabetical order of base colors
        List<HamsterVariant> baseColors = Arrays.asList(
                BLACK, BLUE, CHOCOLATE, CREAM, DARK_GRAY, LAVENDER, LIGHT_GRAY, ORANGE, WHITE
        );
        for (HamsterVariant base : baseColors) {
            List<HamsterVariant> variants = new ArrayList<>();
            for (HamsterVariant currentVariant : values()) {
                if (currentVariant.getBaseVariant() == base) {
                    variants.add(currentVariant);
                }
            }
            VARIANTS_BY_BASE_CACHE.put(base, List.copyOf(variants));
        }

        // Populate VARIANT_BY_BASE_OVERLAY_CACHE
        for (HamsterVariant variant : values()) {
            VARIANT_BY_BASE_OVERLAY_CACHE.put(new BaseOverlayPair(variant.getBaseVariant(), variant.getOverlayTextureName()), variant);
        }
    }

    HamsterVariant(int id, String baseTextureName, @Nullable String overlayTextureName) {
        this.id = id;
        this.baseTextureName = baseTextureName;
        this.overlayTextureName = overlayTextureName;
    }

    public int getId() {
        return this.id;
    }

    public String getBaseTextureName() {
        return this.baseTextureName;
    }

    @Nullable
    public String getOverlayTextureName() {
        // White variant never has an overlay, this check is more robust
        if ("white".equals(this.baseTextureName) && this.overlayTextureName == null) {
            return null;
        }
        return this.overlayTextureName;
    }

    public HamsterVariant getBaseVariant() {
        return switch (this.baseTextureName) {
            case "black" -> BLACK;
            case "blue" -> BLUE;
            case "chocolate" -> CHOCOLATE;
            case "cream" -> CREAM;
            case "dark_gray" -> DARK_GRAY;
            case "lavender" -> LAVENDER;
            case "light_gray" -> LIGHT_GRAY;
            case "orange" -> ORANGE;
            case "white" -> WHITE;
            default -> ORANGE; // Fallback, should ideally not be reached
        };
    }

    public static HamsterVariant byId(int id) {
        if (id < 0 || id >= BY_ID.length) {
            return ORANGE; // Default fallback
        }
        return BY_ID[id];
    }

    /**
     * Gets a list of all variants (including the base itself) for a given base color.
     * @param baseColorEnum The base color (e.g., HamsterVariant.CHOCOLATE).
     * @return A list of matching HamsterVariant enums.
     */
    public static List<HamsterVariant> getVariantsForBase(HamsterVariant baseColorEnum) {
        return VARIANTS_BY_BASE_CACHE.getOrDefault(baseColorEnum, List.of(baseColorEnum));
    }

    /**
     * Gets a specific variant by its base color and overlay name.
     * @param baseColorEnum The base color enum (e.g., HamsterVariant.LAVENDER).
     * @param overlayName The name of the overlay (e.g., "overlay1"), or null for no overlay.
     * @return The matching HamsterVariant, or the baseColorEnum if no exact match is found.
     */
    public static HamsterVariant getVariantByBaseAndOverlay(HamsterVariant baseColorEnum, @Nullable String overlayName) {
        HamsterVariant result = VARIANT_BY_BASE_OVERLAY_CACHE.get(new BaseOverlayPair(baseColorEnum, overlayName));
        return result != null ? result : baseColorEnum; // Fallback to base color if no specific overlay match
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/item/`
`ModItems.java`
```java
package net.dawson.adorablehamsterpets.item;

// (Imports omitted to save token count)

public class ModItems {

    public static final DeferredRegister<Item> ITEMS = DeferredRegister.create(AdorableHamsterPets.MOD_ID, RegistryKeys.ITEM);

    public static final RegistrySupplier<Item> HAMSTER_GUIDE_BOOK = registerItem("hamster_guide_book",
            () -> new net.dawson.adorablehamsterpets.item.custom.PatchouliGuideBookItem(new Item.Settings().maxCount(1)));

    public static final RegistrySupplier<Item> HAMSTER_SPAWN_EGG = registerSpawnEgg();

    public static final RegistrySupplier<Item> GREEN_BEAN_SEEDS = registerItem("green_bean_seeds",
            () -> new AliasedBlockItem(ModBlocks.GREEN_BEANS_CROP.get(), new Item.Settings()) {
                @Override
                public void appendTooltip(ItemStack stack, @Nullable World world, List<Text> tooltip, TooltipContext context) {
                    if (Configs.AHP.enableItemTooltips) {
                        tooltip.add(Text.translatable("tooltip.adorablehamsterpets.green_bean_seeds.hint1").formatted(Formatting.GOLD));
                        tooltip.add(Text.translatable("tooltip.adorablehamsterpets.green_bean_seeds.hint2").formatted(Formatting.GRAY));
                    } else if (!Platform.isModLoaded("emi")) {
                        tooltip.add(Text.literal("Adorable Hamster Pets").formatted(Formatting.BLUE, Formatting.ITALIC));
                    }
                    super.appendTooltip(stack, world, tooltip, context);
                }
            });

    public static final RegistrySupplier<Item> CUCUMBER_SEEDS = registerItem("cucumber_seeds",
            () -> new AliasedBlockItem(ModBlocks.CUCUMBER_CROP.get(), new Item.Settings()) {
                @Override
                public void appendTooltip(ItemStack stack, @Nullable World world, List<Text> tooltip, TooltipContext context) {
                    if (Configs.AHP.enableItemTooltips) {
                        tooltip.add(Text.translatable("tooltip.adorablehamsterpets.cucumber_seeds.hint1").formatted(Formatting.GOLD));
                        tooltip.add(Text.translatable("tooltip.adorablehamsterpets.cucumber_seeds.hint2").formatted(Formatting.GRAY));
                    } else if (!Platform.isModLoaded("emi")) {
                        tooltip.add(Text.literal("Adorable Hamster Pets").formatted(Formatting.BLUE, Formatting.ITALIC));
                    }
                    super.appendTooltip(stack, world, tooltip, context);
                }
            });

    public static final RegistrySupplier<Item> SUNFLOWER_SEEDS = registerItem("sunflower_seeds",
            () -> new Item(new Item.Settings()) {
                @Override
                public void appendTooltip(ItemStack stack, @Nullable World world, List<Text> tooltip, TooltipContext context) {
                    if (Configs.AHP.enableItemTooltips) {
                        tooltip.add(Text.translatable("tooltip.adorablehamsterpets.sunflower_seeds.hint1").formatted(Formatting.GOLD));
                        tooltip.add(Text.translatable("tooltip.adorablehamsterpets.sunflower_seeds.hint2").formatted(Formatting.GRAY));
                    } else if (!Platform.isModLoaded("emi")) {
                        tooltip.add(Text.literal("Adorable Hamster Pets").formatted(Formatting.BLUE, Formatting.ITALIC));
                    }
                    super.appendTooltip(stack, world, tooltip, context);
                }
            });

    public static final RegistrySupplier<Item> CUCUMBER = registerItem("cucumber",
            () -> new Item(new Item.Settings().food(ModFoodComponents.CUCUMBER)) {
                @Override
                public void appendTooltip(ItemStack stack, @Nullable World world, List<Text> tooltip, TooltipContext context) {
                    if (Configs.AHP.enableItemTooltips) {
                        tooltip.add(Text.translatable("tooltip.adorablehamsterpets.cucumber.hint1").formatted(Formatting.GOLD));
                        tooltip.add(Text.translatable("tooltip.adorablehamsterpets.cucumber.hint2").formatted(Formatting.GRAY));
                    } else if (!Platform.isModLoaded("emi")) {
                        tooltip.add(Text.literal("Adorable Hamster Pets").formatted(Formatting.BLUE, Formatting.ITALIC));
                    }
                    super.appendTooltip(stack, world, tooltip, context);
                }
            });

    public static final RegistrySupplier<Item> SLICED_CUCUMBER = registerItem("sliced_cucumber",
            () -> new Item(new Item.Settings().food(ModFoodComponents.SLICED_CUCUMBER)) {
                @Override
                public void appendTooltip(ItemStack stack, @Nullable World world, List<Text> tooltip, TooltipContext context) {
                    if (Configs.AHP.enableItemTooltips) {
                        tooltip.add(Text.translatable("tooltip.adorablehamsterpets.sliced_cucumber.hint1").formatted(Formatting.GOLD));
                        tooltip.add(Text.translatable("tooltip.adorablehamsterpets.sliced_cucumber.hint2").formatted(Formatting.GRAY));
                    } else if (!Platform.isModLoaded("emi")) {
                        tooltip.add(Text.literal("Adorable Hamster Pets").formatted(Formatting.BLUE, Formatting.ITALIC));
                    }
                    super.appendTooltip(stack, world, tooltip, context);
                }
            });

    public static final RegistrySupplier<Item> GREEN_BEANS = registerItem("green_beans",
            () -> new Item(new Item.Settings().food(ModFoodComponents.GREEN_BEANS)) {
                @Override
                public void appendTooltip(ItemStack stack, @Nullable World world, List<Text> tooltip, TooltipContext context) {
                    if (Configs.AHP.enableItemTooltips) {
                        tooltip.add(Text.translatable("tooltip.adorablehamsterpets.green_beans.hint1").formatted(Formatting.GOLD));
                        tooltip.add(Text.translatable("tooltip.adorablehamsterpets.green_beans.hint2").formatted(Formatting.GRAY));
                    } else if (!Platform.isModLoaded("emi")) {
                        tooltip.add(Text.literal("Adorable Hamster Pets").formatted(Formatting.BLUE, Formatting.ITALIC));
                    }
                    super.appendTooltip(stack, world, tooltip, context);
                }
            });

    public static final RegistrySupplier<Item> STEAMED_GREEN_BEANS = registerItem("steamed_green_beans",
            () -> new Item(new Item.Settings().food(ModFoodComponents.STEAMED_GREEN_BEANS)) {
                @Override
                public void appendTooltip(ItemStack stack, @Nullable World world, List<Text> tooltip, TooltipContext context) {
                    if (Configs.AHP.enableItemTooltips) {
                        tooltip.add(Text.translatable("tooltip.adorablehamsterpets.steamed_green_beans.hint1").formatted(Formatting.GOLD));
                        tooltip.add(Text.translatable("tooltip.adorablehamsterpets.steamed_green_beans.hint2").formatted(Formatting.GRAY));
                    } else if (!Platform.isModLoaded("emi")) {
                        tooltip.add(Text.literal("Adorable Hamster Pets").formatted(Formatting.BLUE, Formatting.ITALIC));
                    }
                    super.appendTooltip(stack, world, tooltip, context);
                }
            });

    public static final RegistrySupplier<Item> HAMSTER_FOOD_MIX = registerItem("hamster_food_mix",
            () -> new Item(new Item.Settings().food(ModFoodComponents.HAMSTER_FOOD_MIX).maxCount(16)) {
                @Override
                public void appendTooltip(ItemStack stack, @Nullable World world, List<Text> tooltip, TooltipContext context) {
                    if (Configs.AHP.enableItemTooltips) {
                        tooltip.add(Text.translatable("tooltip.adorablehamsterpets.hamster_food_mix.hint1").formatted(Formatting.GOLD));
                        tooltip.add(Text.translatable("tooltip.adorablehamsterpets.hamster_food_mix.hint2").formatted(Formatting.GRAY));
                    } else if (!Platform.isModLoaded("emi")) {
                        tooltip.add(Text.literal("Adorable Hamster Pets").formatted(Formatting.BLUE, Formatting.ITALIC));
                    }
                    super.appendTooltip(stack, world, tooltip, context);
                }
            });

    public static final RegistrySupplier<Item> CHEESE = registerItem("cheese",
            () -> new net.dawson.adorablehamsterpets.item.custom.CheeseItem(new Item.Settings().food(ModFoodComponents.CHEESE)));

    public static final RegistrySupplier<Item> WILD_GREEN_BEAN_BUSH_ITEM = registerBlockItem("wild_green_bean_bush",
            () -> new BlockItem(ModBlocks.WILD_GREEN_BEAN_BUSH.get(), new Item.Settings()) {
                @Override
                public void appendTooltip(ItemStack stack, @Nullable World world, List<Text> tooltip, TooltipContext context) {
                    if (Configs.AHP.enableItemTooltips) {
                        tooltip.add(Text.translatable("block.adorablehamsterpets.wild_green_bean_bush.hint1").formatted(Formatting.GOLD));
                        tooltip.add(Text.translatable("block.adorablehamsterpets.wild_green_bean_bush.hint2").formatted(Formatting.GRAY));
                    } else if (!Platform.isModLoaded("emi")) {
                        tooltip.add(Text.literal("Adorable Hamster Pets").formatted(Formatting.BLUE, Formatting.ITALIC));
                    }
                    super.appendTooltip(stack, world, tooltip, context);
                }
            });

    public static final RegistrySupplier<Item> WILD_CUCUMBER_BUSH_ITEM = registerBlockItem("wild_cucumber_bush",
            () -> new BlockItem(ModBlocks.WILD_CUCUMBER_BUSH.get(), new Item.Settings()) {
                @Override
                public void appendTooltip(ItemStack stack, @Nullable World world, List<Text> tooltip, TooltipContext context) {
                    if (Configs.AHP.enableItemTooltips) {
                        tooltip.add(Text.translatable("block.adorablehamsterpets.wild_cucumber_bush.hint1").formatted(Formatting.GOLD));
                        tooltip.add(Text.translatable("block.adorablehamsterpets.wild_cucumber_bush.hint2").formatted(Formatting.GRAY));
                    } else if (!Platform.isModLoaded("emi")) {
                        tooltip.add(Text.literal("Adorable Hamster Pets").formatted(Formatting.BLUE, Formatting.ITALIC));
                    }
                    super.appendTooltip(stack, world, tooltip, context);
                }
            });

    public static final RegistrySupplier<Item> SUNFLOWER_BLOCK_ITEM = registerBlockItem("sunflower_block",
            () -> new BlockItem(ModBlocks.SUNFLOWER_BLOCK.get(), new Item.Settings()) {
                @Override
                public void appendTooltip(ItemStack stack, @Nullable World world, List<Text> tooltip, TooltipContext context) {
                    if (Configs.AHP.enableItemTooltips) {
                        tooltip.add(Text.translatable("block.adorablehamsterpets.sunflower_block.hint1").formatted(Formatting.GOLD));
                        tooltip.add(Text.translatable("block.adorablehamsterpets.sunflower_block.hint2").formatted(Formatting.GRAY));
                    } else if (!Platform.isModLoaded("emi")) {
                        tooltip.add(Text.literal("Adorable Hamster Pets").formatted(Formatting.BLUE, Formatting.ITALIC));
                    }
                    super.appendTooltip(stack, world, tooltip, context);
                }
            });

    public static final RegistrySupplier<Item> HAMSTER_BEDDING = registerItem("hamster_bedding",
            () -> new HamsterBeddingItem(new Item.Settings()));

    // Hamster Bed
    public static final Map<WoodVariant, RegistrySupplier<Item>> HAMSTER_BED_ITEMS = new EnumMap<>(WoodVariant.class);
    static {
        for (WoodVariant variant : WoodVariant.values()) {
            HAMSTER_BED_ITEMS.put(variant, registerBlockItem("hamster_bed_" + variant.asString(),
                    // On 1.20.1, use HamsterBedItem.create(...) instead of new HamsterBedItem(...)
                    () -> HamsterBedItem.create(ModBlocks.HAMSTER_BED.get(), variant, new Item.Settings())));
        }
    }

    public static final RegistrySupplier<Item> UPSIDE_DOWN_HAMSTER_BED_ICON = registerItem("upside_down_hamster_bed_icon",
            // On 1.20.1, use HamsterBedItem.create(...)
            () -> HamsterBedItem.create(ModBlocks.HAMSTER_BED.get(), WoodVariant.OAK, new Item.Settings()));

    // So Patchouli can display custom bell icon in its category list
    public static final RegistrySupplier<Item> ANNOUNCEMENT_BELL_ICON = registerItem("announcement_bell_icon",
            () -> new Item(new Item.Settings()));

    // --- 3. Helper methods for registration ---
    private static RegistrySupplier<Item> registerItem(String name, Supplier<Item> itemSupplier) {
        return ITEMS.register(Identifier.of(AdorableHamsterPets.MOD_ID, name), itemSupplier);
    }

    private static RegistrySupplier<Item> registerBlockItem(String name, Supplier<Item> itemSupplier) {
        return ITEMS.register(name, itemSupplier);
    }

    public static void register() {
        ITEMS.register();
    }

    @ExpectPlatform
    private static RegistrySupplier<Item> registerSpawnEgg() {
        throw new AssertionError();
    }
}
```

`ModFoodComponents.java`
```java
package net.dawson.adorablehamsterpets.item;

// (Imports omitted to save token count)

public class ModFoodComponents {

    public static final FoodComponent CUCUMBER = new FoodComponent.Builder()
            .hunger(2)
            .saturationModifier(0.3F)
            .build();

    public static final FoodComponent SLICED_CUCUMBER = new FoodComponent.Builder()
            .hunger(4)
            .saturationModifier(0.6F)
            .build();

    public static final FoodComponent GREEN_BEANS = new FoodComponent.Builder()
            .hunger(2)
            .saturationModifier(0.3F)
            .build();

    public static final FoodComponent STEAMED_GREEN_BEANS = new FoodComponent.Builder()
            .hunger(4)
            .saturationModifier(0.6F)
            .build();

    public static final FoodComponent HAMSTER_FOOD_MIX = new FoodComponent.Builder()
            .hunger(4)
            .saturationModifier(0.6F)
            .build();

    public static final FoodComponent CHEESE = new FoodComponent.Builder()
            .hunger(8) // Like cooked porkchop
            .saturationModifier(0.8F) // Like cooked porkchop
            .build();
}
```

`ModItemGroups.java`
```java
package net.dawson.adorablehamsterpets.item;

// (Imports omitted to save token count)

public class ModItemGroups {


    public static final DeferredRegister<ItemGroup> ITEM_GROUPS = DeferredRegister.create(AdorableHamsterPets.MOD_ID, RegistryKeys.ITEM_GROUP);


    public static final RegistrySupplier<ItemGroup> ADORABLE_HAMSTER_PETS_GROUP = ITEM_GROUPS.register(
            "adorable_hamster_pets",
            () -> CreativeTabRegistry.create(builder -> builder
                    .displayName(Text.translatable("itemgroup.adorablehamsterpets.main"))
                    .icon(() -> new ItemStack(ModItems.HAMSTER_SPAWN_EGG.get()))
                    .entries((featureSet, output) -> {
                        // This is where we add all the items to the tab's contents.
                        output.add(ModItems.CHEESE.get());
                        output.add(ModItems.HAMSTER_FOOD_MIX.get());
                        output.add(ModItems.CUCUMBER.get());
                        output.add(ModItems.CUCUMBER_SEEDS.get());
                        output.add(ModItems.SLICED_CUCUMBER.get());
                        output.add(ModItems.GREEN_BEANS.get());
                        output.add(ModItems.GREEN_BEAN_SEEDS.get());
                        output.add(ModItems.STEAMED_GREEN_BEANS.get());
                        output.add(ModItems.SUNFLOWER_SEEDS.get());
                        output.add(ModItems.HAMSTER_SPAWN_EGG.get());
                        output.add(ModItems.SUNFLOWER_BLOCK_ITEM.get());
                        output.add(ModItems.WILD_GREEN_BEAN_BUSH_ITEM.get());
                        output.add(ModItems.WILD_CUCUMBER_BUSH_ITEM.get());
                        output.add(ModItems.HAMSTER_BEDDING.get());
                        ModItems.HAMSTER_BED_ITEMS.values().forEach(supplier -> output.add(supplier.get()));
                    }))
    );


    public static void register() {
        ITEM_GROUPS.register();
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/item/client/`
`HamsterBedItemModel.java`
```java
package net.dawson.adorablehamsterpets.item.client;

// (Imports omitted to save token count)

@SuppressWarnings({"removal"})
public final class HamsterBedItemModel extends GeoModel<HamsterBedItem> {

    @Override
    public Identifier getModelResource(HamsterBedItem animatable) {
        return new Identifier(AdorableHamsterPets.MOD_ID, "geo/hamster_bed.geo.json");
    }

    @Override
    public Identifier getTextureResource(HamsterBedItem animatable) {
        // Fallback texture; the actual texture is determined by the Renderer
        // In 1.20.1, access the state directly from the block entity
        return new Identifier(AdorableHamsterPets.MOD_ID, "textures/block/hamster_bed_oak.png");
    }

    @Override
    public Identifier getAnimationResource(HamsterBedItem animatable) {
        return Identifier.of(AdorableHamsterPets.MOD_ID, "animations/anim_hamster_bed.animation.json");
    }
}
```

`HamsterBedRenderProvider.java`
```java
package net.dawson.adorablehamsterpets.item.client;

// (Imports omitted to save token count)

/**
 * A client-only helper class used to lazily instantiate the {@link RenderProvider}
 * for the Hamster Bed item.
 * <p>
 * This logic had to be isolated into a separate class on 1.20.1 to prevent {@link NoClassDefFoundError} on the server
 * by ensuring that client-only GeckoLib classes are not loaded during the item's common initialization.
 */
public class HamsterBedRenderProvider {
    public static RenderProvider create() {
        return new RenderProvider() {
            private HamsterBedItemRenderer renderer;

            @Override
            public BuiltinModelItemRenderer getCustomRenderer() {
                if (this.renderer == null)
                    this.renderer = new HamsterBedItemRenderer();
                return this.renderer;
            }
        };
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/item/custom/`
`CheeseItem.java`
```java
package net.dawson.adorablehamsterpets.item.custom;

// (Imports omitted to save token count)

public class CheeseItem extends Item {

    public CheeseItem(Settings settings) {
        super(settings);
    }

    @Override
    public void appendTooltip(ItemStack stack, @Nullable World world, List<Text> tooltip, TooltipContext context) {
        if (Configs.AHP.enableItemTooltips) {
            tooltip.add(Text.translatable("tooltip.adorablehamsterpets.cheese.hint1").formatted(Formatting.GOLD));
            tooltip.add(Text.translatable("tooltip.adorablehamsterpets.cheese.hint2").formatted(Formatting.GRAY));

            boolean appleSkinLoaded = Platform.isModLoaded("appleskin");
            if (appleSkinLoaded) {
                tooltip.add(Text.translatable("tooltip.adorablehamsterpets.cheese.appleskin_warning").formatted(Formatting.DARK_GRAY));
            } else {
                tooltip.add(Text.translatable("tooltip.adorablehamsterpets.cheese.hint3",
                        Configs.AHP.cheeseNutrition.get(),
                        String.format("%.1f", Configs.AHP.cheeseSaturation.get() * Configs.AHP.cheeseNutrition.get() * 2.0F)
                ).formatted(Formatting.DARK_GRAY));
            }
        }  else if (!Platform.isModLoaded("emi")) {
            tooltip.add(Text.literal("Adorable Hamster Pets").formatted(Formatting.BLUE, Formatting.ITALIC));
        }
        super.appendTooltip(stack, world, tooltip, context);
    }

    @Override
    public SoundEvent getEatSound() {
        return ModSounds.CHEESE_EAT1.get();
    }

    @Override
    public UseAction getUseAction(ItemStack stack) {
        return UseAction.EAT;
    }

    @Override
    public int getMaxUseTime(ItemStack stack) {
        return 20; // Custom eating time
    }

    @Override
    public ItemStack finishUsing(ItemStack stack, World world, LivingEntity user) {
        if (user instanceof PlayerEntity player) {
            // Manually apply hunger and saturation from config
            int nutrition = Configs.AHP.cheeseNutrition.get();
            float saturation = Configs.AHP.cheeseSaturation.get();
            player.getHungerManager().add(nutrition, saturation);
            player.incrementStat(Stats.USED.getOrCreateStat(this));
            SoundEvent randomEatSound = ModSounds.getRandomSoundFrom(ModSounds.CHEESE_EAT_SOUNDS, world.random);
            if (randomEatSound != null) {
                world.playSound(null, player.getX(), player.getY(), player.getZ(), randomEatSound, player.getSoundCategory(), 1.2F, 1.0F + (world.random.nextFloat() - world.random.nextFloat()) * 0.4F);
            }
        }
        if (!(user instanceof PlayerEntity player) || !player.getAbilities().creativeMode) {
            stack.decrement(1);
        }
        return stack;
    }
}
```

`HamsterBeddingItem.java`
```java
package net.dawson.adorablehamsterpets.item.custom;

// (Imports omitted to save token count)

public class HamsterBeddingItem extends Item {
    public HamsterBeddingItem(Settings settings) {
        super(settings);
    }

    @Override
    public TypedActionResult<ItemStack> use(World world, PlayerEntity user, Hand hand) {
        ItemStack stack = user.getStackInHand(hand);

        if (world.isClient) {
            // Perform a raycast to see what the player is looking at
            BlockHitResult hitResult = raycast(world, user, RaycastContext.FluidHandling.NONE);
            Vec3d particlePos;

            if (hitResult.getType() == HitResult.Type.BLOCK) {
                // Player is looking at a block, spawn particles in the adjacent air block
                BlockPos adjacentPos = hitResult.getBlockPos().offset(hitResult.getSide());
                particlePos = Vec3d.ofCenter(adjacentPos);
            } else {
                // Player is looking at the air, spawn particles in front of them
                particlePos = user.getEyePos().add(user.getRotationVec(1.0f).multiply(1.5));
            }

            // Spawn a puff of leaf particles
            for (int i = 0; i < 100; i++) {
                double offsetX = world.random.nextGaussian() * 1.2;
                double offsetY = world.random.nextGaussian() * 1.2;
                double offsetZ = world.random.nextGaussian() * 1.2;
                world.addParticle(ModParticles.getForVariant(WoodVariant.OAK), // Use OAK as default
                        particlePos.x + offsetX, particlePos.y + offsetY, particlePos.z + offsetZ,
                        0, HamsterBeddingParticle.BEDDING_ITEM_FLAG, 0);
            }

            // Play leaf sound
            SoundEvent rustleSound = ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_BED_LEAVES_RUSTLE_SOUNDS, world.random);
            if (rustleSound != null) {
                world.playSound(user, user.getBlockPos(), rustleSound, SoundCategory.PLAYERS, 0.2f, 1.5f);
            }
        }

        // Trigger advancement on server
        if (!world.isClient && user instanceof ServerPlayerEntity serverPlayer) {
            ModCriteria.USED_HAMSTER_BEDDING.trigger(serverPlayer);
        }

        return TypedActionResult.success(stack, world.isClient());
    }

    @Override
    public void appendTooltip(ItemStack stack, @Nullable World world, List<Text> tooltip, TooltipContext context) {
        if (Configs.AHP.enableItemTooltips) {
            if (Screen.hasShiftDown()) {
                // --- Expanded Tooltip (Shift) ---
                tooltip.add(Text.translatable("tooltip.adorablehamsterpets.hamster_bedding.hint1").formatted(Formatting.GOLD));
                tooltip.add(Text.translatable("tooltip.adorablehamsterpets.hamster_bedding.hint2").formatted(Formatting.GRAY));
                tooltip.add(Text.translatable("tooltip.adorablehamsterpets.hamster_bedding.hint3").formatted(Formatting.GRAY));
            } else {
                // --- Default Tooltip ---
                tooltip.add(Text.translatable("tooltip.adorablehamsterpets.hamster_bedding.hint1").formatted(Formatting.GOLD));
                tooltip.add(Text.translatable("tooltip.adorablehamsterpets.shift_for_info").formatted(Formatting.DARK_GRAY));
            }
        } else if (!Platform.isModLoaded("emi")) {
            tooltip.add(Text.literal("Adorable Hamster Pets").formatted(Formatting.BLUE, Formatting.ITALIC));
        }
        super.appendTooltip(stack, world, tooltip, context);
    }
}
```

`HamsterBedItem.java`
```java
package net.dawson.adorablehamsterpets.item.custom;

// (Imports omitted to save token count)

public class HamsterBedItem extends BlockItem implements GeoItem {
    private final AnimatableInstanceCache cache = GeckoLibUtil.createInstanceCache(this);
    private final WoodVariant variant;

    /**
     * Platform-agnostic factory method.
     * On Fabric: Returns new HamsterBedItem()
     * On Forge: Returns new HamsterBedItem() { @Override initializeClient... }
     */
    @ExpectPlatform
    public static HamsterBedItem create(Block block, WoodVariant variant, Settings settings) {
        throw new AssertionError();
    }

    // On 1.20.1, initialize the RenderProvider and implement the getter
    private final Supplier<Object> renderProvider = new Supplier<Object>() {
        private Object provider;

        @Override
        public Object get() {
            if (provider == null) {
                if (Platform.getEnvironment() == Env.CLIENT) {
                    // Only load HamsterBedRenderProvider on the client.
                    provider = net.dawson.adorablehamsterpets.item.client.HamsterBedRenderProvider.create();
                }
            }
            return provider;
        }
    };

    @Override
    public Supplier<Object> getRenderProvider() {
        return renderProvider;
    }

    public HamsterBedItem(Block block, WoodVariant variant, Settings settings) {
        super(block, settings);
        this.variant = variant;
        GeoItem.registerSyncedAnimatable(this);
    }

    @Override
    protected boolean postPlacement(BlockPos pos, World world, @Nullable PlayerEntity player, ItemStack stack, BlockState state) {
        if (!world.isClient) {
            // --- Sound and Particle Logic ---
            SoundEvent rustleSound = ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_BED_LEAVES_RUSTLE_SOUNDS, world.getRandom());
            if (rustleSound != null) {
                world.playSound(null, pos, rustleSound, SoundCategory.BLOCKS, 0.5f, 1.5f);
            }

            BlockEntity be = world.getBlockEntity(pos);
            if (be instanceof HamsterBedBlockEntity bedEntity) {
                bedEntity.triggerAnim("hamster_bed_controller", "anim_bed_being_placed");

                // Spawn particles with the wood variant
                // 1.20.1 Wood variant Logic
                WoodVariant variant = this.variant; // Default to item's variant
                if (stack.hasNbt() && stack.getNbt().contains(ModNbtKeys.WOOD_VARIANT)) {
                    try {
                        variant = WoodVariant.valueOf(stack.getNbt().getString(ModNbtKeys.WOOD_VARIANT));
                    } catch (IllegalArgumentException ignored) {}
                }
                ((ServerWorld)world).spawnParticles(ModParticles.getForVariant(variant),
                        pos.getX() + 0.5, pos.getY() + 0.3, pos.getZ() + 0.5,
                        30, 0.1, 0.2, 0.1, 0.0);
            }
        }
        // Set the block state with the correct wood variant after it has been placed.
        return world.setBlockState(pos, state.with(HamsterBedBlock.WOOD_VARIANT, this.variant), Block.NOTIFY_ALL | Block.REDRAW_ON_MAIN_THREAD);
    }

    @Override
    public void appendTooltip(ItemStack stack, @Nullable World world, List<Text> tooltip, TooltipContext context) {
        // 1.20.1 Variant read logic
        WoodVariant stackVariant = this.variant;
        if (stack.hasNbt() && stack.getNbt().contains(ModNbtKeys.WOOD_VARIANT)) {
            try {
                stackVariant = WoodVariant.valueOf(stack.getNbt().getString(ModNbtKeys.WOOD_VARIANT));
            } catch (IllegalArgumentException ignored) {}
        }
        if (Configs.AHP.enableItemTooltips) {
            if (Screen.hasShiftDown()) {
                // --- Expanded Tooltip (Sneaking) ---
                tooltip.add(Text.translatable("tooltip.adorablehamsterpets.hamster_bed.description1").formatted(Formatting.GOLD));
                tooltip.add(Text.translatable("tooltip.adorablehamsterpets.hamster_bed.description2").formatted(Formatting.GRAY));
                tooltip.add(Text.translatable("tooltip.adorablehamsterpets.jade.wander_controls").formatted(Formatting.GRAY));
                tooltip.add(Text.translatable("tooltip.adorablehamsterpets.jade.lure_hint").formatted(Formatting.GRAY));
                tooltip.add(Text.translatable("tooltip.adorablehamsterpets.jade.repellent_hint").formatted(Formatting.GRAY));
                tooltip.add(Text.translatable("tooltip.adorablehamsterpets.jade.unlink_hint").formatted(Formatting.GRAY));

                // --- Conditional Linked Info ---
                // 1.20.1 Conditional linked info logic
                if (stack.hasNbt()) {
                    NbtCompound nbt = stack.getNbt();
                    if (nbt.contains(ModNbtKeys.LINKED_HAMSTER_UUID) && nbt.contains(ModNbtKeys.LINKED_HAMSTER_NAME)) {

                        Text hamsterName = Text.Serializer.fromJson(nbt.getString(ModNbtKeys.LINKED_HAMSTER_NAME));

                        tooltip.add(Text.literal(""));
                        if (hamsterName != null) {
                            tooltip.add(Text.translatable("tooltip.adorablehamsterpets.hamster_bed.linked_to", hamsterName).formatted(Formatting.GREEN));
                        }

                        if (nbt.contains(ModNbtKeys.WANDER_DISTANCE)) {
                            try {
                                WanderDistance wanderDistance = WanderDistance.valueOf(nbt.getString(ModNbtKeys.WANDER_DISTANCE));
                                int radius = switch (wanderDistance) {
                                    case NEAR -> Configs.AHP.wanderDistanceNear.get();
                                    case FAR -> Configs.AHP.wanderDistanceFar.get();
                                    default -> Configs.AHP.wanderDistanceMedium.get();
                                };
                                tooltip.add(Text.translatable("tooltip.adorablehamsterpets.hamster_bed.wander_distance", wanderDistance.asString(), radius).formatted(Formatting.AQUA));
                            } catch (IllegalArgumentException ignored) {}
                        }
                    }
                }
            } else {
                // --- Default (Condensed) Tooltip ---
                tooltip.add(Text.translatable("tooltip.adorablehamsterpets.hamster_bed.description1").formatted(Formatting.GOLD));
                tooltip.add(Text.translatable("tooltip.adorablehamsterpets.shift_for_info").formatted(Formatting.DARK_GRAY));
            }
        } else if (!Platform.isModLoaded("emi")) {
            tooltip.add(Text.literal("Adorable Hamster Pets").formatted(Formatting.BLUE, Formatting.ITALIC));
        }
        super.appendTooltip(stack, world, tooltip, context);
    }

    // InventoryTick override for dynamic tooltip
    @Override
    public void inventoryTick(ItemStack stack, World world, Entity entity, int slot, boolean selected) {
        if (!world.isClient) {
            return;
        }

        // 1.20.1 Check logic
        if (!stack.hasNbt() || !stack.getNbt().contains(ModNbtKeys.LINKED_HAMSTER_UUID)) {
            return;
        }
        UUID linkedUuid = stack.getNbt().getUuid(ModNbtKeys.LINKED_HAMSTER_UUID);

        if (entity instanceof PlayerEntity) {
            // Search nearby entities for the linked hamster
            world.getEntitiesByClass(HamsterEntity.class, entity.getBoundingBox().expand(16), e -> e.getUuid().equals(linkedUuid))
                    .stream().findFirst().ifPresent(hamster -> {
                        Text newName;
                        if (hamster.hasCustomName()) {
                            newName = hamster.getName();
                        } else {
                            newName = hamster.getDisplayName().copy().append(" " + hamster.getId());
                        }

                        // 1.20.1 Check and update logic
                        String currentJson = stack.getNbt().getString(ModNbtKeys.LINKED_HAMSTER_NAME);
                        String newJson = Text.Serializer.toJson(newName);

                        if (!currentJson.equals(newJson)) {
                            stack.getOrCreateNbt().putString(ModNbtKeys.LINKED_HAMSTER_NAME, newJson);
                        }
                    });
        }
    }

    @Override
    public void registerControllers(AnimatableManager.ControllerRegistrar controllers) {
        // No item animations needed, so this is empty.
    }

    @Override
    public AnimatableInstanceCache getAnimatableInstanceCache() {
        return this.cache;
    }


    public WoodVariant getVariant() {
        return this.variant;
    }

    @Override
    public String getTranslationKey() {
        // Forces the item to use its own unique translation key
        return this.getOrCreateTranslationKey();
    }

    @Override
    public void createRenderer(Consumer<Object> consumer) {
        // On 1.20.1, delegating to the separate client-only class prevents ClassNotFound errors on the server
        if (Platform.getEnvironment() == Env.CLIENT) {
            consumer.accept(net.dawson.adorablehamsterpets.item.client.HamsterBedRenderProvider.create());
        }
    }
}
```

`PatchouliGuideBookItem.java`
```java
package net.dawson.adorablehamsterpets.item.custom;

// (Imports omitted to save token count)

public class PatchouliGuideBookItem extends Item {
    public PatchouliGuideBookItem(Settings settings) {
        super(settings);
    }

    /**
     * Called when the player right-clicks with this item.
     * This opens the Patchouli book screen for the player.
     */
    @Override
    public TypedActionResult<ItemStack> use(World world, PlayerEntity user, Hand hand) {
        ItemStack stack = user.getStackInHand(hand);
        if (user instanceof ServerPlayerEntity serverPlayer) {
            PatchouliAPI.get().openBookGUI(serverPlayer, Identifier.of("adorablehamsterpets", "hamster_tips_guide_book"));
        }
        return TypedActionResult.success(stack);
    }

    /**
     * Appends the custom tooltip, including a context-aware check to prevent
     * duplicating the mod name when another mod (like Jade) would also add it.
     * This method is annotated with @Environment to be stripped from dedicated servers.
     */
    @Override
    public void appendTooltip(ItemStack stack, World world, List<Text> tooltip, TooltipContext context) {
        // --- 1. Add the primary hint text unconditionally ---
        tooltip.add(Text.translatable("tooltip.adorablehamsterpets.hamster_guide_book.hint").formatted(Formatting.GRAY));

        // --- 2. Get Contextual Information ---
        boolean isJadeLoaded = Platform.isModLoaded("jade");
        boolean isEMILoaded = Platform.isModLoaded("emi");
        Screen currentScreen = MinecraftClient.getInstance().currentScreen;

        // --- 3. Determine screen context ---
        // A tooltip is needed anywhere Jade does NOT add its own tooltip.
        boolean needsToolTip = (currentScreen == null || currentScreen.getClass() == CreativeInventoryScreen.class);

        // --- 4. Add the mod name line if needed ---
        // Add line if EITHER Jade/EMI is not installed OR we are in a screen that needs a tooltip.
        if (!isJadeLoaded || !isEMILoaded || needsToolTip) {
            tooltip.add(Text.literal("Adorable Hamster Pets").formatted(Formatting.BLUE, Formatting.ITALIC));
        }

        super.appendTooltip(stack, world, tooltip, context);
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/sound/`
`ModSounds.java`
```java
package net.dawson.adorablehamsterpets.sound;

// (Imports omitted to save token count)

public class ModSounds {

    // --- 1. DeferredRegister for SoundEvents ---
    public static final DeferredRegister<SoundEvent> SOUND_EVENTS = DeferredRegister.create(AdorableHamsterPets.MOD_ID, RegistryKeys.SOUND_EVENT);

    // --- 2. SoundEvent Registrations as RegistrySuppliers ---
    // --- Ambient Weather Sounds ---
    public static final RegistrySupplier<SoundEvent> GENTLE_BREEZE = registerSoundEvent("gentle_breeze"); // For Hamster Bedding particle effect

    // --- General Movement Sounds ---
    public static final RegistrySupplier<SoundEvent> HAMSTER_BOUNCE = registerSoundEvent("hamster_bounce");
    public static final RegistrySupplier<SoundEvent> HAMSTER_THUMP = registerSoundEvent("hamster_thump");
    public static final RegistrySupplier<SoundEvent> HAMSTER_SWISH = registerSoundEvent("hamster_swish");

    // --- Impact/Throw ---
    public static final RegistrySupplier<SoundEvent> HAMSTER_IMPACT = registerSoundEvent("hamster_impact");
    public static final RegistrySupplier<SoundEvent> HAMSTER_THROW = registerSoundEvent("hamster_throw");
    public static final RegistrySupplier<SoundEvent> HAMSTER_INCOMING = registerSoundEvent("hamster_throw_reversed");

    // --- Flying / Special ---
    public static final RegistrySupplier<SoundEvent> HAMSTER_AIRBORNE_CELEBRATION = registerSoundEvent("hamster_airborne_celebration");
    public static final RegistrySupplier<SoundEvent> HAMSTER_WOW = registerSoundEvent("hamster_wow");

    // --- Attack Sounds (1-4) ---
    public static final RegistrySupplier<SoundEvent> HAMSTER_ATTACK1 = registerSoundEvent("hamster_attack1");
    public static final RegistrySupplier<SoundEvent> HAMSTER_ATTACK2 = registerSoundEvent("hamster_attack2");
    public static final RegistrySupplier<SoundEvent> HAMSTER_ATTACK3 = registerSoundEvent("hamster_attack3");
    public static final RegistrySupplier<SoundEvent> HAMSTER_ATTACK4 = registerSoundEvent("hamster_attack4");

    // --- Beg Sounds (1-5) ---
    public static final RegistrySupplier<SoundEvent> HAMSTER_BEG1 = registerSoundEvent("hamster_beg1");
    public static final RegistrySupplier<SoundEvent> HAMSTER_BEG2 = registerSoundEvent("hamster_beg2");
    public static final RegistrySupplier<SoundEvent> HAMSTER_BEG3 = registerSoundEvent("hamster_beg3");
    public static final RegistrySupplier<SoundEvent> HAMSTER_BEG4 = registerSoundEvent("hamster_beg4");
    public static final RegistrySupplier<SoundEvent> HAMSTER_BEG5 = registerSoundEvent("hamster_beg5");

    // --- Celebrate Sounds (1-4) ---
    public static final RegistrySupplier<SoundEvent> HAMSTER_CELEBRATE1 = registerSoundEvent("hamster_celebrate1");
    public static final RegistrySupplier<SoundEvent> HAMSTER_CELEBRATE2 = registerSoundEvent("hamster_celebrate2");
    public static final RegistrySupplier<SoundEvent> HAMSTER_CELEBRATE3 = registerSoundEvent("hamster_celebrate3");
    public static final RegistrySupplier<SoundEvent> HAMSTER_CELEBRATE4 = registerSoundEvent("hamster_celebrate4");

    // --- Creeper Detect Sounds (1-4) ---
    public static final RegistrySupplier<SoundEvent> HAMSTER_CREEPER_DETECT1 = registerSoundEvent("hamster_creeper_detect1");
    public static final RegistrySupplier<SoundEvent> HAMSTER_CREEPER_DETECT2 = registerSoundEvent("hamster_creeper_detect2");
    public static final RegistrySupplier<SoundEvent> HAMSTER_CREEPER_DETECT3 = registerSoundEvent("hamster_creeper_detect3");
    public static final RegistrySupplier<SoundEvent> HAMSTER_CREEPER_DETECT4 = registerSoundEvent("hamster_creeper_detect4");

    // --- Sniff Sounds (1-4) - Used for Diamond Detection ---
    public static final RegistrySupplier<SoundEvent> HAMSTER_SNIFF1 = registerSoundEvent("hamster_sniff1");
    public static final RegistrySupplier<SoundEvent> HAMSTER_SNIFF2 = registerSoundEvent("hamster_sniff2");
    public static final RegistrySupplier<SoundEvent> HAMSTER_SNIFF3 = registerSoundEvent("hamster_sniff3");
    public static final RegistrySupplier<SoundEvent> HAMSTER_SNIFF4 = registerSoundEvent("hamster_sniff4");

    // --- Death Sounds (1-4) ---
    public static final RegistrySupplier<SoundEvent> HAMSTER_DEATH1 = registerSoundEvent("hamster_death1");
    public static final RegistrySupplier<SoundEvent> HAMSTER_DEATH2 = registerSoundEvent("hamster_death2");
    public static final RegistrySupplier<SoundEvent> HAMSTER_DEATH3 = registerSoundEvent("hamster_death3");
    public static final RegistrySupplier<SoundEvent> HAMSTER_DEATH4 = registerSoundEvent("hamster_death4");

    // --- Hurt Sounds (1-10) ---
    public static final RegistrySupplier<SoundEvent> HAMSTER_HURT1 = registerSoundEvent("hamster_hurt1");
    public static final RegistrySupplier<SoundEvent> HAMSTER_HURT2 = registerSoundEvent("hamster_hurt2");
    public static final RegistrySupplier<SoundEvent> HAMSTER_HURT3 = registerSoundEvent("hamster_hurt3");
    public static final RegistrySupplier<SoundEvent> HAMSTER_HURT4 = registerSoundEvent("hamster_hurt4");
    public static final RegistrySupplier<SoundEvent> HAMSTER_HURT5 = registerSoundEvent("hamster_hurt5");
    public static final RegistrySupplier<SoundEvent> HAMSTER_HURT6 = registerSoundEvent("hamster_hurt6");
    public static final RegistrySupplier<SoundEvent> HAMSTER_HURT7 = registerSoundEvent("hamster_hurt7");
    public static final RegistrySupplier<SoundEvent> HAMSTER_HURT8 = registerSoundEvent("hamster_hurt8");
    public static final RegistrySupplier<SoundEvent> HAMSTER_HURT9 = registerSoundEvent("hamster_hurt9");
    public static final RegistrySupplier<SoundEvent> HAMSTER_HURT10 = registerSoundEvent("hamster_hurt10");

    // --- Idle Sounds (1-11) ---
    public static final RegistrySupplier<SoundEvent> HAMSTER_IDLE1 = registerSoundEvent("hamster_idle1");
    public static final RegistrySupplier<SoundEvent> HAMSTER_IDLE2 = registerSoundEvent("hamster_idle2");
    public static final RegistrySupplier<SoundEvent> HAMSTER_IDLE3 = registerSoundEvent("hamster_idle3");
    public static final RegistrySupplier<SoundEvent> HAMSTER_IDLE4 = registerSoundEvent("hamster_idle4");
    public static final RegistrySupplier<SoundEvent> HAMSTER_IDLE5 = registerSoundEvent("hamster_idle5");
    public static final RegistrySupplier<SoundEvent> HAMSTER_IDLE6 = registerSoundEvent("hamster_idle6");
    public static final RegistrySupplier<SoundEvent> HAMSTER_IDLE7 = registerSoundEvent("hamster_idle7");
    public static final RegistrySupplier<SoundEvent> HAMSTER_IDLE8 = registerSoundEvent("hamster_idle8");
    public static final RegistrySupplier<SoundEvent> HAMSTER_IDLE9 = registerSoundEvent("hamster_idle9");
    public static final RegistrySupplier<SoundEvent> HAMSTER_IDLE10 = registerSoundEvent("hamster_idle10");
    public static final RegistrySupplier<SoundEvent> HAMSTER_IDLE11 = registerSoundEvent("hamster_idle11");

    // --- Sleep Sounds (1-9) ---
    public static final RegistrySupplier<SoundEvent> HAMSTER_SLEEP1 = registerSoundEvent("hamster_sleep1");
    public static final RegistrySupplier<SoundEvent> HAMSTER_SLEEP2 = registerSoundEvent("hamster_sleep2");
    public static final RegistrySupplier<SoundEvent> HAMSTER_SLEEP3 = registerSoundEvent("hamster_sleep3");
    public static final RegistrySupplier<SoundEvent> HAMSTER_SLEEP4 = registerSoundEvent("hamster_sleep4");
    public static final RegistrySupplier<SoundEvent> HAMSTER_SLEEP5 = registerSoundEvent("hamster_sleep5");
    public static final RegistrySupplier<SoundEvent> HAMSTER_SLEEP6 = registerSoundEvent("hamster_sleep6");
    public static final RegistrySupplier<SoundEvent> HAMSTER_SLEEP7 = registerSoundEvent("hamster_sleep7");
    public static final RegistrySupplier<SoundEvent> HAMSTER_SLEEP8 = registerSoundEvent("hamster_sleep8");
    public static final RegistrySupplier<SoundEvent> HAMSTER_SLEEP9 = registerSoundEvent("hamster_sleep9");

    // --- Wake Up Sounds (1-3) ---
    public static final RegistrySupplier<SoundEvent> HAMSTER_WAKE_UP1 = registerSoundEvent("hamster_wake_up1");
    public static final RegistrySupplier<SoundEvent> HAMSTER_WAKE_UP2 = registerSoundEvent("hamster_wake_up2");
    public static final RegistrySupplier<SoundEvent> HAMSTER_WAKE_UP3 = registerSoundEvent("hamster_wake_up3");

    // --- Cheese Sounds ---
    public static final RegistrySupplier<SoundEvent> CHEESE_USE_SOUND = registerSoundEvent("cheese_use");
    public static final RegistrySupplier<SoundEvent> CHEESE_EAT1 = registerSoundEvent("cheese_eat1");
    public static final RegistrySupplier<SoundEvent> CHEESE_EAT2 = registerSoundEvent("cheese_eat2");
    public static final RegistrySupplier<SoundEvent> CHEESE_EAT3 = registerSoundEvent("cheese_eat3");

    // --- Shoulder Mount/Dismount Sounds ---
    public static final RegistrySupplier<SoundEvent> HAMSTER_MOUNT1 = registerSoundEvent("hamster_mount1");
    public static final RegistrySupplier<SoundEvent> HAMSTER_MOUNT2 = registerSoundEvent("hamster_mount2");
    public static final RegistrySupplier<SoundEvent> HAMSTER_MOUNT3 = registerSoundEvent("hamster_mount3");
    public static final RegistrySupplier<SoundEvent> HAMSTER_DISMOUNT = registerSoundEvent("hamster_dismount");

    // --- Cleaning Sound ---
    public static final RegistrySupplier<SoundEvent> HAMSTER_SCRATCH = registerSoundEvent("hamster_scratch");

    // --- Shocked Sounds (for when the hamster accidentally finds gold ore instead of diamond) ---
    public static final RegistrySupplier<SoundEvent> ALARM_ORCHESTRA_HIT = registerSoundEvent("alarm_orchestra_hit");
    public static final RegistrySupplier<SoundEvent> HAMSTER_SHOCKED = registerSoundEvent("hamster_shocked");

    // --- Affection Sounds (1-3) ---
    public static final RegistrySupplier<SoundEvent> HAMSTER_AFFECTION1 = registerSoundEvent("hamster_affection1");
    public static final RegistrySupplier<SoundEvent> HAMSTER_AFFECTION2 = registerSoundEvent("hamster_affection2");
    public static final RegistrySupplier<SoundEvent> HAMSTER_AFFECTION3 = registerSoundEvent("hamster_affection3");

    // --- Diamond Sparkle Sounds (1-3) ---
    public static final RegistrySupplier<SoundEvent> DIAMOND_SPARKLE1 = registerSoundEvent("diamond_sparkle1");
    public static final RegistrySupplier<SoundEvent> DIAMOND_SPARKLE2 = registerSoundEvent("diamond_sparkle2");
    public static final RegistrySupplier<SoundEvent> DIAMOND_SPARKLE3 = registerSoundEvent("diamond_sparkle3");

    // --- Pounce Sound ---
    public static final RegistrySupplier<SoundEvent> HAMSTER_DIAMOND_POUNCE = registerSoundEvent("hamster_diamond_pounce");

    // --- Shoulder Impact Sounds (1-3) ---
    public static final RegistrySupplier<SoundEvent> HAMSTER_SHOULDER_IMPACT1 = registerSoundEvent("hamster_shoulder_impact1");
    public static final RegistrySupplier<SoundEvent> HAMSTER_SHOULDER_IMPACT2 = registerSoundEvent("hamster_shoulder_impact2");
    public static final RegistrySupplier<SoundEvent> HAMSTER_SHOULDER_IMPACT3 = registerSoundEvent("hamster_shoulder_impact3");

    // --- Hamster Bed Sounds ---
    public static final RegistrySupplier<SoundEvent> HAMSTER_BED_LEAVES_RUSTLE1 = registerSoundEvent("hamster_bed_leaves_rustle1");
    public static final RegistrySupplier<SoundEvent> HAMSTER_BED_LEAVES_RUSTLE2 = registerSoundEvent("hamster_bed_leaves_rustle2");
    public static final RegistrySupplier<SoundEvent> HAMSTER_BED_LEAVES_RUSTLE3 = registerSoundEvent("hamster_bed_leaves_rustle3");

    // --- 3. Public Sound Lists (using RegistrySuppliers) ---
    public static final List<RegistrySupplier<SoundEvent>> HAMSTER_ATTACK_SOUNDS = List.of(HAMSTER_ATTACK1, HAMSTER_ATTACK2, HAMSTER_ATTACK3, HAMSTER_ATTACK4);
    public static final List<RegistrySupplier<SoundEvent>> HAMSTER_IDLE_SOUNDS = List.of(HAMSTER_IDLE1, HAMSTER_IDLE2, HAMSTER_IDLE3, HAMSTER_IDLE4, HAMSTER_IDLE5, HAMSTER_IDLE6, HAMSTER_IDLE7, HAMSTER_IDLE8, HAMSTER_IDLE9, HAMSTER_IDLE10, HAMSTER_IDLE11);
    public static final List<RegistrySupplier<SoundEvent>> HAMSTER_SLEEP_SOUNDS = List.of(HAMSTER_SLEEP1, HAMSTER_SLEEP2, HAMSTER_SLEEP3, HAMSTER_SLEEP4, HAMSTER_SLEEP5, HAMSTER_SLEEP6, HAMSTER_SLEEP7, HAMSTER_SLEEP8, HAMSTER_SLEEP9);
    public static final List<RegistrySupplier<SoundEvent>> HAMSTER_HURT_SOUNDS = List.of(HAMSTER_HURT1, HAMSTER_HURT2, HAMSTER_HURT3, HAMSTER_HURT4, HAMSTER_HURT5, HAMSTER_HURT6, HAMSTER_HURT7, HAMSTER_HURT8, HAMSTER_HURT9, HAMSTER_HURT10);
    public static final List<RegistrySupplier<SoundEvent>> HAMSTER_DEATH_SOUNDS = List.of(HAMSTER_DEATH1, HAMSTER_DEATH2, HAMSTER_DEATH3, HAMSTER_DEATH4);
    public static final List<RegistrySupplier<SoundEvent>> HAMSTER_BEG_SOUNDS = List.of(HAMSTER_BEG1, HAMSTER_BEG2, HAMSTER_BEG3, HAMSTER_BEG4, HAMSTER_BEG5);
    public static final List<RegistrySupplier<SoundEvent>> HAMSTER_CREEPER_DETECT_SOUNDS = List.of(HAMSTER_CREEPER_DETECT1, HAMSTER_CREEPER_DETECT2, HAMSTER_CREEPER_DETECT3, HAMSTER_CREEPER_DETECT4);
    public static final List<RegistrySupplier<SoundEvent>> HAMSTER_DIAMOND_SNIFF_SOUNDS = List.of(HAMSTER_SNIFF1, HAMSTER_SNIFF2, HAMSTER_SNIFF3, HAMSTER_SNIFF4);
    public static final List<RegistrySupplier<SoundEvent>> HAMSTER_CELEBRATE_SOUNDS = List.of(HAMSTER_CELEBRATE1, HAMSTER_CELEBRATE2, HAMSTER_CELEBRATE3, HAMSTER_CELEBRATE4);
    public static final List<RegistrySupplier<SoundEvent>> HAMSTER_FLYING_SOUNDS = List.of(HAMSTER_WOW, HAMSTER_AIRBORNE_CELEBRATION);
    public static final List<RegistrySupplier<SoundEvent>> HAMSTER_WAKE_UP_SOUNDS = List.of(HAMSTER_WAKE_UP1, HAMSTER_WAKE_UP2, HAMSTER_WAKE_UP3);
    public static final List<RegistrySupplier<SoundEvent>> CHEESE_EAT_SOUNDS = List.of(CHEESE_EAT1, CHEESE_EAT2, CHEESE_EAT3);
    public static final List<RegistrySupplier<SoundEvent>> HAMSTER_SHOULDER_MOUNT_SOUNDS = List.of(HAMSTER_MOUNT1, HAMSTER_MOUNT2, HAMSTER_MOUNT3);
    public static final List<RegistrySupplier<SoundEvent>> HAMSTER_BOUNCE_SOUNDS = List.of(HAMSTER_BOUNCE);
    public static final List<RegistrySupplier<SoundEvent>> HAMSTER_AFFECTION_SOUNDS = List.of(HAMSTER_AFFECTION1, HAMSTER_AFFECTION2, HAMSTER_AFFECTION3);
    public static final List<RegistrySupplier<SoundEvent>> DIAMOND_SPARKLE_SOUNDS = List.of(DIAMOND_SPARKLE1, DIAMOND_SPARKLE2, DIAMOND_SPARKLE3);
    public static final List<RegistrySupplier<SoundEvent>> HAMSTER_SHOULDER_IMPACT_SOUNDS = List.of(HAMSTER_SHOULDER_IMPACT1, HAMSTER_SHOULDER_IMPACT2, HAMSTER_SHOULDER_IMPACT3);
    public static final List<RegistrySupplier<SoundEvent>> HAMSTER_BED_LEAVES_RUSTLE_SOUNDS = List.of(HAMSTER_BED_LEAVES_RUSTLE1, HAMSTER_BED_LEAVES_RUSTLE2, HAMSTER_BED_LEAVES_RUSTLE3);

    // --- 4. Helper Methods ---
    private static RegistrySupplier<SoundEvent> registerSoundEvent(String name) {
        Identifier id = Identifier.of(AdorableHamsterPets.MOD_ID, name);
        return SOUND_EVENTS.register(id, () -> SoundEvent.of(id));
    }

    /**
     * Determines an appropriate interaction sound based on the properties of an item.
     * This method categorizes items using extensive keyword lists and component checks
     * to return one of several possible sound events.
     *
     * @param stack The ItemStack to be evaluated.
     * @return The most fitting SoundEvent for the item ("clink", "stone", "wood", "squish", "crunch", or "thud").
     */
    public static SoundEvent getDynamicItemSound(ItemStack stack) {
        if (stack.isEmpty()) {
            return SoundEvents.BLOCK_WOOL_PLACE; // Fallback for safety
        }
        Item item = stack.getItem();
        String translationKey = item.getTranslationKey();

        // --- Keyword Lists for Sound Categories ---
        List<String> clinkKeywords = List.of(
                "diamond", "emerald", "amethyst", "lapis", "quartz", "raw_", "coal",
                "ingot", "nugget", "netherite", "gold", "iron", "copper", "scrap", "shard",
                "brick", "sherd", "flint", "prismarine", "rod", "glass", "bottle", "spyglass",
                "tear", "pearl", "eye", "bell", "trim", "charcoal", "bucket", "shears", "hoe",
                "axe", "pickaxe", "shovel", "sword"
        );

        List<String> stoneKeywords = List.of(
                "stone", "rock", "ore", "andesite", "diorite", "granite", "deepslate",
                "tuff", "calcite", "netherrack", "dust", "basalt", "obsidian", "gravel", "clay",
                "terracotta", "concrete", "powder", "sugar", "bone_meal", "egg", "snowball"
        );

        List<String> woodKeywords = List.of(
                "log", "wood", "planks", "stick", "sapling", "door", "trapdoor", "sign",
                "boat", "bowl", "chest", "table", "lectern", "loom", "composter", "barrel", "ladder",
                "fence", "gate", "plate", "button", "torch", "arrow", "bow", "scaffolding", "bamboo",
                "propagule", "roots", "cherry", "acacia", "birch", "dark_oak", "jungle", "oak", "spruce"
        );

        List<String> squishKeywords = List.of(
                "cheese", "flesh", "slime", "magma", "honey", "kelp", "moss", "fungus", "wart",
                "guts", "ink", "moist", "wet", "leaf", "lily", "pad", "vine", "pickle", "cucumber", "beans",
                "chorus_fruit", "berries", "cabbage", "tomato", "rice", "pumpkin", "corn", "egg", "pork",
                "beef", "mutton", "chicken", "rabbit", "cod", "salmon", "spore", "dripleaf", "warped", "stem"
        );

        // --- Check Categories in Order of Priority ---
        for (String keyword : clinkKeywords) {
            if (translationKey.contains(keyword)) {
                return ModSounds.HAMSTER_DIAMOND_POUNCE.get(); // "Clink" (for metallic items)
            }
        }
        for (String keyword : stoneKeywords) {
            if (translationKey.contains(keyword)) {
                return SoundEvents.BLOCK_STONE_PLACE; // "Scuff" (for stony items)
            }
        }
        for (String keyword : woodKeywords) {
            if (translationKey.contains(keyword)) {
                return SoundEvents.BLOCK_WOOD_PLACE; // "Thud" (for wooden items)
            }
        }
        for (String keyword : squishKeywords) {
            if (translationKey.contains(keyword)) {
                return ModSounds.CHEESE_USE_SOUND.get(); // "Squish" (for wet/moist items)
            }
        }
        if (item.isFood()) {
            return SoundEvents.ENTITY_GENERIC_EAT; // "Crunch" (for food items)
        }
        // --- Fallback for everything else ---
        return SoundEvents.BLOCK_WOOL_PLACE; // "Fump" (for generic/soft items)
    }

    // --- 5. Main Registration Call ---
    public static void register() {
        SOUND_EVENTS.register();
    }

    // --- 6. Helper Method for Random Sound Selection (Updated) ---
    public static SoundEvent getRandomSoundFrom(List<RegistrySupplier<SoundEvent>> sounds, Random random) {
        if (sounds == null || sounds.isEmpty()) {
            AdorableHamsterPets.LOGGER.warn("Attempted to get random sound from empty or null list!");
            return null;
        }
        return sounds.get(random.nextInt(sounds.size())).get();
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/advancement/criterion/`
`AppliedPinkPetalCriterion.java`
```java
package net.dawson.adorablehamsterpets.advancement.criterion;

// (Imports omitted to save token count)

public class AppliedPinkPetalCriterion extends AbstractCriterion<AppliedPinkPetalCriterion.Conditions> {
    private final Identifier id;

    public AppliedPinkPetalCriterion(Identifier id) {
        this.id = id;
    }

    @Override
    public Identifier getId() {
        return this.id;
    }

    @Override
    public AppliedPinkPetalCriterion.Conditions conditionsFromJson(JsonObject jsonObject, LootContextPredicate playerPredicate, AdvancementEntityPredicateDeserializer predicateDeserializer) {
        LootContextPredicate hamsterPredicate = EntityPredicate.contextPredicateFromJson(jsonObject, "hamster", predicateDeserializer);
        return new AppliedPinkPetalCriterion.Conditions(this.id, playerPredicate, hamsterPredicate);
    }

    public void trigger(ServerPlayerEntity player, HamsterEntity hamster) {
        LootContext hamsterContext = EntityPredicate.createAdvancementEntityLootContext(player, hamster);
        this.trigger(player, (conditions) -> conditions.matches(hamsterContext));
    }

    public static class Conditions extends AbstractCriterionConditions {
        private final LootContextPredicate hamster;

        public Conditions(Identifier id, LootContextPredicate player, LootContextPredicate hamster) {
            super(id, player);
            this.hamster = hamster;
        }

        public boolean matches(LootContext hamsterContext) {
            return this.hamster.test(hamsterContext);
        }
    }
}
```

`CheekPouchUnlockedCriterion.java`
```java
package net.dawson.adorablehamsterpets.advancement.criterion;

// (Imports omitted to save token count)

public class CheekPouchUnlockedCriterion extends AbstractCriterion<CheekPouchUnlockedCriterion.Conditions> {
    private final Identifier id;

    public CheekPouchUnlockedCriterion(Identifier id) {
        this.id = id;
    }

    @Override
    public Identifier getId() {
        return this.id;
    }

    @Override
    public CheekPouchUnlockedCriterion.Conditions conditionsFromJson(JsonObject jsonObject, LootContextPredicate playerPredicate, AdvancementEntityPredicateDeserializer predicateDeserializer) {
        LootContextPredicate hamsterPredicate = EntityPredicate.contextPredicateFromJson(jsonObject, "hamster", predicateDeserializer);
        return new CheekPouchUnlockedCriterion.Conditions(this.id, playerPredicate, hamsterPredicate);
    }

    public void trigger(ServerPlayerEntity player, HamsterEntity hamster) {
        LootContext hamsterContext = EntityPredicate.createAdvancementEntityLootContext(player, hamster);
        this.trigger(player, (conditions) -> conditions.matches(hamsterContext));
    }

    public static class Conditions extends AbstractCriterionConditions {
        private final LootContextPredicate hamster;

        public Conditions(Identifier id, LootContextPredicate player, LootContextPredicate hamster) {
            super(id, player);
            this.hamster = hamster;
        }

        public boolean matches(LootContext hamsterContext) {
            return this.hamster.test(hamsterContext);
        }
    }
}
```

`DispensedHamsterBeddingCriterion.java`
```java
package net.dawson.adorablehamsterpets.advancement.criterion;

// (Imports omitted to save token count)

public class DispensedHamsterBeddingCriterion extends AbstractCriterion<DispensedHamsterBeddingCriterion.Conditions> {
    private final Identifier id;

    public DispensedHamsterBeddingCriterion(Identifier id) {
        this.id = id;
    }

    @Override
    public Identifier getId() {
        return this.id;
    }

    @Override
    public Conditions conditionsFromJson(JsonObject obj, LootContextPredicate playerPredicate, AdvancementEntityPredicateDeserializer predicateDeserializer) {
        return new Conditions(this.id, playerPredicate);
    }

    public void trigger(ServerPlayerEntity player) {
        this.trigger(player, conditions -> true);
    }

    public static class Conditions extends AbstractCriterionConditions {
        public Conditions(Identifier id, LootContextPredicate playerPredicate) {
            super(id, playerPredicate);
        }
    }
}
```

`FedHamsterSteamedBeansCriterion.java`
```java
package net.dawson.adorablehamsterpets.advancement.criterion;

// (Imports omitted to save token count)

public class FedHamsterSteamedBeansCriterion extends AbstractCriterion<FedHamsterSteamedBeansCriterion.Conditions> {
    private final Identifier id;

    public FedHamsterSteamedBeansCriterion(Identifier id) {
        this.id = id;
    }

    @Override
    public Identifier getId() {
        return this.id;
    }

    @Override
    public FedHamsterSteamedBeansCriterion.Conditions conditionsFromJson(JsonObject jsonObject, LootContextPredicate playerPredicate, AdvancementEntityPredicateDeserializer predicateDeserializer) {
        LootContextPredicate hamsterPredicate = EntityPredicate.contextPredicateFromJson(jsonObject, "hamster", predicateDeserializer);
        return new FedHamsterSteamedBeansCriterion.Conditions(this.id, playerPredicate, hamsterPredicate);
    }

    public void trigger(ServerPlayerEntity player, HamsterEntity hamster) {
        LootContext hamsterContext = EntityPredicate.createAdvancementEntityLootContext(player, hamster);
        this.trigger(player, (conditions) -> conditions.matches(hamsterContext));
    }

    public static class Conditions extends AbstractCriterionConditions {
        private final LootContextPredicate hamster;

        public Conditions(Identifier id, LootContextPredicate player, LootContextPredicate hamster) {
            super(id, player);
            this.hamster = hamster;
        }

        public boolean matches(LootContext hamsterContext) {
            return this.hamster.test(hamsterContext);
        }
    }
}
```

`HamsterAutoFedCriterion.java`
```java
package net.dawson.adorablehamsterpets.advancement.criterion;

// (Imports omitted to save token count)

public class HamsterAutoFedCriterion extends AbstractCriterion<HamsterAutoFedCriterion.Conditions> {
    private final Identifier id;

    public HamsterAutoFedCriterion(Identifier id) {
        this.id = id;
    }

    @Override
    public Identifier getId() {
        return this.id;
    }

    @Override
    public HamsterAutoFedCriterion.Conditions conditionsFromJson(JsonObject jsonObject, LootContextPredicate playerPredicate, AdvancementEntityPredicateDeserializer predicateDeserializer) {
        LootContextPredicate hamsterPredicate = EntityPredicate.contextPredicateFromJson(jsonObject, "hamster", predicateDeserializer);
        return new HamsterAutoFedCriterion.Conditions(this.id, playerPredicate, hamsterPredicate);
    }

    public void trigger(ServerPlayerEntity player, HamsterEntity hamster) {
        LootContext hamsterContext = EntityPredicate.createAdvancementEntityLootContext(player, hamster);
        this.trigger(player, (conditions) -> conditions.matches(hamsterContext));
    }

    public static class Conditions extends AbstractCriterionConditions {
        private final LootContextPredicate hamster;

        public Conditions(Identifier id, LootContextPredicate player, LootContextPredicate hamster) {
            super(id, player);
            this.hamster = hamster;
        }

        public boolean matches(LootContext hamsterContext) {
            return this.hamster.test(hamsterContext);
        }
    }
}
```

`HamsterBedLinkedCriterion.java`
```java
package net.dawson.adorablehamsterpets.advancement.criterion;

// (Imports omitted to save token count)

public class HamsterBedLinkedCriterion extends AbstractCriterion<HamsterBedLinkedCriterion.Conditions> {
    private final Identifier id;

    public HamsterBedLinkedCriterion(Identifier id) {
        this.id = id;
    }

    @Override
    public Identifier getId() {
        return this.id;
    }

    @Override
    public Conditions conditionsFromJson(JsonObject obj, LootContextPredicate playerPredicate, AdvancementEntityPredicateDeserializer predicateDeserializer) {
        return new Conditions(this.id, playerPredicate);
    }

    public void trigger(ServerPlayerEntity player) {
        this.trigger(player, conditions -> true);
    }

    public static class Conditions extends AbstractCriterionConditions {
        public Conditions(Identifier id, LootContextPredicate playerPredicate) {
            super(id, playerPredicate);
        }
    }
}
```

`HamsterBedPlacedUpsideDownCriterion.java`
```java
package net.dawson.adorablehamsterpets.advancement.criterion;

// (Imports omitted to save token count)

public class HamsterBedPlacedUpsideDownCriterion extends AbstractCriterion<HamsterBedPlacedUpsideDownCriterion.Conditions> {
    private final Identifier id;

    public HamsterBedPlacedUpsideDownCriterion(Identifier id) {
        this.id = id;
    }

    @Override
    public Identifier getId() {
        return this.id;
    }

    @Override
    public Conditions conditionsFromJson(JsonObject obj, LootContextPredicate playerPredicate, AdvancementEntityPredicateDeserializer predicateDeserializer) {
        return new Conditions(this.id, playerPredicate);
    }

    public void trigger(ServerPlayerEntity player) {
        this.trigger(player, conditions -> true);
    }

    public static class Conditions extends AbstractCriterionConditions {
        public Conditions(Identifier id, LootContextPredicate playerPredicate) {
            super(id, playerPredicate);
        }
    }
}
```

`HamsterCreeperAlertCriterion.java`
```java
package net.dawson.adorablehamsterpets.advancement.criterion;

// (Imports omitted to save token count)

public class HamsterCreeperAlertCriterion extends AbstractCriterion<HamsterCreeperAlertCriterion.Conditions> {
    private final Identifier id;

    public HamsterCreeperAlertCriterion(Identifier id) {
        this.id = id;
    }

    @Override
    public Identifier getId() {
        return this.id;
    }

    @Override
    public HamsterCreeperAlertCriterion.Conditions conditionsFromJson(JsonObject jsonObject, LootContextPredicate playerPredicate, AdvancementEntityPredicateDeserializer predicateDeserializer) {
        return new HamsterCreeperAlertCriterion.Conditions(this.id, playerPredicate);
    }

    public void trigger(ServerPlayerEntity player) {
        this.trigger(player, (conditions) -> true);
    }

    public static class Conditions extends AbstractCriterionConditions {
        public Conditions(Identifier id, LootContextPredicate player) {
            super(id, player);
        }
    }
}
```

`HamsterDiamondAlertCriterion.java`
```java
package net.dawson.adorablehamsterpets.advancement.criterion;

// (Imports omitted to save token count)

public class HamsterDiamondAlertCriterion extends AbstractCriterion<HamsterDiamondAlertCriterion.Conditions> {
    private final Identifier id;

    public HamsterDiamondAlertCriterion(Identifier id) {
        this.id = id;
    }

    @Override
    public Identifier getId() {
        return this.id;
    }

    @Override
    public HamsterDiamondAlertCriterion.Conditions conditionsFromJson(JsonObject jsonObject, LootContextPredicate playerPredicate, AdvancementEntityPredicateDeserializer predicateDeserializer) {
        return new HamsterDiamondAlertCriterion.Conditions(this.id, playerPredicate);
    }

    public void trigger(ServerPlayerEntity player) {
        this.trigger(player, (conditions) -> true);
    }

    public static class Conditions extends AbstractCriterionConditions {
        public Conditions(Identifier id, LootContextPredicate player) {
            super(id, player);
        }
    }
}
```

`HamsterFoundGoldCriterion.java`
```java
package net.dawson.adorablehamsterpets.advancement.criterion;

// (Imports omitted to save token count)

public class HamsterFoundGoldCriterion extends AbstractCriterion<HamsterFoundGoldCriterion.Conditions> {
    private final Identifier id;

    public HamsterFoundGoldCriterion(Identifier id) {
        this.id = id;
    }

    @Override
    public Identifier getId() {
        return this.id;
    }

    @Override
    public HamsterFoundGoldCriterion.Conditions conditionsFromJson(JsonObject jsonObject, LootContextPredicate playerPredicate, AdvancementEntityPredicateDeserializer predicateDeserializer) {
        return new HamsterFoundGoldCriterion.Conditions(this.id, playerPredicate);
    }

    public void trigger(ServerPlayerEntity player) {
        this.trigger(player, (conditions) -> true);
    }

    public static class Conditions extends AbstractCriterionConditions {
        public Conditions(Identifier id, LootContextPredicate player) {
            super(id, player);
        }
    }
}
```

`HamsterLedToDiamondCriterion.java`
```java
package net.dawson.adorablehamsterpets.advancement.criterion;

// (Imports omitted to save token count)

public class HamsterLedToDiamondCriterion extends AbstractCriterion<HamsterLedToDiamondCriterion.Conditions> {
    private final Identifier id;

    public HamsterLedToDiamondCriterion(Identifier id) {
        this.id = id;
    }

    @Override
    public Identifier getId() {
        return this.id;
    }

    @Override
    public HamsterLedToDiamondCriterion.Conditions conditionsFromJson(JsonObject jsonObject, LootContextPredicate playerPredicate, AdvancementEntityPredicateDeserializer predicateDeserializer) {
        LootContextPredicate hamsterPredicate = EntityPredicate.contextPredicateFromJson(jsonObject, "hamster", predicateDeserializer);
        BlockPredicate oreBlockPredicate = BlockPredicate.fromJson(jsonObject.get("ore_block"));
        return new HamsterLedToDiamondCriterion.Conditions(this.id, playerPredicate, hamsterPredicate, oreBlockPredicate);
    }

    public void trigger(ServerPlayerEntity player, HamsterEntity hamster, BlockPos orePos) {
        LootContext hamsterContext = EntityPredicate.createAdvancementEntityLootContext(player, hamster);
        this.trigger(player, (conditions) -> conditions.matches(hamsterContext, (ServerWorld) player.getWorld(), orePos));
    }

    public static class Conditions extends AbstractCriterionConditions {
        private final LootContextPredicate hamster;
        private final BlockPredicate oreBlock;

        public Conditions(Identifier id, LootContextPredicate player, LootContextPredicate hamster, BlockPredicate oreBlock) {
            super(id, player);
            this.hamster = hamster;
            this.oreBlock = oreBlock;
        }

        public boolean matches(LootContext hamsterContext, ServerWorld world, BlockPos pos) {
            if (!this.hamster.test(hamsterContext)) {
                return false;
            }
            return this.oreBlock.test(world, pos);
        }
    }
}
```

`HamsterOnShoulderCriterion.java`
```java
package net.dawson.adorablehamsterpets.advancement.criterion;

// (Imports omitted to save token count)

public class HamsterOnShoulderCriterion extends AbstractCriterion<HamsterOnShoulderCriterion.Conditions> {
    private final Identifier id;

    public HamsterOnShoulderCriterion(Identifier id) {
        this.id = id;
    }

    @Override
    public Identifier getId() {
        return this.id;
    }

    @Override
    public HamsterOnShoulderCriterion.Conditions conditionsFromJson(JsonObject jsonObject, LootContextPredicate playerPredicate, AdvancementEntityPredicateDeserializer predicateDeserializer) {
        return new HamsterOnShoulderCriterion.Conditions(this.id, playerPredicate);
    }

    public void trigger(ServerPlayerEntity player) {
        this.trigger(player, (conditions) -> true);
    }

    public static class Conditions extends AbstractCriterionConditions {
        public Conditions(Identifier id, LootContextPredicate player) {
            super(id, player);
        }
    }
}
```

`HamsterPouchFilledCriterion.java`
```java
package net.dawson.adorablehamsterpets.advancement.criterion;

// (Imports omitted to save token count)

public class HamsterPouchFilledCriterion extends AbstractCriterion<HamsterPouchFilledCriterion.Conditions> {
    private final Identifier id;

    public HamsterPouchFilledCriterion(Identifier id) {
        this.id = id;
    }

    @Override
    public Identifier getId() {
        return this.id;
    }

    @Override
    public HamsterPouchFilledCriterion.Conditions conditionsFromJson(JsonObject jsonObject, LootContextPredicate playerPredicate, AdvancementEntityPredicateDeserializer predicateDeserializer) {
        LootContextPredicate hamsterPredicate = EntityPredicate.contextPredicateFromJson(jsonObject, "hamster", predicateDeserializer);
        return new HamsterPouchFilledCriterion.Conditions(this.id, playerPredicate, hamsterPredicate);
    }

    public void trigger(ServerPlayerEntity player, HamsterEntity hamster) {
        LootContext hamsterContext = EntityPredicate.createAdvancementEntityLootContext(player, hamster);
        this.trigger(player, (conditions) -> conditions.matches(hamsterContext));
    }

    public static class Conditions extends AbstractCriterionConditions {
        private final LootContextPredicate hamster;

        public Conditions(Identifier id, LootContextPredicate player, LootContextPredicate hamster) {
            super(id, player);
            this.hamster = hamster;
        }

        public boolean matches(LootContext hamsterContext) {
            return this.hamster.test(hamsterContext);
        }
    }
}
```

`HamsterSleptInBedCriterion.java`
```java
package net.dawson.adorablehamsterpets.advancement.criterion;

// (Imports omitted to save token count)

public class HamsterSleptInBedCriterion extends AbstractCriterion<HamsterSleptInBedCriterion.Conditions> {
    private final Identifier id;

    public HamsterSleptInBedCriterion(Identifier id) {
        this.id = id;
    }

    @Override
    public Identifier getId() {
        return this.id;
    }

    @Override
    public Conditions conditionsFromJson(JsonObject obj, LootContextPredicate playerPredicate, AdvancementEntityPredicateDeserializer predicateDeserializer) {
        return new Conditions(this.id, playerPredicate);
    }

    public void trigger(ServerPlayerEntity player) {
        this.trigger(player, conditions -> true);
    }

    public static class Conditions extends AbstractCriterionConditions {
        public Conditions(Identifier id, LootContextPredicate playerPredicate) {
            super(id, playerPredicate);
        }
    }
}
```

`HamsterThrownCriterion.java`
```java
package net.dawson.adorablehamsterpets.advancement.criterion;

// (Imports omitted to save token count)

public class HamsterThrownCriterion extends AbstractCriterion<HamsterThrownCriterion.Conditions> {
    private final Identifier id;

    public HamsterThrownCriterion(Identifier id) {
        this.id = id;
    }

    @Override
    public Identifier getId() {
        return this.id;
    }

    @Override
    public HamsterThrownCriterion.Conditions conditionsFromJson(JsonObject jsonObject, LootContextPredicate playerPredicate, AdvancementEntityPredicateDeserializer predicateDeserializer) {
        return new HamsterThrownCriterion.Conditions(this.id, playerPredicate);
    }

    public void trigger(ServerPlayerEntity player) {
        this.trigger(player, (conditions) -> true);
    }

    public static class Conditions extends AbstractCriterionConditions {
        public Conditions(Identifier id, LootContextPredicate player) {
            super(id, player);
        }
    }
}
```

`ModCriteria.java`
```java
package net.dawson.adorablehamsterpets.advancement.criterion;

// (Imports omitted to save token count)

public class ModCriteria {

    // --- Define Criterion Instances ---
    public static final HamsterOnShoulderCriterion HAMSTER_ON_SHOULDER = new HamsterOnShoulderCriterion(Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_on_shoulder"));
    public static final HamsterThrownCriterion HAMSTER_THROWN = new HamsterThrownCriterion(Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_thrown"));
    public static final FedHamsterSteamedBeansCriterion FED_HAMSTER_STEAMED_BEANS = new FedHamsterSteamedBeansCriterion(Identifier.of(AdorableHamsterPets.MOD_ID, "fed_hamster_steamed_beans"));
    public static final CheekPouchUnlockedCriterion CHEEK_POUCH_UNLOCKED = new CheekPouchUnlockedCriterion(Identifier.of(AdorableHamsterPets.MOD_ID, "cheek_pouch_unlocked"));
    public static final AppliedPinkPetalCriterion APPLIED_PINK_PETAL = new AppliedPinkPetalCriterion(Identifier.of(AdorableHamsterPets.MOD_ID, "applied_pink_petal"));
    public static final HamsterAutoFedCriterion HAMSTER_AUTO_FED = new HamsterAutoFedCriterion(Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_auto_fed"));
    public static final HamsterDiamondAlertCriterion HAMSTER_DIAMOND_ALERT_TRIGGERED = new HamsterDiamondAlertCriterion(Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_diamond_alert_triggered"));
    public static final HamsterCreeperAlertCriterion HAMSTER_CREEPER_ALERT_TRIGGERED = new HamsterCreeperAlertCriterion(Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_creeper_alert_triggered"));
    public static final HamsterPouchFilledCriterion HAMSTER_POUCH_FILLED = new HamsterPouchFilledCriterion(Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_pouch_filled"));
    public static final HamsterLedToDiamondCriterion HAMSTER_LED_TO_DIAMOND = new HamsterLedToDiamondCriterion(Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_led_to_diamond"));
    public static final HamsterFoundGoldCriterion HAMSTER_FOUND_GOLD = new HamsterFoundGoldCriterion(Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_found_gold"));
    public static final HamsterBedLinkedCriterion HAMSTER_BED_LINKED = new HamsterBedLinkedCriterion(Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_bed_linked"));
    public static final HamsterSleptInBedCriterion HAMSTER_SLEPT_IN_BED = new HamsterSleptInBedCriterion(Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_slept_in_bed"));
    public static final UsedHamsterBeddingCriterion USED_HAMSTER_BEDDING = new UsedHamsterBeddingCriterion(Identifier.of(AdorableHamsterPets.MOD_ID, "used_hamster_bedding"));
    public static final HamsterBedPlacedUpsideDownCriterion HAMSTER_BED_PLACED_UPSIDE_DOWN = new HamsterBedPlacedUpsideDownCriterion(Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_bed_placed_upside_down"));
    public static final DispensedHamsterBeddingCriterion DISPENSED_HAMSTER_BEDDING = new DispensedHamsterBeddingCriterion(Identifier.of(AdorableHamsterPets.MOD_ID, "dispensed_hamster_bedding"));

    /**
     * Registers a criterion with Minecraft's advancement system.
     * @param criterion The criterion instance to register.
     * @return The registered criterion instance.
     */
    private static <T extends Criterion<?>> T register(T criterion) {
        return Criteria.register(criterion);
    }

    /**
     * Main registration call. This method ensures all custom criteria are registered.
     */
    public static void register() {
        register(HAMSTER_ON_SHOULDER);
        register(HAMSTER_THROWN);
        register(FED_HAMSTER_STEAMED_BEANS);
        register(CHEEK_POUCH_UNLOCKED);
        register(APPLIED_PINK_PETAL);
        register(HAMSTER_AUTO_FED);
        register(HAMSTER_DIAMOND_ALERT_TRIGGERED);
        register(HAMSTER_CREEPER_ALERT_TRIGGERED);
        register(HAMSTER_POUCH_FILLED);
        register(HAMSTER_LED_TO_DIAMOND);
        register(HAMSTER_FOUND_GOLD);
        register(HAMSTER_BED_LINKED);
        register(HAMSTER_SLEPT_IN_BED);
        register(USED_HAMSTER_BEDDING);
        register(HAMSTER_BED_PLACED_UPSIDE_DOWN);
        register(DISPENSED_HAMSTER_BEDDING);

        AdorableHamsterPets.LOGGER.info("Registering Mod Criteria for " + AdorableHamsterPets.MOD_ID);
    }
}
```

`UsedHamsterBeddingCriterion.java`
```java
package net.dawson.adorablehamsterpets.advancement.criterion;

// (Imports omitted to save token count)

public class UsedHamsterBeddingCriterion extends AbstractCriterion<UsedHamsterBeddingCriterion.Conditions> {
    private final Identifier id;

    public UsedHamsterBeddingCriterion(Identifier id) {
        this.id = id;
    }

    @Override
    public Identifier getId() {
        return this.id;
    }

    @Override
    public Conditions conditionsFromJson(JsonObject obj, LootContextPredicate playerPredicate, AdvancementEntityPredicateDeserializer predicateDeserializer) {
        return new Conditions(this.id, playerPredicate);
    }

    public void trigger(ServerPlayerEntity player) {
        this.trigger(player, conditions -> true);
    }

    public static class Conditions extends AbstractCriterionConditions {
        public Conditions(Identifier id, LootContextPredicate playerPredicate) {
            super(id, playerPredicate);
        }
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/command/`
`ModCommands.java`
```java
package net.dawson.adorablehamsterpets.command;

// (Imports omitted to save token count)

public class ModCommands {

    public static void register(CommandDispatcher<ServerCommandSource> dispatcher, CommandRegistryAccess registryAccess, CommandManager.RegistrationEnvironment environment) {
        dispatcher.register(CommandManager.literal("ahamsterpets_unlock_advancements")
                .requires(source -> source.hasPermissionLevel(2))
                .executes(context -> executeUnlockAllModAdvancements(context.getSource()))
        );
    }

    private static int executeUnlockAllModAdvancements(ServerCommandSource source) throws CommandSyntaxException {
        ServerPlayerEntity player = source.getPlayerOrThrow();
        PlayerAdvancementTracker tracker = player.getAdvancementTracker();
        // The collection holds Advancement objects
        Collection<Advancement> allAdvancements = source.getServer().getAdvancementLoader().getAdvancements();
        int count = 0;

        for (Advancement advancement : allAdvancements) {
            Identifier id = advancement.getId();
            // Check for advancements in the mod's "husbandry" path
            if (id.getNamespace().equals(AdorableHamsterPets.MOD_ID) &&
                    (id.getPath().startsWith("husbandry/"))) {

                AdvancementProgress progress = tracker.getProgress(advancement);
                if (!progress.isDone()) {
                    // Grant all criteria for the advancement
                    for (String criterion : advancement.getCriteria().keySet()) {
                        tracker.grantCriterion(advancement, criterion);
                    }
                    count++;
                }
            }
        }

        final int finalCount = count;
        if (finalCount > 0) {
            source.sendFeedback(() -> Text.literal("Unlocked " + finalCount + " Adorable Hamster Pets advancements."), true);
        } else {
            source.sendFeedback(() -> Text.literal("No new Adorable Hamster Pets advancements to unlock or all already unlocked."), true);
        }
        return finalCount;
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/component/`
`HamsterShoulderData.java`
```java
package net.dawson.adorablehamsterpets.component;

// (Imports omitted to save token count)

public record HamsterShoulderData(
        UUID entityUuid,
        int variantId,
        float health,
        NbtCompound inventoryNbt,
        int breedingAge,
        long throwCooldownEndTick,
        GreenBeanBuffData greenBeanBuffData,
        int autoEatCooldownTicks,
        Optional<String> customName,
        int pinkPetalType,
        int animationPersonalityId,
        SeekingBehaviorData seekingBehaviorData,
        WanderModeData wanderModeData,
        int hamsterFlags
) {

    // --- Static Codecs Definitions ---
    public static final Codec<NbtCompound> NBT_COMPOUND_CODEC = Codec.PASSTHROUGH.comapFlatMap(
            (dynamic) -> {
                NbtElement element = dynamic.convert(NbtOps.INSTANCE).getValue();
                if (element instanceof NbtCompound compound) {
                    return DataResult.success(compound);
                }
                return DataResult.error(() -> "Not a compound NBT: " + element);
            },
            (nbt) -> new Dynamic<>(NbtOps.INSTANCE, nbt)
    );

    public static final Codec<NbtList> NBT_LIST_CODEC = Codec.PASSTHROUGH.comapFlatMap(
            (dynamic) -> {
                NbtElement element = dynamic.convert(NbtOps.INSTANCE).getValue();
                if (element instanceof NbtList list) {
                    return DataResult.success(list);
                }
                return DataResult.error(() -> "Not a list NBT: " + element);
            },
            (nbt) -> new Dynamic<>(NbtOps.INSTANCE, nbt)
    );

    // --- Inner Record for Seeking/Sulking Data ---
    public record SeekingBehaviorData(
            boolean isPrimedToSeekDiamonds,
            long foundOreCooldownEndTick,
            Optional<BlockPos> currentOreTarget
    ) {
        public static final Codec<SeekingBehaviorData> CODEC = RecordCodecBuilder.create(instance ->
                instance.group(
                        Codec.BOOL.fieldOf("isPrimedToSeekDiamonds").orElse(false).forGetter(SeekingBehaviorData::isPrimedToSeekDiamonds),
                        Codec.LONG.fieldOf("foundOreCooldownEndTick").orElse(0L).forGetter(SeekingBehaviorData::foundOreCooldownEndTick),
                        BlockPos.CODEC.optionalFieldOf("currentOreTarget").forGetter(SeekingBehaviorData::currentOreTarget)
                ).apply(instance, SeekingBehaviorData::new)
        );

        public static SeekingBehaviorData empty() {
            return new SeekingBehaviorData(false, 0L, Optional.empty());
        }
    }

    // --- Inner Record for Green Bean Buff Data ---
    public record GreenBeanBuffData(
            long greenBeanBuffEndTick,
            long greenBeanBuffDuration,
            NbtList activeEffectsNbt // NbtList for 1.20.1 compatibility
    ) {
        public static final Codec<GreenBeanBuffData> CODEC = RecordCodecBuilder.create(instance ->
                instance.group(
                        Codec.LONG.fieldOf("greenBeanBuffEndTick").orElse(0L).forGetter(GreenBeanBuffData::greenBeanBuffEndTick),
                        Codec.LONG.fieldOf("greenBeanBuffDuration").orElse(0L).forGetter(GreenBeanBuffData::greenBeanBuffDuration),
                        NBT_LIST_CODEC.fieldOf("activeEffectsNbt").forGetter(GreenBeanBuffData::activeEffectsNbt)
                ).apply(instance, GreenBeanBuffData::new)
        );

        public static GreenBeanBuffData empty() {
            return new GreenBeanBuffData(0L, 0L, new NbtList());
        }
    }

    // --- Inner Record for Wander Mode/Hamster Bed Data ---
    public record WanderModeData(
            Optional<GlobalPos> linkedBedPos,
            boolean bypassNextSleepDelay
    ) {
        public static final Codec<WanderModeData> CODEC = RecordCodecBuilder.create(instance ->
                instance.group(
                        GlobalPos.CODEC.optionalFieldOf("linkedBedPos").forGetter(WanderModeData::linkedBedPos),
                        Codec.BOOL.fieldOf("bypassNextSleepDelay").orElse(false).forGetter(WanderModeData::bypassNextSleepDelay)
                ).apply(instance, WanderModeData::new)
        );

        public static WanderModeData empty() {
            return new WanderModeData(Optional.empty(), false);
        }
    }

    // --- Lazy Initialized Main Codec ---
    private static Codec<HamsterShoulderData> CODEC;

    public static Codec<HamsterShoulderData> getCodec() {
        if (CODEC == null) {
            CODEC = RecordCodecBuilder.create(instance ->
                    instance.group(
                            Uuids.CODEC.fieldOf("entityUuid").forGetter(HamsterShoulderData::entityUuid),
                            Codec.INT.fieldOf("variantId").forGetter(HamsterShoulderData::variantId),
                            Codec.FLOAT.fieldOf("health").forGetter(HamsterShoulderData::health),
                            NBT_COMPOUND_CODEC.fieldOf("inventoryNbt").forGetter(HamsterShoulderData::inventoryNbt),
                            Codec.INT.fieldOf("breedingAge").forGetter(HamsterShoulderData::breedingAge),
                            Codec.LONG.fieldOf("throwCooldownEndTick").forGetter(HamsterShoulderData::throwCooldownEndTick),
                            GreenBeanBuffData.CODEC.fieldOf("greenBeanBuffData").orElse(GreenBeanBuffData.empty()).forGetter(HamsterShoulderData::greenBeanBuffData),
                            Codec.INT.fieldOf("autoEatCooldownTicks").forGetter(HamsterShoulderData::autoEatCooldownTicks),
                            Codec.STRING.optionalFieldOf("customName").forGetter(HamsterShoulderData::customName),
                            Codec.INT.fieldOf("pinkPetalType").orElse(0).forGetter(HamsterShoulderData::pinkPetalType),
                            Codec.INT.fieldOf("animationPersonalityId").orElse(1).forGetter(HamsterShoulderData::animationPersonalityId),
                            SeekingBehaviorData.CODEC.fieldOf("seekingBehaviorData").orElse(SeekingBehaviorData.empty()).forGetter(HamsterShoulderData::seekingBehaviorData),
                            WanderModeData.CODEC.fieldOf("wanderModeData").orElse(WanderModeData.empty()).forGetter(HamsterShoulderData::wanderModeData),
                            Codec.INT.fieldOf("hamsterFlags").orElse(0).forGetter(HamsterShoulderData::hamsterFlags)
                    ).apply(instance, HamsterShoulderData::new)
            );
        }
        return CODEC;
    }

    /**
     * Deserializes an NbtCompound into a HamsterShoulderData record.
     * @param nbt The NbtCompound to deserialize.
     * @return An Optional containing the HamsterShoulderData, or empty if deserialization fails.
     */
    public static Optional<HamsterShoulderData> fromNbt(NbtCompound nbt) {
        return getCodec().parse(NbtOps.INSTANCE, nbt).result();
    }

    /**
     * Serializes this record into an NbtCompound.
     * @return The NbtCompound representation of this data.
     */
    public NbtCompound toNbt() {
        // Use the 1.20.1 getOrThrow signature
        return (NbtCompound) getCodec().encodeStart(NbtOps.INSTANCE, this)
                .getOrThrow(false, error -> {
                    throw new IllegalStateException("Could not encode HamsterShoulderData: " + error);
                });
    }

    @Override
    public String toString() {
        return "HamsterShoulderData[uuid=" + entityUuid +
                ", variantId=" + variantId +
                ", health=" + health +
                ", inventoryNbt=" + inventoryNbt.toString().substring(0, Math.min(inventoryNbt.toString().length(), 50)) + "..." +
                ", age=" + breedingAge +
                ", throwCooldownEnd=" + throwCooldownEndTick +
                ", buffData=" + greenBeanBuffData +
                ", autoEatCooldown=" + autoEatCooldownTicks +
                ", customName=" + customName.orElse("None") +
                ", pinkPetalType=" + pinkPetalType +
                ", animationPersonalityId=" + animationPersonalityId +
                ", seekingBehaviorData=" + seekingBehaviorData +
                ", wanderModeData=" + wanderModeData +
                ", hamsterFlags=" + hamsterFlags +
                "]";
    }

    public static HamsterShoulderData empty() {
        return new HamsterShoulderData(UUID.randomUUID(), 0, 8.0f, new NbtCompound(), 0, 0L,
                GreenBeanBuffData.empty(), 0, Optional.empty(), 0, 1,
                SeekingBehaviorData.empty(), WanderModeData.empty(), 0
        );
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/event/`
`AHPCommonEvents.java`
```java
package net.dawson.adorablehamsterpets.event;

// (Imports omitted to save token count)

/**
 * Central handler for common, cross-loader events.
 */
public class AHPCommonEvents {

    /**
     * Initializes and registers all common event listeners.
     */
    public static void init() {
        PlayerEvent.OPEN_MENU.register(AHPCommonEvents::onOpenMenu);
        EntityEvent.LIVING_HURT.register(AHPCommonEvents::onLivingHurt);
    }

    /**
     * An event listener that fires whenever a player opens any menu (inventory, chest, etc.).
     * It scans all unique inventories within the menu and upgrades any outdated guide books.
     *
     * @param player The player opening the menu.
     * @param menu The menu being opened.
     */
    private static void onOpenMenu(PlayerEntity player, ScreenHandler menu) {
        if (player.getWorld().isClient()) {
            return;
        }

        // Use a Set to avoid scanning the same inventory multiple times
        Set<Inventory> inventories = new HashSet<>();
        for (Slot slot : menu.slots) {
            // Use the Mixin Accessor to get the inventory object.
            // This works on both Fabric (inventory) and Forge (container) thanks to the remapper.
            Inventory inv = ((SlotAccessor) slot).adorablehamsterpets$getInventory();
            if (inv != null) {
                inventories.add(inv);
            }
        }

        // Run the upgrade logic on each unique inventory found.
        for (Inventory inv : inventories) {
            AdorableHamsterPets.replaceOldBooksInInventory(inv);
        }
    }

    /**
     * An event listener that fires just before a living entity takes damage.
     * Prevents friendly fire between pets that share the same owner — including our
     * hamsters and vanilla pets (wolves, cats, parrots, horses, etc). Works cross-loader
     * from the common source set by relying on vanilla/Yarn types and simple reflection.
     *
     * @param victim The living entity about to be hurt.
     * @param source The source of the damage.
     * @param amount The amount of damage.
     * @return {@link EventResult#interruptFalse()} to cancel the damage, or
     *         {@link EventResult#pass()} to allow it.
     */
    private static EventResult onLivingHurt(LivingEntity victim, DamageSource source, float amount) {
        // --- 1. Server-side guard ---
        if (victim.getWorld().isClient()) {
            return EventResult.pass();
        }

        // --- 2. Gather the direct and indirect sources of the damage ---
        Entity direct   = source.getSource();     // Immediate cause (e.g., projectile / hamster body)
        Entity attacker = source.getAttacker();   // Credited attacker (e.g., the mob that dealt it)

        // --- 3. Debug logging to verify what entities are involved ---
        AdorableHamsterPets.LOGGER.trace("onLivingHurt: victim={} srcType={} attacker={}({}) direct={}({}) amount={}",
                victim.getType().toString(),
                source.getName(),
                attacker, attacker == null ? "null" : attacker.getClass().getSimpleName(),
                direct,   direct   == null ? "null" : direct.getClass().getSimpleName(),
                amount
        );

        // --- 4. If a tamed hamster is involved as attacker (direct or indirect) ---
        HamsterEntity hamster = null;
        if (direct instanceof HamsterEntity h && h.isTamed()) {
            hamster = h;
        } else if (attacker instanceof HamsterEntity h && h.isTamed()) {
            hamster = h;
        }

        // --- 5. Hamster → pet protection ---
        if (hamster != null) {
            boolean victimIsTameable = victim instanceof TameableEntity;
            AdorableHamsterPets.LOGGER.trace("hamster→pet branch entered: hamsterTamed={} victim instanceof TameableEntity={}",
                    hamster.isTamed(), victimIsTameable);

            // Owner of the hamster (always LivingEntity or null)
            LivingEntity hamsterOwner = hamster.getOwner();

            // Owner of the victim (generic, supports wolves/cats/parrots/horses/mods)
            LivingEntity victimOwner = getPetOwner(victim);

            AdorableHamsterPets.LOGGER.trace(
                    "hamster→pet owners: hamsterOwnerUuid={} victimOwnerUuid={}",
                    hamsterOwner == null ? "null" : hamsterOwner.getUuid(),
                    victimOwner  == null ? "null" : victimOwner.getUuid()
            );

            if (hamsterOwner != null && victimOwner != null) {
                if (sameOwner(hamsterOwner, victimOwner)) {
                    AdorableHamsterPets.LOGGER.trace("hamster→pet: SAME OWNER detected, cancelling damage.");
                    return EventResult.interruptFalse();
                }
            }
        }

        // --- 6. Symmetric protection: pet (any) → hamster ---
        if (victim instanceof HamsterEntity victimHamster && victimHamster.isTamed()) {
            LivingEntity victimOwner   = victimHamster.getOwner();
            LivingEntity attackerOwner = (attacker instanceof LivingEntity leAttacker) ? getPetOwner(leAttacker) : null;

            AdorableHamsterPets.LOGGER.trace(
                    "onLivingHurt: symm hamsterOwnerUuid={} attackerOwnerUuid={}",
                    victimOwner   == null ? "null" : victimOwner.getUuid(),
                    attackerOwner == null ? "null" : attackerOwner.getUuid()
            );

            if (victimOwner != null && attackerOwner != null) {
                if (sameOwner(victimOwner, attackerOwner)) {
                    return EventResult.interruptFalse();
                }
            }
        }

        // --- 7. For all other cases, allow normal damage processing ---
        return EventResult.pass();
    }

    @Nullable
    private static LivingEntity getPetOwner(LivingEntity entity) {
        // --- A. Direct vanilla APIs ---
        // TameableEntity (wolves, cats, parrots, etc.)
        if (entity instanceof TameableEntity tame) {
            return tame.getOwner();
        }

        // AbstractHorseEntity stores only the owner's UUID; resolve it into an entity.
        if (entity instanceof AbstractHorseEntity horse) {
            UUID ownerId = horse.getOwnerUuid();
            if (ownerId != null) {
                return lookupLivingByUuid(entity.getWorld(), ownerId);
            }
        }

        // Some entities (esp. projectiles/custom) may implement the "Ownable" marker that returns an Entity.
        // Only accept it if it is actually a LivingEntity.
        // NOTE: Wolves do NOT implement this interface; this branch is just a safe bonus path.
        if (entity instanceof net.minecraft.entity.Ownable ownable) {
            Entity e = ownable.getOwner();
            return (e instanceof LivingEntity le) ? le : null;   // <-- fixes the “Entity → LivingEntity” type mismatch
        }

        // --- B. Reflection fallback for common mod patterns ---
        // Try a no-arg getOwner() that returns LivingEntity or Entity.
        try {
            Method m = entity.getClass().getMethod("getOwner");
            Object ret = m.invoke(entity);
            if (ret instanceof LivingEntity le) return le;
            if (ret instanceof Entity e) return (e instanceof LivingEntity le) ? le : null;
        } catch (Throwable ignored) {
        }

        // Try getOwnerUuid() / getOwnerUUID() and resolve.
        UUID id = tryGetUuid(entity, "getOwnerUuid");
        if (id == null) id = tryGetUuid(entity, "getOwnerUUID");
        if (id != null) {
            return lookupLivingByUuid(entity.getWorld(), id);
        }

        return null;
    }

    // Resolve a UUID-returning method by name, if present.
    @Nullable
    private static UUID tryGetUuid(Object target, String methodName) {
        try {
            Method m = target.getClass().getMethod(methodName);
            Object ret = m.invoke(target);
            return (ret instanceof UUID u) ? u : null;
        } catch (Throwable ignored) {
            return null;
        }
    }

    // Lookup a LivingEntity by UUID in the current world (players first, then any entity).
    @Nullable
    private static LivingEntity lookupLivingByUuid(World world, UUID id) {
        if (!(world instanceof ServerWorld server)) return null;
        // Players
        Entity player = server.getPlayerByUuid(id);
        if (player instanceof LivingEntity le) return le;
        // Any other entity with that UUID
        Entity any = server.getEntity(id);
        return (any instanceof LivingEntity le) ? le : null;
    }

    // Strict "same owner" check by identity OR UUID match to be resilient to different instances.
    private static boolean sameOwner(LivingEntity a, LivingEntity b) {
        return a == b || a.getUuid().equals(b.getUuid());
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/networking/`
`ModPackets.java`
```java
package net.dawson.adorablehamsterpets.networking;

// (Imports omitted to save token count)

/**
 * Manages network packet registration and handling for the 1.20.1 version of the mod.
 * Utilizes Architectury API's {@link NetworkChannel} to handle cross-platform networking.
 * <p>
 * Note: In Architectury 9 (1.20.1), packets must be registered on both logical sides
 * to ensure the NetworkChannel knows how to encode/decode them. Client-side handlers
 * are wrapped in {@link EnvExecutor} to prevent classloading crashes on the server.
 */
public class ModPackets {

    // --- 1. Create Network Channel ---
    public static final NetworkChannel CHANNEL = NetworkChannel.create(new Identifier(MOD_ID, "main"));

    // --- 2. Define Packet Data as Records ---
    // C2S (Client-to-Server)
    public record ThrowHamsterC2SPacket() {}
    public record DismountHamsterC2SPacket() {}
    public record UpdateRenderStateC2SPacket(int entityId, boolean isRendering) {}
    public record RequestGuidebookC2SPacket() {}
    public record RequestHamsterMountC2SPacket(int entityId) {}

    // S2C (Server-to-Client)
    public record PlayGuidebookEffectsS2CPacket() {}
    public record SpawnBeddingParticlesS2CPacket(BlockPos pos, Direction direction, WoodVariant variant) {}
    public record SyncShoulderDataS2CPacket(int entityId, NbtCompound data) {}
    public record PlayDistantSoundS2CPacket(Identifier soundId, float volume, float pitch) {}

    /**
     * Registers all packet definitions and their handlers.
     * This method must be called during common setup on both client and server.
     */
    public static void registerCommonPackets() {

        // --- Client to Server (C2S) ---
        CHANNEL.register(ThrowHamsterC2SPacket.class,
                (packet, buf) -> {},
                (buf) -> new ThrowHamsterC2SPacket(),
                (packet, context) -> context.get().queue(() -> HamsterEntity.tryThrowFromShoulder((ServerPlayerEntity) context.get().getPlayer()))
        );

        CHANNEL.register(DismountHamsterC2SPacket.class,
                (packet, buf) -> {},
                (buf) -> new DismountHamsterC2SPacket(),
                (packet, context) -> context.get().queue(() -> {
                    if (context.get().getPlayer() instanceof ServerPlayerEntity player) {
                        ((PlayerEntityAccessor) player).adorablehamsterpets$dismountShoulderHamster(false);
                    }
                })
        );

        CHANNEL.register(UpdateRenderStateC2SPacket.class,
                (packet, buf) -> {
                    buf.writeInt(packet.entityId());
                    buf.writeBoolean(packet.isRendering());
                },
                (buf) -> new UpdateRenderStateC2SPacket(buf.readInt(), buf.readBoolean()),
                (packet, context) -> context.get().queue(() -> {
                    if (packet.isRendering()) {
                        HamsterRenderTracker.addPlayer(packet.entityId(), context.get().getPlayer().getUuid());
                    } else {
                        HamsterRenderTracker.removePlayer(packet.entityId(), context.get().getPlayer().getUuid());
                    }
                })
        );

        CHANNEL.register(RequestGuidebookC2SPacket.class,
                (packet, buf) -> {},
                (buf) -> new RequestGuidebookC2SPacket(),
                (packet, context) -> context.get().queue(() -> {
                    ServerPlayerEntity player = (ServerPlayerEntity) context.get().getPlayer();
                    ItemStack bookStack = new ItemStack(ModItems.HAMSTER_GUIDE_BOOK.get());

                    // In 1.20.1, add the Patchouli ID to NBT
                    NbtCompound nbt = bookStack.getOrCreateNbt();
                    nbt.putString("patchouli:book", "adorablehamsterpets:hamster_tips_guide_book");

                    player.getInventory().offerOrDrop(bookStack);

                    // Send effects packet back to the player
                    CHANNEL.sendToPlayer(player, new PlayGuidebookEffectsS2CPacket());
                })
        );

        CHANNEL.register(RequestHamsterMountC2SPacket.class,
                (packet, buf) -> buf.writeInt(packet.entityId()),
                (buf) -> new RequestHamsterMountC2SPacket(buf.readInt()),
                (packet, context) -> context.get().queue(() -> {
                    net.minecraft.entity.player.PlayerEntity player = context.get().getPlayer();
                    net.minecraft.entity.Entity entity = player.getWorld().getEntityById(packet.entityId());
                    if (entity instanceof HamsterEntity hamster && hamster.isOwner(player)) {
                        // Distance check for security
                        if (hamster.squaredDistanceTo(player) < 64.0) {
                            // Use the 1.20.1 version of tryShoulderMount (check signature)
                            hamster.tryShoulderMount(player, net.minecraft.item.ItemStack.EMPTY);
                        }
                    }
                })
        );

        // --- Server to Client (S2C) ---
        CHANNEL.register(SpawnBeddingParticlesS2CPacket.class,
                (packet, buf) -> {
                    buf.writeBlockPos(packet.pos());
                    buf.writeEnumConstant(packet.direction());
                    buf.writeEnumConstant(packet.variant());
                },
                (buf) -> new SpawnBeddingParticlesS2CPacket(
                        buf.readBlockPos(),
                        buf.readEnumConstant(Direction.class),
                        buf.readEnumConstant(WoodVariant.class)
                ),
                (packet, context) -> context.get().queue(() ->
                        EnvExecutor.runInEnv(Env.CLIENT, () -> () -> AdorableHamsterPetsClient.handleSpawnBeddingParticles(packet))
                )
        );

        CHANNEL.register(PlayGuidebookEffectsS2CPacket.class,
                (packet, buf) -> {},
                (buf) -> new PlayGuidebookEffectsS2CPacket(),
                (packet, context) -> context.get().queue(() ->
                        EnvExecutor.runInEnv(Env.CLIENT, () -> () -> AdorableHamsterPetsClient.handlePlayGuidebookEffects())
                )
        );

        CHANNEL.register(SyncShoulderDataS2CPacket.class,
                (packet, buf) -> {
                    buf.writeInt(packet.entityId());
                    buf.writeNbt(packet.data());
                },
                (buf) -> new SyncShoulderDataS2CPacket(buf.readInt(), buf.readNbt()),
                (packet, context) -> context.get().queue(() ->
                        EnvExecutor.runInEnv(Env.CLIENT, () -> () -> AdorableHamsterPetsClient.handleSyncShoulderData(packet.entityId(), packet.data()))
                )
        );

        CHANNEL.register(PlayDistantSoundS2CPacket.class,
                (packet, buf) -> {
                    buf.writeIdentifier(packet.soundId());
                    buf.writeFloat(packet.volume());
                    buf.writeFloat(packet.pitch());
                },
                (buf) -> new PlayDistantSoundS2CPacket(
                        buf.readIdentifier(),
                        buf.readFloat(),
                        buf.readFloat()
                ),
                (packet, context) -> context.get().queue(() ->
                        EnvExecutor.runInEnv(Env.CLIENT, () -> () -> AdorableHamsterPetsClient.handlePlayDistantSound(packet))
                )
        );
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/tag/`
`ModBiomeTags.java`
```java
package net.dawson.adorablehamsterpets.tag;

// (Imports omitted to save token count)

/**
 * Centralizes all custom "union" biome tags for the mod.
 * Each tag aggregates vanilla, 'c', and 'forge' tags for maximum cross-loader compatibility.
 */
public class ModBiomeTags {

    public static final TagKey<Biome> IS_ICY = of("is_icy");
    public static final TagKey<Biome> IS_MUSHROOM = of("is_mushroom");
    public static final TagKey<Biome> IS_MAGICAL = of("is_magical");
    public static final TagKey<Biome> IS_COLD = of("is_cold");
    public static final TagKey<Biome> IS_SNOWY = of("is_snowy");
    public static final TagKey<Biome> IS_MOUNTAIN = of("is_mountain");
    public static final TagKey<Biome> IS_SPARSE_VEGETATION = of("is_sparse_vegetation");
    public static final TagKey<Biome> IS_WET = of("is_wet");
    public static final TagKey<Biome> IS_CAVE = of("is_cave");
    public static final TagKey<Biome> IS_SANDY = of("is_sandy");
    public static final TagKey<Biome> IS_FOREST = of("is_forest");
    public static final TagKey<Biome> IS_DENSE_VEGETATION = of("is_dense_vegetation");

    private static TagKey<Biome> of(String path) {
        return TagKey.of(RegistryKeys.BIOME, Identifier.of(AdorableHamsterPets.MOD_ID, path));
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/world/`
`ModSpawnPlacements.java`
```java
package net.dawson.adorablehamsterpets.world;

// (Imports omitted to save token count)

/**
 * Common class for registering entity spawn restrictions using an @ExpectPlatform bridge.
 * The actual implementation is provided by each loader.
 */
public final class ModSpawnPlacements {
    @ExpectPlatform
    public static <T extends MobEntity> void register(EntityType<T> entityType, SpawnRestriction.Location location, Heightmap.Type heightmapType, SpawnRestriction.SpawnPredicate<T> predicate) {
        // This is a placeholder that will be replaced by the platform-specific implementation at runtime.
        throw new AssertionError();
    }
}
```

`ModWorldGeneration.java`
```java
package net.dawson.adorablehamsterpets.world;

// (Imports omitted to save token count)

public class ModWorldGeneration {

    // --- Caches for Parsed Config Values ---
    private static final Set<Identifier> SUNFLOWER_IDS = new HashSet<>();
    private static final Set<TagKey<Biome>> SUNFLOWER_TAGS = new HashSet<>();
    private static final Set<Identifier> GREEN_BEAN_BUSH_IDS = new HashSet<>();
    private static final Set<TagKey<Biome>> GREEN_BEAN_BUSH_TAGS = new HashSet<>();
    private static final Set<TagKey<Biome>> GREEN_BEAN_BUSH_CONVENTION_TAGS = new HashSet<>();
    private static final Set<Identifier> GREEN_BEAN_BUSH_EXCLUSIONS = new HashSet<>();
    private static final Set<Identifier> CUCUMBER_BUSH_IDS = new HashSet<>();
    private static final Set<TagKey<Biome>> CUCUMBER_BUSH_TAGS = new HashSet<>();
    private static final Set<TagKey<Biome>> CUCUMBER_BUSH_CONVENTION_TAGS = new HashSet<>();
    private static final Set<Identifier> CUCUMBER_BUSH_EXCLUSIONS = new HashSet<>();

    public static void generateModWorldGen() {
        AdorableHamsterPets.LOGGER.info("Registering Biome Modifications for " + AdorableHamsterPets.MOD_ID);
        registerBiomeModifications();
    }

    @ExpectPlatform
    public static void registerBiomeModifications() {
        throw new AssertionError();
    }

    /**
     * Parses the feature generation lists from the config file into Sets for efficient lookup.
     * This should be called once during mod initialization.
     */
    public static void parseConfig() {
        // --- Clear all sets to allow for config reloading ---
        SUNFLOWER_IDS.clear();
        SUNFLOWER_TAGS.clear();
        GREEN_BEAN_BUSH_IDS.clear();
        GREEN_BEAN_BUSH_TAGS.clear();
        GREEN_BEAN_BUSH_CONVENTION_TAGS.clear();
        GREEN_BEAN_BUSH_EXCLUSIONS.clear();
        CUCUMBER_BUSH_IDS.clear();
        CUCUMBER_BUSH_TAGS.clear();
        CUCUMBER_BUSH_CONVENTION_TAGS.clear();
        CUCUMBER_BUSH_EXCLUSIONS.clear();

        // --- Parse Sunflowers ---
        Configs.AHP_WORLDGEN.sunflowerBiomes.forEach(idStr -> parseIdentifier(idStr, SUNFLOWER_IDS, "sunflowerBiomes"));
        Configs.AHP_WORLDGEN.sunflowerBiomeTags.forEach(tagStr -> parseTag(tagStr, SUNFLOWER_TAGS, "sunflowerBiomeTags"));

        // --- Parse Green Bean Bushes ---
        Configs.AHP_WORLDGEN.greenBeanBushBiomes.forEach(idStr -> parseIdentifier(idStr, GREEN_BEAN_BUSH_IDS, "greenBeanBushBiomes"));
        Configs.AHP_WORLDGEN.greenBeanBushTags.forEach(tagStr -> parseTag(tagStr, GREEN_BEAN_BUSH_TAGS, "greenBeanBushTags"));
        Configs.AHP_WORLDGEN.greenBeanBushConventionTags.forEach(tagStr -> parseTag(tagStr, GREEN_BEAN_BUSH_CONVENTION_TAGS, "greenBeanBushConventionTags"));
        Configs.AHP_WORLDGEN.greenBeanBushExclusions.forEach(idStr -> parseIdentifier(idStr, GREEN_BEAN_BUSH_EXCLUSIONS, "greenBeanBushExclusions"));

        // --- Parse Cucumber Bushes ---
        Configs.AHP_WORLDGEN.cucumberBushBiomes.forEach(idStr -> parseIdentifier(idStr, CUCUMBER_BUSH_IDS, "cucumberBushBiomes"));
        Configs.AHP_WORLDGEN.cucumberBushTags.forEach(tagStr -> parseTag(tagStr, CUCUMBER_BUSH_TAGS, "cucumberBushTags"));
        Configs.AHP_WORLDGEN.cucumberBushConventionTags.forEach(tagStr -> parseTag(tagStr, CUCUMBER_BUSH_CONVENTION_TAGS, "cucumberBushConventionTags"));
        Configs.AHP_WORLDGEN.cucumberBushExclusions.forEach(idStr -> parseIdentifier(idStr, CUCUMBER_BUSH_EXCLUSIONS, "cucumberBushExclusions"));

        AdorableHamsterPets.LOGGER.info("[FeatureConfig] Parsed feature generation settings from config.");
    }

    /**
     * The Forge-specific decider method for feature placement, driven by the parsed config.
     * For sunflowers, it also verifies that the biome already contains the vanilla sunflower feature. Fabric does this same filtering, but in the Fabric/`ModWorldGenerationImpl` class instead.
     *
     * @param feature The PlacedFeature being considered for generation.
     * @param biome   The Biome where the feature might be placed.
     * @return True if the feature should spawn in this biome according to config rules.
     */
    public static boolean shouldFeatureSpawnInBiome(RegistryEntry<PlacedFeature> feature, RegistryEntry<Biome> biome) {
        Identifier featureId = feature.getKey().map(RegistryKey::getValue).orElse(null);
        Identifier biomeId = biome.getKey().map(RegistryKey::getValue).orElse(null);

        if (featureId == null || biomeId == null) {
            return false;
        }

        String featurePath = featureId.getPath();

        boolean isCandidate = switch (featurePath) {
            case "custom_sunflower_placed", "patch_sunflower" -> {
                boolean isAllowedByConfig = SUNFLOWER_IDS.contains(biomeId) || SUNFLOWER_TAGS.stream().anyMatch(biome::isIn);
                if (!isAllowedByConfig) yield false;

                List<RegistryEntryList<PlacedFeature>> allFeaturesByStep = biome.value().getGenerationSettings().getFeatures();
                int vegetalStep = GenerationStep.Feature.VEGETAL_DECORATION.ordinal();

                if (vegetalStep >= allFeaturesByStep.size()) yield false;

                RegistryEntryList<PlacedFeature> vegetalFeatures = allFeaturesByStep.get(vegetalStep);
                // Iterate through the entries and check their keys.
                for (RegistryEntry<PlacedFeature> entry : vegetalFeatures) {
                    if (entry.matchesKey(VegetationPlacedFeatures.PATCH_SUNFLOWER)) {
                        yield true;
                    }
                }
                yield false;
            }
            case "wild_green_bean_bush_placed" -> GREEN_BEAN_BUSH_IDS.contains(biomeId) ||
                    GREEN_BEAN_BUSH_TAGS.stream().anyMatch(biome::isIn) ||
                    GREEN_BEAN_BUSH_CONVENTION_TAGS.stream().anyMatch(biome::isIn);
            case "wild_cucumber_bush_placed" -> CUCUMBER_BUSH_IDS.contains(biomeId) ||
                    CUCUMBER_BUSH_TAGS.stream().anyMatch(biome::isIn) ||
                    CUCUMBER_BUSH_CONVENTION_TAGS.stream().anyMatch(biome::isIn);
            default -> false;
        };

        if (!isCandidate) {
            return false;
        }

        // Apply exclusions as the final veto
        return switch (featurePath) {
            case "wild_green_bean_bush_placed" -> !GREEN_BEAN_BUSH_EXCLUSIONS.contains(biomeId);
            case "wild_cucumber_bush_placed" -> !CUCUMBER_BUSH_EXCLUSIONS.contains(biomeId);
            default -> true; // Sunflowers and vanilla features have no exclusion list in this system.
        };
    }

    /**
     * The Fabric-specific decider method for feature placement, driven by the parsed config.
     * This version uses Architectury's BiomeContext for compatibility.
     *
     * @param featureKey The RegistryKey of the PlacedFeature being considered.
     * @param context    The BiomeContext for the biome where the feature might be placed.
     * @return True if the feature should spawn in this biome according to config rules.
     */
    public static boolean shouldFeatureSpawnInBiome(RegistryKey<PlacedFeature> featureKey, BiomeModifications.BiomeContext context) {
        Identifier biomeId = context.getKey().orElse(null);
        if (biomeId == null) {
            return false;
        }

        String featurePath = featureKey.getValue().getPath();

        boolean isCandidate = switch (featurePath) {
            case "custom_sunflower_placed", "patch_sunflower" -> SUNFLOWER_IDS.contains(biomeId) ||
                    SUNFLOWER_TAGS.stream().anyMatch(context::hasTag);
            case "wild_green_bean_bush_placed" -> GREEN_BEAN_BUSH_IDS.contains(biomeId) ||
                    GREEN_BEAN_BUSH_TAGS.stream().anyMatch(context::hasTag) ||
                    GREEN_BEAN_BUSH_CONVENTION_TAGS.stream().anyMatch(context::hasTag);
            case "wild_cucumber_bush_placed" -> CUCUMBER_BUSH_IDS.contains(biomeId) ||
                    CUCUMBER_BUSH_TAGS.stream().anyMatch(context::hasTag) ||
                    CUCUMBER_BUSH_CONVENTION_TAGS.stream().anyMatch(context::hasTag);
            default -> false;
        };

        if (!isCandidate) {
            return false;
        }

        // Apply exclusions as the final veto
        return switch (featurePath) {
            case "wild_green_bean_bush_placed" -> !GREEN_BEAN_BUSH_EXCLUSIONS.contains(biomeId);
            case "wild_cucumber_bush_placed" -> !CUCUMBER_BUSH_EXCLUSIONS.contains(biomeId);
            default -> true;
        };
    }

    // --- Private Helper Methods for Parsing ---
    private static void parseIdentifier(String idStr, Set<Identifier> set, String configListName) {
        try {
            set.add(new Identifier(idStr));
        } catch (Exception e) {
            AdorableHamsterPets.LOGGER.info("[FeatureConfig] Invalid identifier in '{}' config list: '{}'", configListName, idStr);
        }
    }

    private static void parseTag(String tagStr, Set<TagKey<Biome>> set, String configListName) {
        try {
            set.add(TagKey.of(RegistryKeys.BIOME, new Identifier(tagStr)));
        } catch (Exception e) {
            AdorableHamsterPets.LOGGER.info("[FeatureConfig] Invalid biome tag identifier in '{}' config list: '{}'", configListName, tagStr);
        }
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/world/gen/`
`ModEntitySpawns.java`
```java
package net.dawson.adorablehamsterpets.world.gen;

// (Imports omitted to save token count)

/**
 * Handles the registration of entity spawns within specific biomes using the Architectury API.
 */
public class ModEntitySpawns {

    public static final Set<Block> VALID_SPAWN_BLOCKS = new HashSet<>();

    // --- Caches for Parsed Config Values ---
    private static final Set<TagKey<Biome>> PARSED_TAGS = new HashSet<>();
    private static final Set<Identifier> PARSED_INCLUDES = new HashSet<>();
    private static final Set<Identifier> PARSED_EXCLUDES = new HashSet<>();

    static {
        VALID_SPAWN_BLOCKS.add(Blocks.SAND);
        VALID_SPAWN_BLOCKS.add(Blocks.RED_SAND);
        VALID_SPAWN_BLOCKS.add(Blocks.TERRACOTTA);
        VALID_SPAWN_BLOCKS.add(Blocks.WHITE_TERRACOTTA);
        VALID_SPAWN_BLOCKS.add(Blocks.ORANGE_TERRACOTTA);
        VALID_SPAWN_BLOCKS.add(Blocks.MAGENTA_TERRACOTTA);
        VALID_SPAWN_BLOCKS.add(Blocks.LIGHT_BLUE_TERRACOTTA);
        VALID_SPAWN_BLOCKS.add(Blocks.YELLOW_TERRACOTTA);
        VALID_SPAWN_BLOCKS.add(Blocks.LIME_TERRACOTTA);
        VALID_SPAWN_BLOCKS.add(Blocks.PINK_TERRACOTTA);
        VALID_SPAWN_BLOCKS.add(Blocks.GRAY_TERRACOTTA);
        VALID_SPAWN_BLOCKS.add(Blocks.LIGHT_GRAY_TERRACOTTA);
        VALID_SPAWN_BLOCKS.add(Blocks.CYAN_TERRACOTTA);
        VALID_SPAWN_BLOCKS.add(Blocks.PURPLE_TERRACOTTA);
        VALID_SPAWN_BLOCKS.add(Blocks.BLUE_TERRACOTTA);
        VALID_SPAWN_BLOCKS.add(Blocks.BROWN_TERRACOTTA);
        VALID_SPAWN_BLOCKS.add(Blocks.GREEN_TERRACOTTA);
        VALID_SPAWN_BLOCKS.add(Blocks.RED_TERRACOTTA);
        VALID_SPAWN_BLOCKS.add(Blocks.BLACK_TERRACOTTA);
        VALID_SPAWN_BLOCKS.add(Blocks.STONE);
        VALID_SPAWN_BLOCKS.add(Blocks.DEEPSLATE);
        VALID_SPAWN_BLOCKS.add(Blocks.ANDESITE);
        VALID_SPAWN_BLOCKS.add(Blocks.DIORITE);
        VALID_SPAWN_BLOCKS.add(Blocks.GRANITE);
        VALID_SPAWN_BLOCKS.add(Blocks.GRAVEL);
        VALID_SPAWN_BLOCKS.add(Blocks.DIRT);
        VALID_SPAWN_BLOCKS.add(Blocks.MUD);
        VALID_SPAWN_BLOCKS.add(Blocks.PACKED_MUD);
        VALID_SPAWN_BLOCKS.add(Blocks.GRASS_BLOCK);
        VALID_SPAWN_BLOCKS.add(Blocks.MOSS_BLOCK);
        VALID_SPAWN_BLOCKS.add(Blocks.COARSE_DIRT);
        VALID_SPAWN_BLOCKS.add(Blocks.PODZOL);
        VALID_SPAWN_BLOCKS.add(Blocks.SNOW_BLOCK);
        VALID_SPAWN_BLOCKS.add(Blocks.MYCELIUM);
        VALID_SPAWN_BLOCKS.add(Blocks.SCULK);
    }

    /**
     * Parses the biome lists from the config file into Sets for efficient lookup.
     * This should be called once during mod initialization.
     */
    public static void parseConfig() {
        // Clear existing sets to allow for config reloading
        PARSED_TAGS.clear();
        PARSED_INCLUDES.clear();
        PARSED_EXCLUDES.clear();

        // Parse Tags
        for (String tagStr : Configs.AHP_WORLDGEN.spawnBiomeTags) {
            try {
                PARSED_TAGS.add(TagKey.of(RegistryKeys.BIOME, new Identifier(tagStr)));
            } catch (Exception e) {
                AdorableHamsterPets.LOGGER.info("[BiomeConfig] Invalid biome tag identifier in config: '{}'", tagStr);
            }
        }

        // Parse Includes
        for (String biomeIdStr : Configs.AHP_WORLDGEN.includeBiomes) {
            try {
                PARSED_INCLUDES.add(new Identifier(biomeIdStr));
            } catch (Exception e) {
                AdorableHamsterPets.LOGGER.warn("[BiomeConfig] Invalid biome identifier in include list: '{}'", biomeIdStr);
            }
        }

        // Parse Excludes
        for (String biomeIdStr : Configs.AHP_WORLDGEN.excludeBiomes) {
            try {
                PARSED_EXCLUDES.add(new Identifier(biomeIdStr));
            } catch (Exception e) {
                AdorableHamsterPets.LOGGER.warn("[BiomeConfig] Invalid biome identifier in exclude list: '{}'", biomeIdStr);
            }
        }

        AdorableHamsterPets.LOGGER.info("[BiomeConfig] Parsed {} tags, {} included biomes, and {} excluded biomes.",
                PARSED_TAGS.size(), PARSED_INCLUDES.size(), PARSED_EXCLUDES.size());
    }

    /**
     * The universal decider for Fabric, driven by the parsed config.
     *
     * @param ctx The biome context provided by Architectury.
     * @return True if hamsters should spawn in this biome, false otherwise.
     */
    public static boolean shouldSpawnInBiome(BiomeModifications.BiomeContext ctx) {
        // Get the Identifier directly from the Optional.
        Identifier biomeId = ctx.getKey().orElse(null);
        if (biomeId == null) return false;

        // 1. Exclusion check (highest priority)
        if (PARSED_EXCLUDES.contains(biomeId)) {
            return false;
        }
        // 2. Inclusion check (specific biomes)
        if (PARSED_INCLUDES.contains(biomeId)) {
            return true;
        }
        // 3. Tag check
        for (TagKey<Biome> tag : PARSED_TAGS) {
            if (ctx.hasTag(tag)) {
                return true;
            }
        }
        // 4. Default to false if no rules match
        return false;
    }

    /**
     * A Forge-specific decider that works directly with a RegistryEntry.
     *
     * @param biomeEntry The biome entry from the Forge modifier.
     * @return True if hamsters should spawn, false otherwise.
     */
    public static boolean shouldSpawnInBiomeForge(RegistryEntry<Biome> biomeEntry) {
        Identifier biomeId = biomeEntry.getKey().map(RegistryKey::getValue).orElse(null);
        if (biomeId == null) return false;

        // 1. Exclusion check
        if (PARSED_EXCLUDES.contains(biomeId)) {
            return false;
        }
        // 2. Inclusion check
        if (PARSED_INCLUDES.contains(biomeId)) {
            return true;
        }
        // 3. Tag check
        for (TagKey<Biome> tag : PARSED_TAGS) {
            if (biomeEntry.isIn(tag)) {
                return true;
            }
        }
        // 4. Default to false
        return false;
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/world/gen/feature/`
`ModConfiguredFeatures.java`
```java
package net.dawson.adorablehamsterpets.world.gen.feature;

// (Imports omitted to save token count)

public class ModConfiguredFeatures {

    public static final RegistryKey<ConfiguredFeature<?, ?>> CUSTOM_SUNFLOWER_PATCH_KEY = registerKey("custom_sunflower_patch");

    // --- Add Keys for Bushes ---
    public static final RegistryKey<ConfiguredFeature<?, ?>> WILD_GREEN_BEAN_BUSH_KEY = registerKey("wild_green_bean_bush_patch");
    public static final RegistryKey<ConfiguredFeature<?, ?>> WILD_CUCUMBER_BUSH_KEY = registerKey("wild_cucumber_bush_patch");
    // --- End Add Keys ---

    public static void bootstrap(Registerable<ConfiguredFeature<?, ?>> context) {
        // Sunflower (Existing)
        register(context, CUSTOM_SUNFLOWER_PATCH_KEY, Feature.RANDOM_PATCH,
                ConfiguredFeatures.createRandomPatchFeatureConfig(
                        64, // Tries per patch for sunflower
                        PlacedFeatures.createEntry(Feature.SIMPLE_BLOCK,
                                new SimpleBlockFeatureConfig(BlockStateProvider.of(ModBlocks.SUNFLOWER_BLOCK.get()))
                        )
                ));

        // --- Register Green Bean Bush Patch ---
        register(context, WILD_GREEN_BEAN_BUSH_KEY, Feature.RANDOM_PATCH,
                ConfiguredFeatures.createRandomPatchFeatureConfig(
                        18, // Fewer tries per patch than sunflowers, adjust as needed
                        PlacedFeatures.createEntry(Feature.SIMPLE_BLOCK,
                                // Ensure the bush starts seeded when generated naturally
                                new SimpleBlockFeatureConfig(BlockStateProvider.of(ModBlocks.WILD_GREEN_BEAN_BUSH.get().getDefaultState().with(net.dawson.adorablehamsterpets.block.custom.WildGreenBeanBushBlock.SEEDED, true)))
                        )
                ));
        // --- End Register Green Bean ---

        // --- Register Cucumber Bush Patch ---
        register(context, WILD_CUCUMBER_BUSH_KEY, Feature.RANDOM_PATCH,
                ConfiguredFeatures.createRandomPatchFeatureConfig(
                        18, // Fewer tries per patch, adjust as needed
                        PlacedFeatures.createEntry(Feature.SIMPLE_BLOCK,
                                // Ensure the bush starts seeded when generated naturally
                                new SimpleBlockFeatureConfig(BlockStateProvider.of(ModBlocks.WILD_CUCUMBER_BUSH.get().getDefaultState().with(net.dawson.adorablehamsterpets.block.custom.WildCucumberBushBlock.SEEDED, true)))
                        )
                ));
        // --- End Register Cucumber ---
    }

    // Helper methods (Existing)
    public static RegistryKey<ConfiguredFeature<?, ?>> registerKey(String name) {
        return RegistryKey.of(RegistryKeys.CONFIGURED_FEATURE, Identifier.of(AdorableHamsterPets.MOD_ID, name));
    }

    private static <FC extends FeatureConfig, F extends Feature<FC>> void register(Registerable<ConfiguredFeature<?, ?>> context,
                                                                                   RegistryKey<ConfiguredFeature<?, ?>> key, F feature, FC configuration) {
        context.register(key, new ConfiguredFeature<>(feature, configuration));
    }
}
```

`ModPlacedFeatures.java`
```java
package net.dawson.adorablehamsterpets.world.gen.feature;

// (Imports omitted to save token count)

public class ModPlacedFeatures {

    public static final RegistryKey<PlacedFeature> CUSTOM_SUNFLOWER_PLACED_KEY = registerKey("custom_sunflower_placed");

    // --- Add Keys for Placed Bushes ---
    public static final RegistryKey<PlacedFeature> WILD_GREEN_BEAN_BUSH_PLACED_KEY = registerKey("wild_green_bean_bush_placed");
    public static final RegistryKey<PlacedFeature> WILD_CUCUMBER_BUSH_PLACED_KEY = registerKey("wild_cucumber_bush_placed");
    // --- End Add Keys ---

    public static void bootstrap(Registerable<PlacedFeature> context) {
        var configuredFeatureRegistryEntryLookup = context.getRegistryLookup(RegistryKeys.CONFIGURED_FEATURE);
        final AhpWorldGenConfig config = AdorableHamsterPets.WORLD_GEN_CONFIG; // Access static config

        // Sunflower
        register(context, CUSTOM_SUNFLOWER_PLACED_KEY,
                configuredFeatureRegistryEntryLookup.getOrThrow(ModConfiguredFeatures.CUSTOM_SUNFLOWER_PATCH_KEY),
                RarityFilterPlacementModifier.of(3),
                SquarePlacementModifier.of(),
                PlacedFeatures.MOTION_BLOCKING_HEIGHTMAP,
                BiomePlacementModifier.of()
        );

        // --- Register Placed Green Bean Bush ---
        register(context, WILD_GREEN_BEAN_BUSH_PLACED_KEY,
                configuredFeatureRegistryEntryLookup.getOrThrow(ModConfiguredFeatures.WILD_GREEN_BEAN_BUSH_KEY),
                // Placement Modifiers:
                RarityFilterPlacementModifier.of(config.wildGreenBeanBushRarity.get()),
                SquarePlacementModifier.of(),
                PlacedFeatures.MOTION_BLOCKING_HEIGHTMAP,
                BiomePlacementModifier.of()
        );
        // --- End Register Placed Green Bean ---

        // --- Register Placed Cucumber Bush ---
        register(context, WILD_CUCUMBER_BUSH_PLACED_KEY,
                configuredFeatureRegistryEntryLookup.getOrThrow(ModConfiguredFeatures.WILD_CUCUMBER_BUSH_KEY),
                // Placement Modifiers:
                RarityFilterPlacementModifier.of(config.wildCucumberBushRarity.get()),
                SquarePlacementModifier.of(),
                PlacedFeatures.MOTION_BLOCKING_HEIGHTMAP,
                BiomePlacementModifier.of()
        );
        // --- End Register Placed Cucumber ---
    }

    // Helper methods (Existing)
    public static RegistryKey<PlacedFeature> registerKey(String name) {
        return RegistryKey.of(RegistryKeys.PLACED_FEATURE, Identifier.of(AdorableHamsterPets.MOD_ID, name));
    }

    private static void register(Registerable<PlacedFeature> context, RegistryKey<PlacedFeature> key, RegistryEntry<ConfiguredFeature<?, ?>> configuration,
                                 List<PlacementModifier> modifiers) {
        context.register(key, new PlacedFeature(configuration, List.copyOf(modifiers)));
    }

    // Overload to accept varargs for modifiers (makes registration cleaner)
    private static void register(Registerable<PlacedFeature> context, RegistryKey<PlacedFeature> key, RegistryEntry<ConfiguredFeature<?, ?>> configuration,
                                 PlacementModifier... modifiers) {
        register(context, key, configuration, List.of(modifiers));
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/client/announcements/`
`Announcement.java`
```java
package net.dawson.adorablehamsterpets.client.announcements;

// (Imports omitted to save token count)

public record Announcement(
        String id,
        String kind,
        String semver,
        String title,
        String markdown,
        ZonedDateTime published
) {
    // Custom codec for ZonedDateTime using xmap to convert to/from String
    private static final Codec<ZonedDateTime> ZONED_DATE_TIME_CODEC = Codec.STRING.comapFlatMap(
            s -> {
                try {
                    return DataResult.success(ZonedDateTime.parse(s));
                } catch (DateTimeParseException e) {
                    return DataResult.error(() -> "Not a valid ZonedDateTime: " + e.getMessage());
                }
            },
            ZonedDateTime::toString
    );
    public static final Codec<Announcement> CODEC = RecordCodecBuilder.create(instance -> instance.group(
            Codec.STRING.fieldOf("id").forGetter(Announcement::id),
            Codec.STRING.fieldOf("kind").forGetter(Announcement::kind),
            Codec.STRING.fieldOf("semver").forGetter(Announcement::semver),
            Codec.STRING.fieldOf("title").forGetter(Announcement::title),
            Codec.STRING.fieldOf("markdown").forGetter(Announcement::markdown),
            ZONED_DATE_TIME_CODEC.fieldOf("published").forGetter(Announcement::published)
    ).apply(instance, Announcement::new));
}
```

`AnnouncementHudRenderer.java`
```java
package net.dawson.adorablehamsterpets.client.announcements;

// (Imports omitted to save token count)

/**
 * Renders the non-interactive announcement icon on the main game HUD.
 * This class is responsible for calculating the icon's position based on config settings
 * and drawing it using animation values from the central AnnouncementIconAnimator.
 */
public class AnnouncementHudRenderer {
    private static final Identifier ICON_TEXTURE = Identifier.of(AdorableHamsterPets.MOD_ID, "textures/item/announcement_bell_icon.png");
    private static final int ICON_WIDTH = 16;
    private static final int ICON_HEIGHT = 16;

    public void render(DrawContext context, float tickDelta) {
        MinecraftClient client = MinecraftClient.getInstance();
        final AhpConfig config = Configs.AHP;

        // --- 1. Pre-render Checks ---
        // Do not render if the config disables it, a GUI is open, or there are no notifications.
        if (!config.enableHudIcon.get() || client.currentScreen != null) {
            return;
        }
        List<AnnouncementManager.PendingNotification> notifications = AdorableHamsterPetsClient.getPendingNotifications();
        if (notifications.isEmpty()) {
            return;
        }

        // --- 2. Get Animation State from Central Animator ---
        AnnouncementIconAnimator animator = AnnouncementIconAnimator.INSTANCE;
        animator.setHovered(false); // The HUD icon is never hovered

        // --- 3. Calculate Position and Update Animator ---
        int screenWidth = context.getScaledWindowWidth();
        int screenHeight = context.getScaledWindowHeight();

        // This now calculates and sets the target position inside the animator
        animator.updateTargetPosition(screenWidth, screenHeight);

        // This snaps the current position to the target for the non-interactive HUD icon
        animator.updateHudPosition(animator.getTargetX(), animator.getTargetY());

        // --- 4. Get Animation State from Central Animator ---
        float animScale = animator.getRenderScale(tickDelta);
        float configScale = Configs.AHP.hudIconScale.get();
        float finalScale = animScale * configScale;
        float angle = animator.getRenderAngle(tickDelta);
        double renderX = animator.getRenderX(tickDelta);
        double renderY = animator.getRenderY(tickDelta);

        // --- 5. Render the Icon ---
        context.getMatrices().push();
        // Use the interpolated renderX and renderY values
        // Translate to the icon's center for proper scaling and rotation
        try {
            context.getMatrices().translate(renderX + (ICON_WIDTH / 2.0), renderY + (ICON_HEIGHT / 2.0), 0);
            context.getMatrices().scale(finalScale, finalScale, 1.0f);
            context.getMatrices().multiply(RotationAxis.POSITIVE_Z.rotationDegrees(angle));
            // Translate back to the top-left corner to draw the texture
            context.getMatrices().translate(-(ICON_WIDTH / 2.0), -(ICON_HEIGHT / 2.0), 0);

            RenderSystem.enableBlend();
            context.drawTexture(ICON_TEXTURE, 0, 0, 0, 0, ICON_WIDTH, ICON_HEIGHT, ICON_WIDTH, ICON_HEIGHT);
        } finally {
            context.getMatrices().pop();
        }

        // --- 6. Render Tooltip on Hover ---
        double mouseX = client.mouse.getX();
        double mouseY = client.mouse.getY();

        if (mouseX >= renderX && mouseX <= renderX + (ICON_WIDTH * finalScale) &&
                mouseY >= renderY && mouseY <= renderY + (ICON_HEIGHT * finalScale)) {

            List<Text> tooltipLines = new java.util.ArrayList<>();
            Text modNameText = Text.translatable("key.categories.adorablehamsterpets.main").formatted(Formatting.BLUE, Formatting.ITALIC);

            AnnouncementManager.PendingNotification primary = notifications.get(0);
            // Use centralized helper method to get the main tooltip line
            Text mainTooltipLine = AnnouncementManager.getTooltipTextForNotification(primary);

            tooltipLines.add(mainTooltipLine);
            tooltipLines.add(modNameText);
            context.drawTooltip(client.textRenderer, tooltipLines, (int)mouseX, (int)mouseY);
        }
    }
}
```

`AnnouncementManager.java`
```java
package net.dawson.adorablehamsterpets.client.announcements;

// (Imports omitted to save token count)

/**
 * Manages fetching, caching, and displaying remote announcements and update notifications.
 * This class is a singleton and handles all client-side state related to announcements.
 */
public class AnnouncementManager {
    // --- 1. Constants, Static Fields, and Nested Types ---
    public static final AnnouncementManager INSTANCE = new AnnouncementManager();
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static final String GITHUB_RAW_URL = "https://raw.githubusercontent.com/DawsonBodenhamer/AdorableHamsterPets-Public/main/announcements/";

    /**
     * A record representing a pending notification, containing the reason it's pending and the announcement itself.
     */
    public record PendingNotification(String reason, Announcement announcement) {
        public static final String UPDATE_AVAILABLE_ANNOUNCEMENT = "update_available_announcement";
        public static final String REGULAR_ANNOUNCEMENT = "regular_announcement";
        public static final String WHATS_NEW_ANNOUNCEMENT = "whats_new_announcement";
    }

    /**
     * Generates the primary tooltip text for a given notification.
     *
     * @param notification The notification to generate text for.
     * @return The formatted Text component for the tooltip.
     */
    public static Text getTooltipTextForNotification(PendingNotification notification) {
        return switch (notification.reason()) {
            case PendingNotification.UPDATE_AVAILABLE_ANNOUNCEMENT ->
                    Text.translatable("tooltip.adorablehamsterpets.hud.update_available_announcement", notification.announcement().semver());
            case PendingNotification.REGULAR_ANNOUNCEMENT ->
                    Text.translatable("tooltip.adorablehamsterpets.hud.regular_announcement");
            default -> Text.translatable("tooltip.adorablehamsterpets.hud.whats_new", notification.announcement().semver());
        };
    }

    // --- 2. Instance Fields ---
    // --- Core State ---
    private ClientAnnouncementState clientState;
    private AnnouncementManifest manifest;

    // --- Initialization & Network ---
    private boolean initialized = false;
    private boolean hasRefreshedThisSession = false;
    private boolean manifestJustLoaded = false;
    private boolean manifestLoaded = false;
    private HttpClient httpClient;
    private CompletableFuture<Void> activeRefreshFuture = CompletableFuture.completedFuture(null);

    // --- Session State ---
    private final Set<String> sessionSnoozedIds = new HashSet<>();
    private final Set<Identifier> deferredReadMarks = new HashSet<>();
    private boolean patchouliStateSynced = false;

    // --- File Paths ---
    private Path stateFilePath;
    private Path manifestCacheFilePath;

    // --- 3. Constructor ---
    /**
     * Private constructor to enforce the singleton pattern.
     * Initializes with default empty states.
     */
    private AnnouncementManager() {
        this.clientState = ClientAnnouncementState.createDefault();
        this.manifest = AnnouncementManifest.empty();
    }

    // --- 4. Public API ---
    // --- Lifecycle & Initialization ---
    /**
     * Ensures the manifest is only fetched once per game session. This is the primary entry point for triggering a refresh.
     *
     * @return A CompletableFuture that completes when the manifest fetch is finished.
     */
    public CompletableFuture<Void> refreshManifestOnce() {
        ensureInitialized();
        if (!hasRefreshedThisSession) {
            hasRefreshedThisSession = true;
            return refreshManifest();
        }
        // If already refreshed, return the active (or last completed) future.
        return activeRefreshFuture;
    }

    /**
     * Asynchronously fetches the markdown content for a specific announcement.
     *
     * @param relativePath The path to the markdown file relative to the announcements directory.
     * @return A CompletableFuture containing the markdown content as a string.
     */
    public CompletableFuture<String> fetchMarkdown(String relativePath) {
        ensureInitialized();

        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(GITHUB_RAW_URL + relativePath))
                .GET()
                .build();

        return httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())
                .thenApply(response -> {
                    if (response.statusCode() == 200) {
                        return response.body();
                    }
                    AdorableHamsterPets.LOGGER.warn("Failed to fetch markdown from '{}', status code: {}", relativePath, response.statusCode());
                    // Return the user-friendly offline message for non-200 responses too
                    return """
                    # Oops! Looks like you're offline.
                    
                    There was supposed to be a really fancy announcement message here, but that requires a teensy bit of internet connection.
                    
                    You can always [join the Discord](https://discord.gg/w54mk5bqdf) to see the latest announcements there!
                    """;
                })
                .exceptionally(e -> {
                    AdorableHamsterPets.LOGGER.error("Exception while fetching markdown from '" + relativePath + "'", e);
                    // Return the user-friendly offline message on network exception
                    return """
                    # Oops! Looks like you're offline.
                    
                    There was supposed to be a really fancy announcement message here, but that requires a teensy bit of internet connection.
                    
                    You can always [join the Discord](https://discord.gg/w54mk5bqdf) to see the latest announcements there!
                    """;
                });
    }

    // --- State Querying ---
    /**
     * Calculates the list of currently pending notifications for the user.
     * This is the core logic that determines if the notification icon should be shown.
     *
     * @return A list of {@link PendingNotification} records, sorted with the newest first.
     */
    public List<PendingNotification> getPendingNotifications() {
        ensureInitialized();
        if (!this.manifestLoaded) {
            return Collections.emptyList(); // Guard against race condition
        }

        AdorableHamsterPets.LOGGER.trace("[Announcements] Running getPendingNotifications check...");
        List<PendingNotification> pending = new ArrayList<>();
        if (manifest == null || manifest.messages().isEmpty()) {
            AdorableHamsterPets.LOGGER.error("[Announcements] -> Check failed: Manifest is null or empty.");
            return pending; // Nothing to do if manifest is not loaded
        }

        Semver installedVersion = Semver.parse(Platform.getMod(AdorableHamsterPets.MOD_ID).getVersion().toString());
        Semver latestVersion = Semver.parse(manifest.latest_version());
        Semver lastAckVersion = Semver.parse(clientState.last_acknowledged_update());
        Instant now = Instant.now();

        AdorableHamsterPets.LOGGER.trace("[Announcements] -> Versions: Installed={}, Latest={}, LastAck={}", installedVersion, latestVersion, lastAckVersion);
        AdorableHamsterPets.LOGGER.trace("[Announcements] -> Snooze IDs: {}.", clientState.snoozed_ids());

        // --- 2. Check for Update Available Announcements ---
        boolean newUpdateAvailable = installedVersion.compareTo(latestVersion) < 0;
        if (newUpdateAvailable) {
            manifest.messages().stream()
                    .filter(a -> "update".equals(a.kind()) && latestVersion.toString().equals(a.semver()))
                    // Check if it has been seen, snoozed (days), or snoozed (session)
                    .filter(a -> !clientState.seen_ids().contains(a.id())
                            && !clientState.snoozed_ids().getOrDefault(a.id(), Instant.EPOCH).isAfter(now)
                            && !sessionSnoozedIds.contains(a.id()))
                    .findFirst()
                    .ifPresent(announcement -> {
                        pending.add(new PendingNotification(PendingNotification.UPDATE_AVAILABLE_ANNOUNCEMENT, announcement));
                        AdorableHamsterPets.LOGGER.trace("[Announcements] -> ADDED (Update Available): id='{}', semver='{}'", announcement.id(), announcement.semver());
                    });
        }

        // --- 3. Check for All Other Messages (Regular Announcements and Missed "What's New") ---
        AdorableHamsterPets.LOGGER.trace("[Announcements] -> Scanning all {} messages for other notifications...", manifest.messages().size());
        for (Announcement message : manifest.messages()) {
            if (clientState.seen_ids().contains(message.id())
                    || clientState.snoozed_ids().getOrDefault(message.id(), Instant.EPOCH).isAfter(now)
                    || sessionSnoozedIds.contains(message.id())) {
                continue;
            }

            Semver messageVersion = Semver.parse(message.semver());

            // --- 3a. Regular Announcements ---
            if ("announcement".equals(message.kind())) {
                pending.add(new PendingNotification(PendingNotification.REGULAR_ANNOUNCEMENT, message));
                AdorableHamsterPets.LOGGER.trace("[Announcements] -> ADDED (Optional Announcement): id='{}'", message.id());
                continue;
            }

            // --- 3b. "What's New" Announcements for Current or Past Versions ---
            if ("update".equals(message.kind())) {
                boolean versionIsRelevant = messageVersion.compareTo(installedVersion) <= 0;
                boolean isUnacknowledged = messageVersion.compareTo(lastAckVersion) > 0;

                if (versionIsRelevant && isUnacknowledged) {
                    // Don't add it if it's already pending as the main "update available" notification
                    boolean alreadyPendingAsUpdate = newUpdateAvailable && message.semver().equals(latestVersion.toString());
                    if (!alreadyPendingAsUpdate) {
                        pending.add(new PendingNotification(PendingNotification.WHATS_NEW_ANNOUNCEMENT, message));
                        AdorableHamsterPets.LOGGER.trace("[Announcements] -> ADDED (What's New): id='{}', semver='{}'", message.id(), message.semver());
                    } else {
                        AdorableHamsterPets.LOGGER.trace("[Announcements] -> SKIPPED (Duplicate Update): id='{}'", message.id());
                    }
                }
            }
        }

        // --- 4. Sort by publication date, newest first ---
        pending.sort(Comparator.comparing((PendingNotification p) -> p.announcement().published()).reversed());
        AdorableHamsterPets.LOGGER.trace("[Announcements] -> Final pending count: {}", pending.size());
        return pending;
    }

    /**
     * Gets the current client-side announcement state record, which contains seen IDs, snoozed IDs, etc.
     *
     * @return The current ClientAnnouncementState record.
     */
    public ClientAnnouncementState getClientState() {
        ensureInitialized();
        return this.clientState;
    }

    /**
     * Retrieves a specific announcement by its unique ID from the current manifest.
     *
     * @param id The ID of the announcement to find.
     * @return The {@link Announcement} if found, otherwise null.
     */
    public Announcement getAnnouncementById(String id) {
        ensureInitialized();
        return manifest.messages().stream()
                .filter(a -> a.id().equals(id))
                .findFirst()
                .orElse(null);
    }

    /**
     * Gets the complete list of all announcements from the current manifest.
     *
     * @return A list of all {@link Announcement} objects.
     */
    public List<Announcement> getAllManifestMessages() {
        ensureInitialized();
        return manifest != null ? manifest.messages() : List.of();
    }

    /**
     * Determines the canonical "reason" for a notification based on its properties and the current game state.
     *
     * @param announcementId The ID of the announcement to check.
     * @return The reason string (e.g., "update_available_announcement").
     */
    public String getCanonicalReasonForAnnouncement(String announcementId) {
        ensureInitialized();
        Announcement announcement = getAnnouncementById(announcementId);
        if (announcement == null) return "unknown"; // Fallback for safety

        Semver installedVersion = Semver.parse(Platform.getMod(AdorableHamsterPets.MOD_ID).getVersion().toString());
        Semver latestVersion = Semver.parse(manifest.latest_version());

        // --- 1. Check for "Update Available" ---
        if (installedVersion.compareTo(latestVersion) < 0 && announcement.semver().equals(latestVersion.toString())) {
            return PendingNotification.UPDATE_AVAILABLE_ANNOUNCEMENT;
        }

        // --- 2. Check for Regular Announcements ---
        if ("announcement".equals(announcement.kind())) {
            return PendingNotification.REGULAR_ANNOUNCEMENT;
        }

        // --- 3. Fallback ---
        return announcement.kind();
    }

    /**
     * Checks if the initial synchronization of read states with Patchouli has been completed for this session.
     *
     * @return True if the sync is complete, false otherwise.
     */
    public boolean isPatchouliStateSynced() {
        return this.patchouliStateSynced;
    }

    // --- State Modification ---
    /**
     * Marks a specific announcement as "seen" by the user and persists this state to disk.
     *
     * @param id The ID of the announcement to mark as seen.
     */
    public void markAsSeen(String id) {
        ensureInitialized();
        Set<String> newSeenIds = new HashSet<>(clientState.seen_ids());
        if (newSeenIds.add(id)) {
            clientState = new ClientAnnouncementState(
                    newSeenIds,
                    clientState.snoozed_ids(),
                    clientState.last_acknowledged_update(),
                    clientState.manifest_etag(),
                    clientState.manifest_last_modified()
            );
            saveState();
        }
    }

    /**
     * Marks all available announcements as read. This is triggered by a user action.
     */
    public void markAllAsRead() {
        ensureInitialized();

        // Get the book instance once
        Book book = BookRegistry.INSTANCE.books.get(Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_tips_guide_book"));
        if (book == null) {
            AdorableHamsterPets.LOGGER.error("[Announcements] Could not mark all as read: Hamster Tips book not found.");
            return;
        }

        // Create a mutable copy of the seen IDs to modify
        Set<String> newSeenIds = new HashSet<>(clientState.seen_ids());
        boolean changed = false;

        for (Announcement announcement : getAllManifestMessages()) {
            // Add the ID to the set. The return value of add() tells us if it was a new addition.
            if (newSeenIds.add(announcement.id())) {
                changed = true;
            }

            // Acknowledge any update-related messages
            if ("update".equals(announcement.kind())) {
                setLastAcknowledgedUpdate(announcement.semver());
            }

            // Find and mark the corresponding virtual entry in Patchouli as read
            Identifier entryId = Identifier.of(AdorableHamsterPets.MOD_ID, "announcement_" + announcement.id());
            BookEntry entry = book.getContents().entries.get(entryId);
            if (entry != null) {
                PatchouliIntegration.setEntryAsRead(entry);
            }
        }

        // Only save the state if something actually changed
        if (changed) {
            clientState = new ClientAnnouncementState(
                    newSeenIds,
                    clientState.snoozed_ids(),
                    clientState.last_acknowledged_update(),
                    clientState.manifest_etag(),
                    clientState.manifest_last_modified()
            );
            saveState();
            AdorableHamsterPets.LOGGER.info("Marked all announcements as read via config action.");
        }
    }

    /**
     * Updates the last acknowledged update version if the new version is greater.
     *
     * @param version The semantic version string to acknowledge.
     */
    public void setLastAcknowledgedUpdate(String version) {
        ensureInitialized();
        Semver currentAck = Semver.parse(clientState.last_acknowledged_update());
        Semver newAck = Semver.parse(version);
        if (newAck.compareTo(currentAck) > 0) {
            clientState = new ClientAnnouncementState(
                    clientState.seen_ids(),
                    clientState.snoozed_ids(),
                    newAck.toString(),
                    clientState.manifest_etag(),
                    clientState.manifest_last_modified()
            );
            saveState();
        }
    }

    /**
     * Snoozes a specific announcement for a configured number of days. This state is persisted.
     *
     * @param id   The ID of the announcement to snooze.
     * @param days The number of days to snooze for.
     */
    public void setSnooze(String id, int days) {
        ensureInitialized();
        Instant snoozeUntil = Instant.now().plus(days, ChronoUnit.DAYS);
        Map<String, Instant> newSnoozedIds = new HashMap<>(clientState.snoozed_ids());
        newSnoozedIds.put(id, snoozeUntil);

        clientState = new ClientAnnouncementState(
                clientState.seen_ids(),
                newSnoozedIds,
                clientState.last_acknowledged_update(),
                clientState.manifest_etag(),
                clientState.manifest_last_modified()
        );
        saveState();
    }

    /**
     * Snoozes a specific announcement for the duration of the current game session only. This state is not persisted.
     *
     * @param id The ID of the announcement to snooze for the session.
     */
    public void snoozeForSession(String id) {
        ensureInitialized();
        sessionSnoozedIds.add(id);
    }

    /**
     * Resets all client-side announcement state, including seen, snoozed, and acknowledged versions.
     */
    public void resetClientState() {
        ensureInitialized();
        this.clientState = ClientAnnouncementState.createDefault();
        saveState();
        PatchouliIntegration.clearAllVirtualEntriesFromHistory();
        AdorableHamsterPets.LOGGER.info("Client announcement state has been reset.");
    }

    // --- Patchouli Integration ---
    /**
     * Queues a virtual entry's ID to be marked as read in Patchouli's data at a later, safer time.
     *
     * @param entryId The Identifier of the virtual BookEntry.
     */
    public void queueDeferredReadMark(Identifier entryId) {
        ensureInitialized();
        this.deferredReadMarks.add(entryId);
        AdorableHamsterPets.LOGGER.trace("[Announcements] Queued deferred read mark for entry: {}", entryId);
    }

    /**
     * Processes all queued deferred read marks. Called when the client joins a world.
     */
    public void processDeferredReadMarks() {
        ensureInitialized();
        if (deferredReadMarks.isEmpty()) {
            return;
        }

        AdorableHamsterPets.LOGGER.trace("[Announcements] Processing {} deferred read marks...", deferredReadMarks.size());
        // Get the book from the common BookRegistry's public map.
        Book book = BookRegistry.INSTANCE.books.get(Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_tips_guide_book"));
        if (book == null) {
            AdorableHamsterPets.LOGGER.error("[Announcements] Could not process deferred read marks: Hamster Tips book not found.");
            return;
        }

        int successCount = 0;
        for (Identifier entryId : deferredReadMarks) {
            // Access the public 'entries' map directly.
            BookEntry entry = book.getContents().entries.get(entryId);
            if (entry != null) {
                PatchouliIntegration.setEntryAsRead(entry);
                successCount++;
            } else {
                AdorableHamsterPets.LOGGER.warn("[Announcements] Could not find virtual entry for deferred read mark: {}", entryId);
            }
        }

        if (successCount > 0) {
            AdorableHamsterPets.LOGGER.trace("[Announcements] Successfully processed {} deferred read marks.", successCount);
        }

        deferredReadMarks.clear();
    }

    // --- 5. Private Implementation ---
    // --- Initialization & Lifecycle ---
    /**
     * Initializes the manager's components. This is called lazily on first access.
     */
    private void initialize() {
        AdorableHamsterPets.LOGGER.trace("[Announcements] Initializing AnnouncementManager...");
        this.httpClient = HttpClient.newHttpClient();
        Path configDir = Platform.getConfigFolder().resolve(AdorableHamsterPets.MOD_ID);
        this.stateFilePath = configDir.resolve("announcements.json");
        this.manifestCacheFilePath = configDir.resolve("manifest.cache.json");
        AdorableHamsterPets.LOGGER.trace("[Announcements] State file path resolved to: {}", stateFilePath.toAbsolutePath());
        try {
            Files.createDirectories(configDir);
        } catch (IOException e) {
            AdorableHamsterPets.LOGGER.error("[Announcements] CRITICAL: Failed to create config directory for announcements at {}", configDir.toAbsolutePath(), e);
        }
        loadState();
        loadCachedManifest();
        processExpiredSnoozes();
        AdorableHamsterPets.LOGGER.trace("[Announcements] Initialization complete.");
    }

    /**
     * Ensures that the manager is initialized before any of its methods are used.
     */
    private void ensureInitialized() {
        if (!initialized) {
            initialize();
            initialized = true;
        }
    }

    /**
     * Acknowledges that the manifest has been loaded and processed for the current UI context.
     */
    public void acknowledgeManifestLoad() {
        ensureInitialized();
        this.manifestJustLoaded = false;
    }

    // --- Network & Caching ---
    /**
     * Ensures the manifest is refreshed if needed, returning a future that completes when the refresh is done.
     * This method is the primary entry point for triggering a refresh.
     *
     * @return A CompletableFuture that completes when the manifest fetch is finished.
     */
    public CompletableFuture<Void> refreshManifest() {
        ensureInitialized();

        if (!activeRefreshFuture.isDone()) {
            return activeRefreshFuture;
        }

        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()
                .uri(URI.create(GITHUB_RAW_URL + "manifest.json"))
                .GET();

        clientState.manifest_etag().ifPresent(etag -> requestBuilder.header("If-None-Match", etag));
        clientState.manifest_last_modified().ifPresent(lastModified -> requestBuilder.header("If-Modified-Since", lastModified));

        activeRefreshFuture = httpClient.sendAsync(requestBuilder.build(), HttpResponse.BodyHandlers.ofString())
                .thenAccept(response -> {
                    AdorableHamsterPets.LOGGER.trace("[Announcements] Manifest fetch completed with status code {}. Current screen: {}", response.statusCode(), MinecraftClient.getInstance().currentScreen);
                    if (response.statusCode() == 200) { // OK
                        AdorableHamsterPets.LOGGER.trace("[Announcements] Fetched new manifest.");
                        AnnouncementManifest.CODEC.parse(JsonOps.INSTANCE, GSON.fromJson(response.body(), com.google.gson.JsonElement.class))
                                .resultOrPartial(AdorableHamsterPets.LOGGER::error)
                                .ifPresent(newManifest -> {
                                    this.manifest = newManifest;
                                    this.manifestLoaded = true;
                                    saveManifestToCache();

                                    Optional<String> etag = response.headers().firstValue("ETag");
                                    Optional<String> lastModified = response.headers().firstValue("Last-Modified");

                                    this.clientState = new ClientAnnouncementState(
                                            clientState.seen_ids(),
                                            clientState.snoozed_ids(),
                                            clientState.last_acknowledged_update(),
                                            etag,
                                            lastModified
                                    );
                                    saveState();
                                    this.manifestJustLoaded = true;

                                    if (MinecraftClient.getInstance().world != null) {
                                        MinecraftClient.getInstance().execute(() -> {
                                            ClientBookRegistry.INSTANCE.reload();
                                            acknowledgeManifestLoad();
                                        });
                                    }
                                });
                    } else if (response.statusCode() == 304) { // Not Modified
                        AdorableHamsterPets.LOGGER.trace("[Announcements] Manifest is up to date (304 Not Modified).");
                    } else {
                        AdorableHamsterPets.LOGGER.warn("[Announcements] Failed to fetch manifest, status code: {}", response.statusCode());
                    }
                }).exceptionally(e -> {
                    AdorableHamsterPets.LOGGER.error("[Announcements] Exception while fetching manifest. Using cached version or offline fallback.", e);
                    // If the manifest is STILL empty (meaning no cache was loaded), create the fallback.
                    if (this.manifest == null || this.manifest.messages().isEmpty()) {
                        this.manifest = createOfflineFallbackManifest();
                        this.manifestLoaded = true;
                        this.manifestJustLoaded = true; // Signal that a "new" manifest is ready

                        if (MinecraftClient.getInstance().world != null) {
                            MinecraftClient.getInstance().execute(() -> {
                                ClientBookRegistry.INSTANCE.reload();
                                acknowledgeManifestLoad();
                            });
                        }
                    }
                    return null;
                });
        return activeRefreshFuture;
    }

    // --- File I/O (State Persistence) ---
    /**
     * Loads the client's announcement state from announcements.json.
     */
    private void loadState() {
        AdorableHamsterPets.LOGGER.trace("[Announcements] Attempting to load state from {}...", stateFilePath.toAbsolutePath()); // LOG 4: Load Start
        if (Files.exists(stateFilePath)) {
            AdorableHamsterPets.LOGGER.trace("[Announcements] announcements.json found. Reading file."); // LOG 5a: File Found
            try (FileReader reader = new FileReader(stateFilePath.toFile())) {
                ClientAnnouncementState.CODEC.parse(JsonOps.INSTANCE, GSON.fromJson(reader, com.google.gson.JsonElement.class))
                        .resultOrPartial(AdorableHamsterPets.LOGGER::error)
                        .ifPresent(state -> this.clientState = state);
            } catch (IOException e) {
                AdorableHamsterPets.LOGGER.error("[Announcements] CRITICAL: Failed to load announcement state from existing file.", e);
            }
        } else {
            AdorableHamsterPets.LOGGER.trace("[Announcements] announcements.json not found. Creating default state file."); // LOG 5b: File Not Found
            saveState(); // Create default file if it doesn't exist
        }
    }

    /**
     * Saves the current client state to announcements.json.
     */
    private void saveState() {
        AdorableHamsterPets.LOGGER.trace("[Announcements] Attempting to save state..."); // LOG 6: Save Start
        ClientAnnouncementState.CODEC.encodeStart(JsonOps.INSTANCE, this.clientState)
                .resultOrPartial(error -> AdorableHamsterPets.LOGGER.error("[Announcements] CRITICAL: Failed to encode client state to JSON: {}", error)) // LOG 7: Encode Error
                .ifPresent(jsonElement -> {
                    AdorableHamsterPets.LOGGER.trace("[Announcements] State encoded successfully. Writing to file: {}", stateFilePath.toAbsolutePath()); // LOG 8: Writing
                    try (FileWriter writer = new FileWriter(stateFilePath.toFile())) {
                        GSON.toJson(jsonElement, writer);
                        AdorableHamsterPets.LOGGER.trace("[Announcements] Successfully saved announcement state."); // LOG 9: Success
                    } catch (IOException e) {
                        AdorableHamsterPets.LOGGER.error("[Announcements] CRITICAL: FAILED TO SAVE ANNOUNCEMENT STATE TO FILE.", e); // LOG 10: Write Error
                    }
                });
    }

    /**
     * Loads the announcement manifest from the local cache file.
     */
    private void loadCachedManifest() {
        if (Files.exists(manifestCacheFilePath)) {
            try (FileReader reader = new FileReader(manifestCacheFilePath.toFile())) {
                AnnouncementManifest.CODEC.parse(JsonOps.INSTANCE, GSON.fromJson(reader, com.google.gson.JsonElement.class))
                        .resultOrPartial(AdorableHamsterPets.LOGGER::error)
                        .ifPresent(cachedManifest -> {
                            this.manifest = cachedManifest;
                            this.manifestLoaded = true; // Mark as loaded from cache
                            AdorableHamsterPets.LOGGER.trace("[Announcements] Loaded cached manifest with {} messages.", manifest.messages().size());
                        });
            } catch (IOException e) {
                AdorableHamsterPets.LOGGER.error("[Announcements] Failed to load cached manifest.", e);
            }
        }
    }

    /**
     * Saves the current in-memory manifest to the local cache file.
     */
    private void saveManifestToCache() {
        AnnouncementManifest.CODEC.encodeStart(JsonOps.INSTANCE, this.manifest)
                .resultOrPartial(error -> AdorableHamsterPets.LOGGER.error("[Announcements] Failed to encode manifest for caching: {}", error))
                .ifPresent(jsonElement -> {
                    try (FileWriter writer = new FileWriter(manifestCacheFilePath.toFile())) {
                        GSON.toJson(jsonElement, writer);
                        AdorableHamsterPets.LOGGER.trace("[Announcements] Successfully saved manifest to cache.");
                    } catch (IOException e) {
                        AdorableHamsterPets.LOGGER.error("[Announcements] FAILED TO SAVE MANIFEST TO CACHE.", e);
                    }
                });
    }

    // --- Internal Logic & Syncing ---
    /**
     * Iterates through snoozed announcements and removes any whose snooze period has expired.
     */
    private void processExpiredSnoozes() {
        Instant now = Instant.now();
        Map<String, Instant> newSnoozedIds = new HashMap<>(clientState.snoozed_ids());

        // Use removeIf for safe concurrent modification
        newSnoozedIds.entrySet().removeIf(entry -> {
            if (now.isAfter(entry.getValue())) {
                // Snooze has expired
                Identifier entryId = Identifier.of(AdorableHamsterPets.MOD_ID, "announcement_" + entry.getKey());
                PatchouliIntegration.setEntryAsUnread(entryId);
                return true; // Remove this entry from the map
            }
            return false;
        });

        if (newSnoozedIds.size() != clientState.snoozed_ids().size()) {
            clientState = new ClientAnnouncementState(
                    clientState.seen_ids(),
                    newSnoozedIds,
                    clientState.last_acknowledged_update(),
                    clientState.manifest_etag(),
                    clientState.manifest_last_modified()
            );
            saveState();
        }
    }

    /**
     * Synchronizes the read state of pending notifications with Patchouli's data.
     */
    public void syncPatchouliReadState() {
        ensureInitialized();

        // --- See if Patchouli is ready ---
        Identifier bookId = Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_tips_guide_book");
        Book book = BookRegistry.INSTANCE.books.get(bookId);
        if (book == null) {
            // Patchouli is not ready yet. Try again on the next tick.
            return;
        }

        // --- Sync and stop trying ---
        this.patchouliStateSynced = true;
        AdorableHamsterPets.LOGGER.trace("[Announcements] Patchouli book found. Syncing read state...");

        List<PendingNotification> pendingNotifications = getPendingNotifications();
        if (pendingNotifications.isEmpty()) {
            AdorableHamsterPets.LOGGER.trace("[Announcements] -> No pending notifications to sync.");
            return;
        }

        AdorableHamsterPets.LOGGER.trace("[Announcements] -> Found {} pending notifications to sync.", pendingNotifications.size());

        for (PendingNotification notification : pendingNotifications) {
            Identifier entryId = Identifier.of(AdorableHamsterPets.MOD_ID, "announcement_" + notification.announcement().id());
            AdorableHamsterPets.LOGGER.trace("[Announcements] -> Syncing entry: {}", entryId);
            boolean success = PatchouliIntegration.setEntryAsUnread(entryId);
            if (success) {
                AdorableHamsterPets.LOGGER.trace("[Announcements] -> Successfully marked {} as unread.", entryId);
            } else {
                // This might log if the entry was already unread.
                AdorableHamsterPets.LOGGER.error("[Announcements] -> Could not mark {} as unread (was it already unread?).", entryId);
            }
        }
    }

    // --- Fallbacks ---
    /**
     * Creates a hardcoded, in-memory Announcement to be used as a fallback when offline.
     *
     * @return A default Announcement object.
     */
    private Announcement createOfflineFallbackAnnouncement() {
        return new Announcement(
                "offline-fallback",
                "No Internet Connection",
                "announcement",
                "0.0.0",
                "offline-fallback.md",  // markdown
                ZonedDateTime.now()              // published
        );
    }

    /**
     * Creates a manifest containing only the offline fallback announcement.
     *
     * @return A default AnnouncementManifest object.
     */
    private AnnouncementManifest createOfflineFallbackManifest() {
        return new AnnouncementManifest("0.0.0", List.of(createOfflineFallbackAnnouncement()));
    }
}
```

`AnnouncementManifest.java`
```java
package net.dawson.adorablehamsterpets.client.announcements;

// (Imports omitted to save token count)

public record AnnouncementManifest(
        String latest_version,
        List<Announcement> messages
) {
    public static final Codec<AnnouncementManifest> CODEC = RecordCodecBuilder.create(instance -> instance.group(
            Codec.STRING.fieldOf("latest_version").forGetter(AnnouncementManifest::latest_version),
            Announcement.CODEC.listOf().fieldOf("messages").forGetter(AnnouncementManifest::messages)
    ).apply(instance, AnnouncementManifest::new));

    public static AnnouncementManifest empty() {
        return new AnnouncementManifest("0.0.0", List.of());
    }
}
```

`ClientAnnouncementState.java`
```java
package net.dawson.adorablehamsterpets.client.announcements;

// (Imports omitted to save token count)

public record ClientAnnouncementState(
        Set<String> seen_ids,
        Map<String, Instant> snoozed_ids,
        String last_acknowledged_update,
        Optional<String> manifest_etag,
        Optional<String> manifest_last_modified
) {
    // Custom codec for a Set of Strings, built from a List codec
    private static final Codec<Set<String>> STRING_SET_CODEC = Codec.STRING.listOf().xmap(Set::copyOf, List::copyOf);
    private static final Codec<Map<String, Instant>> SNOOZE_MAP_CODEC = Codec.unboundedMap(Codec.STRING, Codecs.INSTANT);

    public static final Codec<ClientAnnouncementState> CODEC = RecordCodecBuilder.create(instance -> instance.group(
            STRING_SET_CODEC.fieldOf("seen_ids").forGetter(ClientAnnouncementState::seen_ids),
            SNOOZE_MAP_CODEC.optionalFieldOf("snoozed_ids", Map.of()).forGetter(ClientAnnouncementState::snoozed_ids),
            Codec.STRING.fieldOf("last_acknowledged_update").forGetter(ClientAnnouncementState::last_acknowledged_update),
            Codec.STRING.optionalFieldOf("manifest_etag").forGetter(ClientAnnouncementState::manifest_etag),
            Codec.STRING.optionalFieldOf("manifest_last_modified").forGetter(ClientAnnouncementState::manifest_last_modified)
    ).apply(instance, ClientAnnouncementState::new));

    public static ClientAnnouncementState createDefault() {
        return new ClientAnnouncementState(
                Set.of(),
                Map.of(),
                "0.0.0",
                Optional.empty(),
                Optional.empty()
        );
    }
}
```

`PatchouliIntegration.java`
```java
package net.dawson.adorablehamsterpets.client.announcements;

// (Imports omitted to save token count)

public class PatchouliIntegration {

    /**
     * Marks a specific entry as "read" in Patchouli's data, preventing duplicates.
     *
     * @param entry The BookEntry to mark as read.
     */
    public static void setEntryAsRead(BookEntry entry) {
        if (entry == null) return;

        PersistentData.BookData data = PersistentData.data.getBookData(entry.getBook());
        Identifier entryId = entry.getId();

        // Check if the entry is already in the list before adding
        if (!data.viewedEntries.contains(entryId)) {
            data.viewedEntries.add(entryId);

            // If the book doesn't exist yet on the title screen, save the
            // data to the file, but don't try to refresh the book UI
            if (entry.getCategory() != null) {
                entry.markReadStateDirty();
            }

            PersistentData.save();
            AdorableHamsterPets.LOGGER.debug("[Announcements] Marked Patchouli entry '{}' as read.", entryId);
        }
    }

    /**
     * Removes an entry from Patchouli's "viewedEntries" list, making it appear as "unread" again.
     *
     * @param entryId The full Identifier of the entry to mark as unread.
     */
    public static boolean setEntryAsUnread(Identifier entryId) {
        Identifier bookId = Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_tips_guide_book");
        Book book = BookRegistry.INSTANCE.books.get(bookId);
        if (book == null) {
            return false;
        }

        PersistentData.BookData data = PersistentData.data.getBookData(book);
        if (data.viewedEntries.remove(entryId)) {
            BookEntry entry = book.getContents().entries.get(entryId);
            if (entry != null) {
                entry.markReadStateDirty(); // Tell Patchouli its visual state needs an update
            }
            PersistentData.save(); // Save the changes to patchouli_data.json
            return true; // The entry was found and removed from the 'viewed' list.
        }
        return false; // The entry was not in the 'viewed' list to begin with.
    }

    /**
     * Clears all virtual announcement and update entries from Patchouli's history.
     */
    public static void clearAllVirtualEntriesFromHistory() {
        Identifier bookId = Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_tips_guide_book");
        Book book = BookRegistry.INSTANCE.books.get(bookId);
        if (book == null) return;

        PersistentData.BookData data = PersistentData.data.getBookData(book);
        List<Identifier> viewed = data.viewedEntries;

        // Use removeIf to efficiently remove all entries that match our virtual entry prefix
        boolean removed = viewed.removeIf(id ->
                id.getNamespace().equals(AdorableHamsterPets.MOD_ID) &&
                        id.getPath().startsWith("announcement_")
        );

        if (removed) {
            // If any entries were removed, mark all book contents as dirty to force a UI refresh
            if (book.getContents() != null) {
                book.getContents().entries.values().forEach(BookEntry::markReadStateDirty);
            }
            PersistentData.save();
            AdorableHamsterPets.LOGGER.debug("[Announcements] Cleared all virtual announcement entries from Patchouli history.");
        }
    }
}
```

`Semver.java`
```java
package net.dawson.adorablehamsterpets.client.announcements;

// (Imports omitted to save token count)

public record Semver(int major, int minor, int patch) implements Comparable<Semver> {

    public static Semver parse(String versionString) {
        if (versionString == null || versionString.isBlank()) {
            return new Semver(0, 0, 0);
        }
        try {
            String[] parts = versionString.split("[.\\-+]"); // Split by '.', '-', or '+'
            int major = Integer.parseInt(parts[0]);
            int minor = parts.length > 1 ? Integer.parseInt(parts[1]) : 0;
            int patch = parts.length > 2 ? Integer.parseInt(parts[2]) : 0;
            return new Semver(major, minor, patch);
        } catch (NumberFormatException e) {
            AdorableHamsterPets.LOGGER.warn("Failed to parse semver string: '{}'", versionString);
            return new Semver(0, 0, 0);
        }
    }

    @Override
    public int compareTo(@NotNull Semver other) {
        if (this.major != other.major) {
            return Integer.compare(this.major, other.major);
        }
        if (this.minor != other.minor) {
            return Integer.compare(this.minor, other.minor);
        }
        return Integer.compare(this.patch, other.patch);
    }

    @Override
    public String toString() {
        return major + "." + minor + "." + patch;
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/client/event/`
`AHPClientScreenEvents.java`
```java
package net.dawson.adorablehamsterpets.client.event;

// (Imports omitted to save token count)

/**
 * Handles client-side screen events for dynamically injecting the announcement icon widget.
 */
public final class AHPClientScreenEvents {
    private static final int ICON_SIZE = 16;

    public static void register() {
        // Register a listener for the post-initialization event.
        ClientGuiEvent.INIT_POST.register(AHPClientScreenEvents::onScreenInitPost);
    }

    private static void onScreenInitPost(Screen screen, ScreenAccess access) {
        // --- 1. Pre-condition Checks ---
        if (!Configs.AHP.enableWidgetIcon.get()) {
            return;
        }
        if (AdorableHamsterPetsClient.getPendingNotifications().isEmpty()) {
            return;
        }
        if (!(screen instanceof HandledScreen<?>)) {
            return;
        }

        // --- 2. Create and Add the Widget ---
        // The widget's initial position is temporary; its render method will calculate the true position.
        AnnouncementIconWidget icon = new AnnouncementIconWidget(
                0, 0, ICON_SIZE, ICON_SIZE,
                button -> ((AnnouncementIconWidget) button).onPress(),
                screen // Pass the parent screen to the widget
        );

        access.addRenderableWidget(icon);
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/client/gui/`
`AnnouncementScreen.java`
```java
package net.dawson.adorablehamsterpets.client.gui;

// (Imports omitted to save token count)

/**
 * Renders a scrollable announcement screen for displaying "What's New" updates, patch notes, or other
 * important information fetched from a remote source.
 *
 * <h2>UI Scaling and Layout</h2>
 * This screen employs a custom scaling strategy to ensure the entire UI, including a row of action
 * buttons below the main texture, fits gracefully within any window size.
 * <ul>
 *   <li><b>uiScale:</b> A dynamic downscaling factor (clamped ≤ 1.0) is calculated based on the
 *       available screen space minus a small {@link #EDGE_MARGIN} on all sides. This ensures the
 *       UI never feels cramped against the window edges.</li>
 *   <li><b>Centering:</b> The entire scaled UI (background + padding + buttons) is centered
 *       horizontally and vertically within the available space defined by the margins.</li>
 *   <li><b>Background Rendering:</b> The 256x256 background texture is drawn using a matrix
 *       transformation (translate and scale). This prevents the right and bottom edges of the
 *       texture from being cropped, a common issue when using DrawContext#drawTexture.
 *       with scaled region sizes.</li>
 * </ul>
 *
 * <h2>Key Components</h2>
 * <ul>
 *   <li>A scrollable content area that renders Markdown text.</li>
 *   <li>A custom scrollbar that appears when content overflows.</li>
 *   <li>A dynamically scaled title that adjusts its size to fit the header.</li>
 *   <li>A row of action buttons (e.g., "Mark as Read", "Changelog") that are dynamically generated,
 *       sized, and centered below the main panel.</li>
 * </ul>
 */
public class AnnouncementScreen extends Screen {

    // --- UI Constants ---
    private static final Identifier BACKGROUND_TEXTURE = Identifier.of(AdorableHamsterPets.MOD_ID, "textures/gui/announcement_ui.png");
    private static final Identifier SCROLLBAR_TEXTURE = Identifier.of(AdorableHamsterPets.MOD_ID, "textures/gui/announcement_ui_scroll_bar.png");
    private static final int BACKGROUND_WIDTH = 256;
    private static final int BACKGROUND_HEIGHT = 256;
    private static final int TOTAL_GUI_HEIGHT = 283; // BG height + padding (7) + button height (20)
    private static final int CONTENT_X_OFFSET = 17;
    private static final int CONTENT_Y_OFFSET = 35;
    private static final int CONTENT_WIDTH = 221;
    private static final int CONTENT_HEIGHT = 204;
    private static final int SCROLLBAR_X_OFFSET = 242;
    private static final int SCROLLBAR_START_Y = 28;
    private static final int SCROLLBAR_END_Y = 221;
    private static final int EDGE_MARGIN = 7;
    private static final int BUTTON_WIDTH = 100;

    // --- Fields ---
    private final Announcement announcement;
    private MarkdownRenderer markdownRenderer;
    private String markdownContent = "Loading...";
    private double scrollY = 0.0;
    private int guiLeft;
    private int guiTop;
    @Nullable private Style hoveredStyle = null;
    private final Screen parentScreen;
    private final BookEntry virtualEntry;
    private final String reason;
    private float uiScale = 1.0f;
    private boolean isDraggingScrollbar = false;

    // --- Scaled Layout Fields ---
    private int scaledBackgroundWidth;
    private int scaledBackgroundHeight;
    private int scaledTotalHeight;
    private int scaledContentXOffset;
    private int scaledContentYOffset;
    private int scaledContentWidth;
    private int scaledContentHeight;
    private int scaledScrollBarXOffset;
    private int scaledScrollBarStartY;
    private int scaledScrollBarEndY;
    private int scaledButtonHeight;
    private int scaledButtonPadding;

    public AnnouncementScreen(Announcement announcement, String reason, @Nullable Screen parentScreen, BookEntry virtualEntry) {
        super(Text.literal(announcement.title()));
        this.announcement = announcement;
        this.reason = reason;
        this.parentScreen = parentScreen;
        this.virtualEntry = virtualEntry;
    }

    /**
     * Initializes the screen, calculating all layout dimensions based on the available window size.
     * This method computes a {@code uiScale} to ensure the entire interface (background, padding, and
     * buttons) fits within the screen, leaving a small {@link #EDGE_MARGIN}. It then pre-calculates
     * all scaled dimensions and positions, and initializes all widgets.
     */
    @Override
    @SuppressWarnings("unchecked")
    protected void init() {
        super.init();

        // --- UI Layout Calculation ---
        // Reserve a margin on all sides for breathing room, similar to vanilla screens.
        int availableWidth = Math.max(0, this.width - 2 * EDGE_MARGIN);
        int availableHeight = Math.max(0, this.height - 2 * EDGE_MARGIN);

        // Determine a downscaling factor so the entire UI fits, clamped to 1.0 to prevent upscaling.
        int buttonRows = 2;
        int unscaledTotalHeight = TOTAL_GUI_HEIGHT + (buttonRows - 1) * (20 + 7);
        float scaleX = (float) availableWidth / BACKGROUND_WIDTH;
        float scaleY = (float) availableHeight / unscaledTotalHeight;
        this.uiScale = Math.min(1.0f, Math.min(scaleX, scaleY));

        // Pre-calculate scaled dimensions used throughout the screen.
        this.scaledBackgroundWidth = Math.round(BACKGROUND_WIDTH * this.uiScale);
        this.scaledBackgroundHeight = Math.round(BACKGROUND_HEIGHT * this.uiScale);
        this.scaledContentXOffset = Math.round(CONTENT_X_OFFSET * this.uiScale);
        this.scaledContentYOffset = Math.round(CONTENT_Y_OFFSET * this.uiScale);
        this.scaledContentWidth = Math.max(1, Math.round(CONTENT_WIDTH * this.uiScale));
        this.scaledContentHeight = Math.max(1, Math.round(CONTENT_HEIGHT * this.uiScale));
        this.scaledScrollBarXOffset = Math.round(SCROLLBAR_X_OFFSET * this.uiScale);
        this.scaledScrollBarStartY = Math.round(SCROLLBAR_START_Y * this.uiScale);
        this.scaledScrollBarEndY = Math.round(SCROLLBAR_END_Y * this.uiScale);

        // Scale button dimensions with sensible minimums to maintain usability.
        this.scaledButtonHeight = Math.max(12, Math.round(20 * this.uiScale));
        this.scaledButtonPadding = Math.max(2, Math.round(7 * this.uiScale));

        // The total scaled height is derived from individually scaled components to respect minimums.
        this.scaledTotalHeight = this.scaledBackgroundHeight + buttonRows * (this.scaledButtonHeight + this.scaledButtonPadding);

        // Center the entire UI within the available margin area.
        this.guiLeft = EDGE_MARGIN + (availableWidth - this.scaledBackgroundWidth) / 2;
        this.guiTop = EDGE_MARGIN + (availableHeight - this.scaledTotalHeight) / 2;

        // --- Markdown Renderer Initialization ---
        this.markdownRenderer = new MarkdownRenderer(
                markdownContent,
                this.guiLeft + this.scaledContentXOffset,
                this.guiTop + this.scaledContentYOffset,
                this.scaledContentWidth
        );

        AnnouncementManager.INSTANCE.fetchMarkdown(announcement.markdown()).thenAccept(content -> {
            this.client.execute(() -> {
                this.markdownContent = content;
                this.markdownRenderer = new MarkdownRenderer(
                        content,
                        this.guiLeft + this.scaledContentXOffset,
                        this.guiTop + this.scaledContentYOffset,
                        this.scaledContentWidth
                );
            });
        });

        // --- "←" Close/Back Button ---
        int closeButtonX = this.guiLeft - 10; // Slightly overlapping the left side of the GUI
        int closeButtonY = this.guiTop + 5; // Slightly below the top of the GUI
        // Use ScreenWidgetAdder accessor to add the widget for cross-loader compatibility
        ((ScreenWidgetAdder)(Object)this).adorablehamsterpets$addWidget(ButtonWidget.builder(Text.literal("←").formatted(Formatting.BOLD), button -> this.returnToBook())
                .dimensions(closeButtonX, closeButtonY, 20, 16)
                .tooltip(Tooltip.of(Text.translatable("gui.adorablehamsterpets.announcement.button.close.tooltip")))
                .build());

        // --- Dynamic Button Creation ---
        // Prepare two rows of buttons: primary actions on the first row and secondary actions on the second.
        int buttonWidth = BUTTON_WIDTH;
        int buttonPadding = this.scaledButtonPadding;

        List<ButtonWidget.Builder> primaryBuilders = new ArrayList<>();
        List<ButtonWidget.Builder> secondaryBuilders = new ArrayList<>();

        // 1. "Mark as Read" button (primary row)
        MutableText markAsReadTooltip = Text.translatable("gui.adorablehamsterpets.announcement.button.mark_as_read.tooltip")
                .append("\n\n")
                .append(Text.translatable("gui.adorablehamsterpets.announcement.button.mark_as_read.shift_tooltip").formatted(Formatting.GOLD));

        primaryBuilders.add(ButtonWidget.builder(Text.translatable("gui.adorablehamsterpets.announcement.button.mark_as_read"), button -> {
            if (Screen.hasShiftDown()) {
                // --- Shift-Click Action: Mark ALL as read ---
                Book book = BookRegistry.INSTANCE.books.get(Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_tips_guide_book"));
                if (book != null) {
                    AnnouncementManager.INSTANCE.getAllManifestMessages().forEach(msg -> {
                        // Mark the announcement as seen in my system
                        AnnouncementManager.INSTANCE.markAsSeen(msg.id());

                        // Acknowledge any update-related messages
                        if ("update".equals(msg.kind())) {
                            AnnouncementManager.INSTANCE.setLastAcknowledgedUpdate(msg.semver());
                        }

                        // Find and mark the corresponding virtual entry in Patchouli as read
                        Identifier entryId = Identifier.of(AdorableHamsterPets.MOD_ID, "announcement_" + msg.id());
                        BookEntry entry = book.getContents().entries.get(entryId);
                        if (entry != null) {
                            PatchouliIntegration.setEntryAsRead(entry);
                        }
                    });
                }
            } else {
                // --- Normal Click Action: Mark this one as read ---
                PatchouliIntegration.setEntryAsRead(this.virtualEntry);
                AnnouncementManager.INSTANCE.markAsSeen(announcement.id());
                // Only acknowledge if it's an update-related message
                if ("update".equals(announcement.kind())) {
                    AnnouncementManager.INSTANCE.setLastAcknowledgedUpdate(announcement.semver());
                }
            }
            this.returnToBook();
        }).tooltip(Tooltip.of(markAsReadTooltip)));

        // 2. "Disable These" button (primary row)
        primaryBuilders.add(ButtonWidget.builder(Text.translatable("gui.adorablehamsterpets.announcement.button.disable_icons"), button -> {
            ((ValidatedFieldAccessor<Boolean>) Configs.AHP.enableNotificationIcons).adorablehamsterpets$set(false);
            Configs.AHP.save();
            this.close();
        }).tooltip(Tooltip.of(Text.translatable("gui.adorablehamsterpets.announcement.button.disable_icons.tooltip"))));

        // 3. "Snooze (Days)" button (primary row)
        MutableText remindLaterTooltip = Text.translatable("gui.adorablehamsterpets.announcement.button.snooze_days.tooltip", Configs.AHP.snoozeUpdateReminderDays.get());
        ClientAnnouncementState state = AnnouncementManager.INSTANCE.getClientState();
        Instant snoozeUntil = state.snoozed_ids().get(announcement.id());
        if (snoozeUntil != null && snoozeUntil.isAfter(Instant.now())) {
            Duration remaining = Duration.between(Instant.now(), snoozeUntil);
            remindLaterTooltip.append("\n\n").append(formatDuration(remaining));
        }
        primaryBuilders.add(ButtonWidget.builder(Text.translatable("gui.adorablehamsterpets.announcement.button.snooze_days"), button -> {
            AnnouncementManager.INSTANCE.setSnooze(announcement.id(), Configs.AHP.snoozeUpdateReminderDays.get());
            if (this.parentScreen instanceof TitleScreen) {
                AnnouncementManager.INSTANCE.queueDeferredReadMark(this.virtualEntry.getId());
            } else {
                PatchouliIntegration.setEntryAsRead(this.virtualEntry);
            }
            this.returnToBook();
        }).tooltip(Tooltip.of(remindLaterTooltip)));

        // 4. "Snooze (Session)" button (primary row)
        primaryBuilders.add(ButtonWidget.builder(Text.translatable("gui.adorablehamsterpets.announcement.button.snooze_session"), button -> {
            // Snooze this specific announcement for the current session.
            AnnouncementManager.INSTANCE.snoozeForSession(announcement.id());

            // Mark the entry as read in Patchouli's data.
            if (this.parentScreen instanceof TitleScreen) {
                AnnouncementManager.INSTANCE.queueDeferredReadMark(this.virtualEntry.getId());
            } else {
                PatchouliIntegration.setEntryAsRead(this.virtualEntry);
            }
            this.returnToBook();
        }).tooltip(Tooltip.of(Text.translatable("gui.adorablehamsterpets.announcement.button.snooze_session.tooltip"))));

        // 5. "Changelog" button (secondary row, only if this is an update note)
        if ("update".equals(announcement.kind())) {
            String changelogUrl = String.format("https://modrinth.com/mod/adorable-hamster-pets/version/%s-1.21.1+fabric", announcement.semver());
            secondaryBuilders.add(ButtonWidget.builder(Text.translatable("gui.adorablehamsterpets.announcement.button.changelog"), button -> {
                Util.getOperatingSystem().open(URI.create(changelogUrl));
            }).tooltip(Tooltip.of(Text.translatable("gui.adorablehamsterpets.announcement.button.changelog.tooltip"))));
        }

        // 6. Discord Button (secondary row, always present)
        secondaryBuilders.add(ButtonWidget.builder(Text.translatable("gui.adorablehamsterpets.announcement.button.discord"), button -> {
            Util.getOperatingSystem().open(URI.create("https://discord.gg/w54mk5bqdf"));
        }).tooltip(Tooltip.of(Text.translatable("config.adorablehamsterpets.main.helpAndResources.joinDiscord.desc"))));

        // --- Button Row Layout ---
        int availableWidthButtons = Math.max(0, this.width - 2 * EDGE_MARGIN);

        // Compute starting X positions for each row by centering the row within the available width.
        int primaryCount = primaryBuilders.size();
        int secondaryCount = secondaryBuilders.size();
        int totalPrimaryWidth = primaryCount * buttonWidth + Math.max(0, primaryCount - 1) * buttonPadding;
        int totalSecondaryWidth = secondaryCount * buttonWidth + Math.max(0, secondaryCount - 1) * buttonPadding;
        int startXRow1 = EDGE_MARGIN + (availableWidthButtons - totalPrimaryWidth) / 2;
        int startXRow2 = EDGE_MARGIN + (availableWidthButtons - totalSecondaryWidth) / 2;

        // Compute Y positions for each row.
        int firstRowY = this.guiTop + this.scaledBackgroundHeight + this.scaledButtonPadding;
        int secondRowY = firstRowY + this.scaledButtonHeight + this.scaledButtonPadding;

        // --- Build and Add Buttons ---
        // Add primary row buttons
        for (int i = 0; i < primaryCount; i++) {
            ButtonWidget.Builder builder = primaryBuilders.get(i);
            int currentX = startXRow1 + i * (buttonWidth + buttonPadding);
            ((ScreenWidgetAdder)(Object)this).adorablehamsterpets$addWidget(
                    builder.dimensions(currentX, firstRowY, buttonWidth, this.scaledButtonHeight).build()
            );
        }
        // Add secondary row buttons
        for (int j = 0; j < secondaryCount; j++) {
            ButtonWidget.Builder builder = secondaryBuilders.get(j);
            int currentX = startXRow2 + j * (buttonWidth + buttonPadding);
            ((ScreenWidgetAdder)(Object)this).adorablehamsterpets$addWidget(
                    builder.dimensions(currentX, secondRowY, buttonWidth, this.scaledButtonHeight).build()
            );
        }
    }

    /**
     * Formats a Duration into a human-readable string (e.g., "2 days, 5 hours").
     *
     * @param duration The duration to format.
     * @return A Text component representing the formatted duration.
     */
    private Text formatDuration(Duration duration) {
        long days = duration.toDays();
        long hours = duration.toHoursPart();
        long minutes = duration.toMinutesPart();

        List<String> parts = new ArrayList<>();
        if (days > 0) {
            parts.add(days + (days == 1 ? " day" : " days"));
        }
        if (hours > 0) {
            parts.add(hours + (hours == 1 ? " hour" : " hours"));
        }
        // Only show minutes if the total duration is less than a day for brevity
        if (days == 0 && minutes > 0) {
            parts.add(minutes + (minutes == 1 ? " minute" : " minutes"));
        }

        String formattedString = String.join(", ", parts);
        if (formattedString.isEmpty()) {
            formattedString = "less than a minute";
        }

        return Text.translatable("tooltip.adorablehamsterpets.hud.snooze_remaining", formattedString)
                .formatted(Formatting.GRAY);
    }

    /**
     * Closes this screen and returns to the parent screen (typically the Patchouli book,
     * but not always).If the parent screen is null, it closes the screen, returning to the game.
     */
    private void returnToBook() {
        if (this.client != null) {
            this.client.setScreen(this.parentScreen);
        }
    }

    /**
     * Renders the screen's main content, including the scrollable markdown area and title.
     * It uses a scissor rectangle to confine the markdown rendering to the content area, allowing
     * for proper scrolling and clipping. It also dynamically scales the title text to ensure it
     * fits within the designated header space.
     *
     * @param context The rendering context.
     * @param mouseX  The current X position of the mouse.
     * @param mouseY  The current Y position of the mouse.
     * @param delta   The time elapsed since the last frame.
     */
    @Override
    public void render(DrawContext context, int mouseX, int mouseY, float delta) {
        // --- 1. Update Hovered Style ---
        Text textAtMouse = this.getTextAt(mouseX, mouseY);
        this.hoveredStyle = (textAtMouse != null && textAtMouse.getStyle().getClickEvent() != null) ? textAtMouse.getStyle() : null;

        // Call Render Background first on 1.20.1 (this is not needed on 1.21.1)
        this.renderBackground(context);

        // --- 2. Call super.render() ---
        super.render(context, mouseX, mouseY, delta);

        // --- 3. Render Markdown Content ---
        // Use a scissor to clip the markdown content to the designated scrollable area.
        // Parameters are in window-space coordinates: left, top, right, bottom.
        context.enableScissor(
                this.guiLeft + this.scaledContentXOffset,
                this.guiTop + this.scaledContentYOffset,
                this.guiLeft + this.scaledContentXOffset + this.scaledContentWidth,
                this.guiTop + this.scaledContentYOffset + this.scaledContentHeight
        );
        markdownRenderer.render(context, (int) scrollY, this.hoveredStyle);
        context.disableScissor();

        // --- 4. Render Scrollbar ---
        int maxScroll = Math.max(0, markdownRenderer.getTotalHeight() - this.scaledContentHeight);
        if (maxScroll > 0) {
            int scrollbarX = this.guiLeft + this.scaledScrollBarXOffset;
            int scrollbarTravel = this.scaledScrollBarEndY - this.scaledScrollBarStartY;
            double scrollPercent = this.scrollY / maxScroll;
            int scrollbarY = this.guiTop + this.scaledScrollBarStartY + (int) (scrollPercent * scrollbarTravel);
            // Draw the scrollbar at a fixed size (4x25) regardless of scaling for consistent interaction.
            context.drawTexture(SCROLLBAR_TEXTURE, scrollbarX, scrollbarY, 0, 0, 4, 25, 4, 25);
        }

        // --- 5. Render Dynamic Title ---
        MatrixStack matrices = context.getMatrices();
        matrices.push();
        float defaultScale = 1.3f * this.uiScale; // Scale title proportionally with the UI.
        int maxWidth = Math.round(222 * this.uiScale); // Scale the maximum width of the title proportionally with the UI.
        Text boldTitle = this.title.copy().formatted(Formatting.BOLD);
        int titleWidth = MinecraftClient.getInstance().textRenderer.getWidth(boldTitle);
        float finalScale = defaultScale;


        if (titleWidth * defaultScale > maxWidth) {
            finalScale = (float) maxWidth / titleWidth; // Shrink to fit if oversized.
        }

        // Translate down from the top of the GUI by 9 scaled pixels so the title sits within the header.
        matrices.translate(this.width / 2.0, this.guiTop + Math.round(9 * this.uiScale), 0);
        matrices.scale(finalScale, finalScale, 1.0f);
        context.drawText(MinecraftClient.getInstance().textRenderer, boldTitle, -titleWidth / 2, 0, 0x323232, false);
        matrices.pop();
    }

    /**
     * Renders the screen's background. This method first draws the default dark overlay, then
     * renders the custom background texture using a matrix transformation.
     * <p>
     * The matrix scaling is crucial: instead of giving {@code drawTexture} scaled region dimensions
     * (which crops the right and bottom edges), we scale the matrix itself and draw the *entire*
     * 256x256 texture. This ensures the full texture is scaled down correctly.
     *
     * @param context The rendering context.
     */
    @Override
    public void renderBackground(DrawContext context) {
        super.renderBackground(context);

        // --- Render Custom Background Texture ---
        // Draw the entire texture and scale it via the matrix, not by region size, to avoid cropping.
        context.getMatrices().push();
        context.getMatrices().translate((float) this.guiLeft, (float) this.guiTop, 0.0F);
        context.getMatrices().scale(this.uiScale, this.uiScale, 1.0F);
        context.drawTexture(
                BACKGROUND_TEXTURE,
                0, 0, 0, 0,
                BACKGROUND_WIDTH, BACKGROUND_HEIGHT,
                BACKGROUND_WIDTH, BACKGROUND_HEIGHT
        );
        context.getMatrices().pop();
    }

    /**
     * Handles key presses. Closes the screen if the inventory key is pressed.
     *
     * @param keyCode The key code of the key that was pressed.
     * @param scanCode The scan code of the key that was pressed.
     * @param modifiers Any modifier keys that were held down.
     * @return {@code true} if the event was handled, {@code false} otherwise.
     */
    @Override
    public boolean keyPressed(int keyCode, int scanCode, int modifiers) {
        // Check if the inventory key was pressed
        if (this.client != null && this.client.options.inventoryKey.matchesKey(keyCode, scanCode)) {
            this.close(); // Close the screen
            return true;  // Mark the event as handled
        }
        // For any other key, use the default behavior (e.g., ESC key)
        return super.keyPressed(keyCode, scanCode, modifiers);
    }

    /**
     * Handles mouse scrolling to adjust the vertical position of the markdown content.
     * The scroll amount is clamped between 0 and the maximum scrollable height. The scroll speed
     * is scaled by {@code uiScale} to feel consistent at different UI sizes.
     *
     * @return {@code true} to indicate the event was handled.
     */
    @Override
    public boolean mouseScrolled(double mouseX, double mouseY, double amount) {
        int maxScroll = Math.max(0, markdownRenderer.getTotalHeight() - this.scaledContentHeight);
        double scrollStep = 10 * this.uiScale; // Scale scroll speed with UI size.
        this.scrollY = MathHelper.clamp(this.scrollY - amount * scrollStep, 0, maxScroll);
        return true;
    }

    @Override
    public boolean mouseClicked(double mouseX, double mouseY, int button) {
        if (button == 0) {
            // --- 1. Check for Scrollbar Drag ---
            int maxScroll = Math.max(0, markdownRenderer.getTotalHeight() - this.scaledContentHeight);
            if (maxScroll > 0) {
                int scrollbarX = this.guiLeft + this.scaledScrollBarXOffset;
                int scrollbarTravel = this.scaledScrollBarEndY - this.scaledScrollBarStartY;
                double scrollPercent = this.scrollY / maxScroll;
                int scrollbarY = this.guiTop + this.scaledScrollBarStartY + (int) (scrollPercent * scrollbarTravel);

                // Check if the click is within the scrollbar handle's bounds
                if (mouseX >= scrollbarX && mouseX < scrollbarX + 4 && mouseY >= scrollbarY && mouseY < scrollbarY + 25) {
                    this.isDraggingScrollbar = true;
                    return true; // Consume the click
                }
            }

            // --- 2. Check for Text Link Click ---
            Text clickedText = this.getTextAt(mouseX, mouseY);
            if (clickedText != null) {
                Style style = clickedText.getStyle();
                if (this.handleTextClick(style)) {
                    return true;
                }
            }
        }
        return super.mouseClicked(mouseX, mouseY, button);
    }

    @Override
    public boolean mouseDragged(double mouseX, double mouseY, int button, double deltaX, double deltaY) {
        if (this.isDraggingScrollbar) {
            int maxScroll = Math.max(0, markdownRenderer.getTotalHeight() - this.scaledContentHeight);
            int scrollbarTravel = this.scaledScrollBarEndY - this.scaledScrollBarStartY;

            // Calculate the scroll percentage based on the mouse's position relative to the scrollbar track
            double relativeMouseY = mouseY - (this.guiTop + this.scaledScrollBarStartY);
            double scrollPercent = relativeMouseY / scrollbarTravel;

            // Set the new scrollY value and clamp it
            this.scrollY = MathHelper.clamp(scrollPercent * maxScroll, 0, maxScroll);

            return true; // Consume the drag event
        }
        return super.mouseDragged(mouseX, mouseY, button, deltaX, deltaY);
    }

    @Override
    public boolean mouseReleased(double mouseX, double mouseY, int button) {
        if (button == 0) {
            this.isDraggingScrollbar = false;
        }
        return super.mouseReleased(mouseX, mouseY, button);
    }

    @Override
    public boolean shouldPause() {
        return true;
    }

    @Override
    public void close() {
        this.returnToBook();
    }

    /**
     * Performs a hit-test to find the clickable {@link Text} component at the given mouse coordinates.
     * This method accounts for the current scroll position and iterates through the pre-wrapped lines
     * of markdown content, checking the vertical and horizontal bounds of each line block to find a
     * match.
     *
     * @param x The mouse's X coordinate.
     * @param y The mouse's Y coordinate.
     * @return The {@link Text} with a clickable style at the given position, or {@code null} if none is found.
     */
    @Nullable
    public Text getTextAt(double x, double y) {
        // --- 1. Calculate Mouse Position Relative to Scrollable Content ---
        int scrollOffset = (int) (this.guiTop + this.scaledContentYOffset - this.scrollY);
        int relativeY = (int) y - scrollOffset;

        if (relativeY < 0) {
            return null; // Mouse is above the content area
        }

        int currentY = 0;
        for (String originalLine : markdownRenderer.lines) {
            String trimmedLine = originalLine.trim();
            int lineHeight;
            int startX = this.guiLeft + this.scaledContentXOffset;
            int contentWidth = markdownRenderer.width;
            String content = trimmedLine;
            boolean isListItem = trimmedLine.startsWith("- ") || trimmedLine.startsWith("* ") || trimmedLine.matches("^\\d+\\.\\s.*");

            // --- 2. Calculate the Height of the Current Line Block ---
            if (trimmedLine.isEmpty()) {
                lineHeight = textRenderer.fontHeight / 2;
            } else if (trimmedLine.startsWith("#")) {
                int level = 0;
                while (level < trimmedLine.length() && trimmedLine.charAt(level) == '#') level++;
                String text = trimmedLine.substring(level).trim();
                float scale = Math.max(1.0f, 2.0f - (level - 1) * 0.25f);
                int scaledWidth = (int) (markdownRenderer.width / scale);
                MutableText styledText = Text.literal(text).setStyle(Style.EMPTY.withBold(true));
                List<OrderedText> wrappedLines = MinecraftClient.getInstance().textRenderer.wrapLines(styledText, scaledWidth);
                int heightOfLines = wrappedLines.size() * (int) (textRenderer.fontHeight * scale);
                int totalSpacing = Math.max(0, wrappedLines.size() - 1) * MarkdownRenderer.LINE_SPACING;
                lineHeight = heightOfLines + totalSpacing + MarkdownRenderer.HEADING_BOTTOM_MARGIN;
            } else if (trimmedLine.equals("---")) {
                lineHeight = MarkdownRenderer.DIVIDER_HEIGHT;
            } else {
                int indentationLevel = MarkdownRenderer.getIndentationLevel(originalLine);
                if (isListItem) {
                    contentWidth = markdownRenderer.width - ((indentationLevel + 1) * MarkdownRenderer.LIST_INDENT);
                    startX += (indentationLevel * MarkdownRenderer.LIST_INDENT) + MarkdownRenderer.LIST_INDENT;
                    if (trimmedLine.matches("^\\d+\\.\\s.*")) {
                        content = trimmedLine.substring(trimmedLine.indexOf('.') + 1).trim();
                    } else {
                        content = trimmedLine.substring(1).trim();
                    }
                } else {
                    contentWidth = markdownRenderer.width - (indentationLevel * MarkdownRenderer.LIST_INDENT);
                    startX += indentationLevel * MarkdownRenderer.LIST_INDENT;
                    content = originalLine.substring(indentationLevel * MarkdownRenderer.SPACES_PER_INDENT_LEVEL);
                }
                MutableText styledText = markdownRenderer.parseLineToText(content, null);
                List<OrderedText> wrappedLines = textRenderer.wrapLines(styledText, contentWidth);
                lineHeight = wrappedLines.size() * (textRenderer.fontHeight + MarkdownRenderer.LINE_SPACING);
            }

            // --- 3. Check if Mouse is Within This Line Block's Vertical Bounds ---
            if (relativeY >= currentY && relativeY < currentY + lineHeight) {
                // --- 4. Find the Specific Style (for paragraphs and list items) ---
                if (!trimmedLine.isEmpty() && !trimmedLine.startsWith("#") && !trimmedLine.equals("---")) {
                    // Re-calculate contentWidth and startX for this specific block type to pass to the text handler
                    int indentationLevel = MarkdownRenderer.getIndentationLevel(originalLine);
                    if (isListItem) {
                        contentWidth = markdownRenderer.width - ((indentationLevel + 1) * MarkdownRenderer.LIST_INDENT);
                    } else {
                        contentWidth = markdownRenderer.width - (indentationLevel * MarkdownRenderer.LIST_INDENT);
                    }

                    MutableText styledText = markdownRenderer.parseLineToText(content, null);
                    List<OrderedText> wrappedLines = textRenderer.wrapLines(styledText, contentWidth);
                    int yInBlock = relativeY - currentY;
                    int lineIndex = yInBlock / (textRenderer.fontHeight + MarkdownRenderer.LINE_SPACING);

                    if (lineIndex >= 0 && lineIndex < wrappedLines.size()) {
                        OrderedText orderedText = wrappedLines.get(lineIndex);
                        int relativeX = (int) x - startX;
                        Style style = this.client.textRenderer.getTextHandler().getStyleAt(orderedText, relativeX);
                        if (style != null && style.getClickEvent() != null) {
                            return Text.literal("").setStyle(style);
                        }
                    }
                }
                return null; // Inside the block's height, but not on a clickable element
            }

            // --- 5. Move to the Next Line Block ---
            currentY += lineHeight;
        }
        return null;
    }
}
```

`MarkdownRenderer.java`
```java
package net.dawson.adorablehamsterpets.client.gui;

// (Imports omitted to save token count)

public class MarkdownRenderer {
    // --- 1. Constants and Patterns ---
    private static final Pattern BOLD_PATTERN = Pattern.compile("\\*\\*(.*?)\\*\\*");
    private static final Pattern ITALIC_PATTERN = Pattern.compile("\\*(.*?)\\*");
    private static final Pattern CODE_PATTERN = Pattern.compile("`(.*?)`");
    private static final Pattern LINK_PATTERN = Pattern.compile("\\[(.*?)]\\((.*?)\\)");
    public static final int LINE_SPACING = 2;
    public static final int HEADING_BOTTOM_MARGIN = 4;
    public static final int DIVIDER_HEIGHT = 13;
    public static final int LIST_INDENT = 10;
    public static final int SPACES_PER_INDENT_LEVEL = 4;

    // --- 2. Fields ---
    private final TextRenderer textRenderer;
    public final List<String> lines;
    private final int x;
    private final int startY;
    public final int width;
    private int totalHeight = 0;

    // --- 3. Constructor ---
    public MarkdownRenderer(String markdownContent, int x, int startY, int width) {
        this.textRenderer = MinecraftClient.getInstance().textRenderer;
        this.lines = markdownContent == null ? List.of() : List.of(markdownContent.split("\n"));
        this.x = x;
        this.startY = startY;
        this.width = width;
        // Pass the content width to the height calculation
        this.calculateHeight(width);
    }

    // --- 4. Public Methods ---
    public void render(DrawContext context, int scrollY, @Nullable Style hoveredStyle) {
        int currentY = startY - scrollY;

        for (String originalLine : lines) {
            String trimmedLine = originalLine.trim();
            if (trimmedLine.isEmpty()) {
                currentY += textRenderer.fontHeight / 2;
                continue;
            }

            if (trimmedLine.startsWith("#")) {
                currentY = renderHeading(context, trimmedLine, currentY);
            } else if (trimmedLine.equals("---")) {
                currentY = renderDivider(context, currentY);
            } else if (trimmedLine.startsWith("- ") || trimmedLine.startsWith("* ") || (trimmedLine.matches("^\\d+\\.\\s.*"))) {
                currentY = renderListItem(context, originalLine, currentY, hoveredStyle);
            } else {
                currentY = renderParagraph(context, trimmedLine, currentY, x, width, hoveredStyle);
            }
        }
    }

    public int getTotalHeight() {
        return totalHeight;
    }

    // --- 5. Public Static Helpers ---
    public static int getIndentationLevel(String line) {
        int spaces = 0;
        for (char c : line.toCharArray()) {
            if (c == ' ') {
                spaces++;
            } else {
                break;
            }
        }
        return spaces / SPACES_PER_INDENT_LEVEL;
    }

    // --- 6. Private Rendering Helpers ---
    private int renderHeading(DrawContext context, String line, int y) {
        int level = 0;
        while (level < line.length() && line.charAt(level) == '#') {
            level++;
        }
        String text = line.substring(level).trim();
        float scale = Math.max(1.0f, 2.0f - (level - 1) * 0.25f);
        int color = 0x323232;

        // Create a styled, bold text object for the heading
        MutableText styledText = Text.literal(text).setStyle(Style.EMPTY.withBold(true));

        // The available width for the text must be scaled down to account for the scaled-up rendering
        int scaledWidth = (int) (this.width / scale);
        List<OrderedText> wrappedLines = this.textRenderer.wrapLines(styledText, scaledWidth);

        MatrixStack matrices = context.getMatrices();
        for (OrderedText wrappedLine : wrappedLines) {
            matrices.push();
            matrices.translate(x, y, 0);
            matrices.scale(scale, scale, 1.0f);
            context.drawText(textRenderer, wrappedLine, 0, 0, color, false);
            matrices.pop();
            y += (int)(textRenderer.fontHeight * scale) + LINE_SPACING;
        }

        // Adjust Y position: remove the last line's spacing and add the final margin
        return y - LINE_SPACING + HEADING_BOTTOM_MARGIN;
    }

    private int renderDivider(DrawContext context, int y) {
        // Draw the divider 3 pixels down from the start, leaving 3px padding above.
        context.fill(x + 15, y + 3, x + width - 15, y + 4, 0xFFB3B3B3); // First two digits control the alpha.
        return y + DIVIDER_HEIGHT;
    }

    private int renderListItem(DrawContext context, String line, int y, @Nullable Style hoveredStyle) {
        int indentationLevel = getIndentationLevel(line);
        String trimmedLine = line.trim();

        String bullet;
        String content;

        if (trimmedLine.matches("^\\d+\\.\\s.*")) {
            int dotIndex = trimmedLine.indexOf('.');
            bullet = trimmedLine.substring(0, dotIndex + 1);
            content = trimmedLine.substring(dotIndex + 1).trim();
        } else {
            bullet = "•";
            content = trimmedLine.substring(1).trim();
        }

        int bulletX = x + (indentationLevel * LIST_INDENT);
        int contentX = bulletX + LIST_INDENT;
        int contentWidth = width - ((indentationLevel + 1) * LIST_INDENT);

        context.drawText(textRenderer, bullet, bulletX, y, 0x323232, false);
        return renderParagraph(context, content, y, contentX, contentWidth, hoveredStyle);
    }

    private int renderParagraph(DrawContext context, String line, int y, int startX, int lineWidth, @Nullable Style hoveredStyle) {
        int indentationLevel = getIndentationLevel(line);
        String content = line.substring(indentationLevel * SPACES_PER_INDENT_LEVEL);
        int finalStartX = startX + (indentationLevel * LIST_INDENT);
        int finalLineWidth = lineWidth - (indentationLevel * LIST_INDENT);

        MutableText styledText = parseLineToText(content, hoveredStyle);
        List<OrderedText> wrappedLines = textRenderer.wrapLines(styledText, finalLineWidth);

        for (OrderedText wrappedLine : wrappedLines) {
            context.drawText(textRenderer, wrappedLine, finalStartX, y, 0x323232, false);
            y += textRenderer.fontHeight + LINE_SPACING;
        }
        return y;
    }

    // --- 7. Parsing Logic ---
    public MutableText parseLineToText(String line, @Nullable Style hoveredStyle) {
        MutableText result = Text.empty();
        String remaining = line;

        while (!remaining.isEmpty()) {
            Matcher boldMatcher = BOLD_PATTERN.matcher(remaining);
            Matcher italicMatcher = ITALIC_PATTERN.matcher(remaining);
            Matcher codeMatcher = CODE_PATTERN.matcher(remaining);
            Matcher linkMatcher = LINK_PATTERN.matcher(remaining);

            int nextMatchPos = Integer.MAX_VALUE;
            Matcher nextMatcher = null;

            if (boldMatcher.find(0) && boldMatcher.start() < nextMatchPos) { nextMatchPos = boldMatcher.start(); nextMatcher = boldMatcher; }
            if (italicMatcher.find(0) && italicMatcher.start() < nextMatchPos) { nextMatchPos = italicMatcher.start(); nextMatcher = italicMatcher; }
            if (codeMatcher.find(0) && codeMatcher.start() < nextMatchPos) { nextMatchPos = codeMatcher.start(); nextMatcher = codeMatcher; }
            if (linkMatcher.find(0) && linkMatcher.start() < nextMatchPos) { nextMatchPos = linkMatcher.start(); nextMatcher = linkMatcher; }

            if (nextMatcher != null) {
                if (nextMatchPos > 0) {
                    result.append(Text.literal(remaining.substring(0, nextMatchPos)));
                }

                if (nextMatcher == boldMatcher) {
                    result.append(Text.literal(boldMatcher.group(1)).setStyle(Style.EMPTY.withBold(true)));
                } else if (nextMatcher == italicMatcher) {
                    result.append(Text.literal(italicMatcher.group(1)).setStyle(Style.EMPTY.withItalic(true)));
                } else if (nextMatcher == codeMatcher) {
                    result.append(Text.literal(codeMatcher.group(1)).setStyle(Style.EMPTY.withFont(Identifier.of("minecraft", "uniform")).withColor(Formatting.BLACK)));
                } else if (nextMatcher == linkMatcher) {
                    String linkText = linkMatcher.group(1);
                    String url = linkMatcher.group(2);
                    ClickEvent clickEvent;

                    if (url.startsWith("ahp://copy ")) {
                        String command = url.substring("ahp://copy ".length());
                        clickEvent = new ClickEvent(ClickEvent.Action.COPY_TO_CLIPBOARD, command);
                    } else {
                        // Default to OPEN_URL for https or any other scheme
                        clickEvent = new ClickEvent(ClickEvent.Action.OPEN_URL, url);
                    }

                    // Hover logic
                    Style linkStyle = Style.EMPTY.withColor(Formatting.AQUA).withUnderline(true).withBold(true).withClickEvent(clickEvent);
                    if (hoveredStyle != null && hoveredStyle.getClickEvent() != null && hoveredStyle.getClickEvent().equals(clickEvent)) {
                        // Hover style: Gold, with no underline.
                        linkStyle = linkStyle.withColor(Formatting.GOLD).withUnderline(false).withBold(true);
                    }
                    result.append(Text.literal(linkText).setStyle(linkStyle));
                }
                remaining = remaining.substring(nextMatcher.end());
            } else {
                result.append(Text.literal(remaining));
                break;
            }
        }
        return result;
    }

    private void calculateHeight(int lineWidth) {
        int currentY = 0;
        for (String line : lines) {
            String trimmedLine = line.trim(); // Trim first to identify element type
            if (trimmedLine.isEmpty()) {
                currentY += textRenderer.fontHeight / 2;
                continue;
            }

            if (trimmedLine.startsWith("#")) {
                int level = 0;
                while (level < trimmedLine.length() && trimmedLine.charAt(level) == '#') level++;
                String text = trimmedLine.substring(level).trim();
                float scale = Math.max(1.0f, 2.0f - (level - 1) * 0.25f);

                int scaledWidth = (int) (lineWidth / scale);
                MutableText styledText = Text.literal(text).setStyle(Style.EMPTY.withBold(true));
                int wrappedLinesCount = this.textRenderer.wrapLines(styledText, scaledWidth).size();

                int heightOfLines = wrappedLinesCount * (int)(textRenderer.fontHeight * scale);
                int totalSpacing = Math.max(0, wrappedLinesCount - 1) * LINE_SPACING;
                currentY += heightOfLines + totalSpacing + HEADING_BOTTOM_MARGIN;
            } else if (trimmedLine.equals("---")) {
                currentY += DIVIDER_HEIGHT;
            } else {
                int indentationLevel = getIndentationLevel(line); // Use original line for indent
                String content = trimmedLine;
                int contentWidth;

                // Check if it's a list item and adjust content/width accordingly.
                if (content.startsWith("- ") || content.startsWith("* ") || content.matches("^\\d+\\.\\s.*")) {
                    contentWidth = lineWidth - ((indentationLevel + 1) * LIST_INDENT);
                    if (content.matches("^\\d+\\.\\s.*")) {
                        content = content.substring(content.indexOf('.') + 1).trim();
                    } else {
                        // Handles both "- " and "* "
                        content = content.substring(1).trim();
                    }
                } else {
                    // It's a paragraph, adjust width for its indentation level.
                    contentWidth = lineWidth - (indentationLevel * LIST_INDENT);
                }

                MutableText styledText = parseLineToText(content, null);
                int wrappedLinesCount = textRenderer.wrapLines(styledText, contentWidth).size();
                currentY += wrappedLinesCount * (textRenderer.fontHeight + LINE_SPACING);
            }
        }
        this.totalHeight = currentY;
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/client/gui/widgets/`
`AnnouncementIconAnimator.java`
```java
package net.dawson.adorablehamsterpets.client.gui.widgets;

// (Imports omitted to save token count)

/**
 * A client-side singleton that manages the animation state for the announcement icon.
 * This centralizes all interpolation and state logic for scale, rotation, and position,
 * ensuring consistent animations whether the icon is rendered on the HUD or as a screen widget.
 */
public class AnnouncementIconAnimator {

    public static final AnnouncementIconAnimator INSTANCE = new AnnouncementIconAnimator();

    // --- Animation Constants ---
    private static final float HOVER_SCALE = 1.3f;
    private static final float CLICK_SCALE = 0.9f;
    private static final float IDLE_SCALE = 1.0f;
    private static final int WIGGLE_INTERVAL_TICKS = 80;
    private static final int WIGGLE_DURATION_TICKS = 5;
    private static final float WIGGLE_MAX_ANGLE_DEGREES = 50.0f;
    private static final int CLICK_ANIMATION_DURATION_TICKS = 2;

    // --- Main Physics Constants ---
    private static final double STIFFNESS = 3.0;               // Spring stiffness; higher = faster snap to target
    private static final double DAMPING = 4.5;                 // Damping; higher = less bounce/overshoot
    private static final double MASS = 7.0;                    // Effective mass; resists acceleration
    private static final float ROTATION_KICK_INTENSITY = 0.2f; // Extra rotational impulse on move

    // --- Settle-Wobble Physics Constants ---
    private static final int WOBBLE_DURATION_TICKS = 30;                // Cosmetic wobble length (ticks)
    private static final float WOBBLE_DECAY_POWER = 2.7f;               // >2.0 decays faster; 1.0 = linear
    private static final float WOBBLE_OSCILLATIONS = 12.0f;             // Total oscillations during the wobble window
    private static final float WOBBLE_BASE_VEL_MULTIPLIER = 50.0f;      // Big constant; we clamp after this
    private static final float WOBBLE_MAX_ICON_FRACTION   = 0.35f;      // Max wobble = 35% of icon's rendered size
    private static final float WOBBLE_MIN_ICON_FRACTION   = 0.08f;      // Floor = 8% of icon size for tiny moves


    // --- State Fields ---
    private double currentX, currentY, currentScale = 1.0, currentAngle = 0.0; // Current state (per tick)
    private double prevX, prevY, prevScale = 1.0, prevAngle = 0.0;             // Previous state (for lerp)
    private double velocityX, velocityY, scaleVelocity, angularVelocity = 0.0; // State velocities
    // Cached UI metric for resolution-independent wobble clamping
    private float iconPixelSize = 16f;     // 16 * hud scale; updated in updateTargetPosition(...)

    // --- Scale State Fields ---
    private double targetX, targetY;
    private float targetScale = 1.0f;
    private float targetAngle = 0.0f;

    private float wiggleAngle = 0.0f;
    private int wiggleTimer = 0;
    private int clickAnimationTicks = 0;

    private int settleWobbleTicks = 0;
    private double wobbleAngle = 0;     // The direction of the wobble in radians
    private double wobbleMagnitude = 0; // The current distance of the wobble from the center
    private double lastVelocityX = 0;   // Velocity from the previous tick
    private double lastVelocityY = 0;   // Velocity from the previous tick

    /**
     * Stores the partial tick value from the last render frame. This is used to
     * compute the time delta between frames and advance the physics simulation
     * proportionally. On every new tick, this value is reset to 0. See
     * {@link #updatePhysicsForRender(float)}.
     */
    private float lastRenderDelta = 0.0f;

    /**
     * Advances the physics simulation by a fractional number of ticks. This allows
     * the spring-damper system to update on every render frame rather than only
     * once per game tick. The existing constants (stiffness, damping, mass)
     * assume a fixed-time step of one tick; by scaling the acceleration and
     * velocity updates by {@code delta}, the animator can smoothly animate
     * between ticks without noticeable jumps. This method should be called once
     * per render with the current tick delta. The method will internally
     * determine how much time has elapsed since the previous render call and
     * integrate the physics accordingly.
     *
     * @param tickDelta The current partial tick value passed to the render method. A value
     *                  between 0.0 and 1.0 indicating how far we are into the current
     *                  game tick.
     */
    public void updatePhysicsForRender(float tickDelta) {
        // Compute how much time (in ticks) has passed since the last render.
        // If the delta decreases, a new tick has started, so use the full delta.
        float deltaTicks = tickDelta - this.lastRenderDelta;
        if (deltaTicks < 0.0f) deltaTicks = tickDelta;
        this.lastRenderDelta = tickDelta;
        if (deltaTicks <= 0.0f) return;

        // Advance each physics property using the scaled time step. Perform Euler integration scaled by the fractional
        // tick value to approximate continuous motion. Updating in this manner between ticks prevents the icon from
        // appearing choppy on high-refresh-rate displays or while certain GUI screens are open.
        // --- Capture pre-step state for overshoot detection ---
        final double errX_before = this.currentX - this.targetX;
        final double errY_before = this.currentY - this.targetY;
        final double velX_before = this.velocityX;
        final double velY_before = this.velocityY;

        // --- Advance physics ---
        updatePhysicsPropertyTimed(this.currentX, this.velocityX, this.targetX, deltaTicks, (val, vel) -> { this.currentX = val; this.velocityX = vel; });
        updatePhysicsPropertyTimed(this.currentY, this.velocityY, this.targetY, deltaTicks, (val, vel) -> { this.currentY = val; this.velocityY = vel; });
        updatePhysicsPropertyTimed(this.currentScale, this.scaleVelocity, this.targetScale, deltaTicks, (val, vel) -> { this.currentScale = val; this.scaleVelocity = vel; });
        updatePhysicsPropertyTimed(this.currentAngle, this.angularVelocity, this.targetAngle, deltaTicks, (val, vel) -> { this.currentAngle = val; this.angularVelocity = vel; });

        // Also update the lastVelocity fields so the settle wobble logic continues to observe the most recent motion.
        // These velocities are captured immediately prior to each tick's physics step in tick(boolean),
        // but need to update them here as well so the wobble triggers based on the continuous motion.
        this.lastVelocityX = this.velocityX;
        this.lastVelocityY = this.velocityY;

        // --- Overshoot-triggered wobble ---
        if (this.settleWobbleTicks == 0) {
            final double errX_after = this.currentX - this.targetX;
            final double errY_after = this.currentY - this.targetY;

            // True if crossed the target on either axis in this frame
            boolean crossedX = (errX_before == 0.0) ? false : (errX_before * errX_after < 0.0);
            boolean crossedY = (errY_before == 0.0) ? false : (errY_before * errY_after < 0.0);
            boolean crossed   = crossedX || crossedY;

            double speed_before = Math.sqrt(velX_before * velX_before + velY_before * velY_before);

            if (crossed) {
                this.settleWobbleTicks = WOBBLE_DURATION_TICKS;
                // Kick opposite the incoming velocity to simulate bounce
                this.wobbleAngle = Math.atan2(-velY_before, -velX_before);
                // Compute a big “raw” kick from speed, then clamp in icon-relative units
                float rawKick = (float)(speed_before * WOBBLE_BASE_VEL_MULTIPLIER);

                // Clamp to [min, max] fractions of the icon's rendered size
                float maxPx = WOBBLE_MAX_ICON_FRACTION * this.iconPixelSize;
                float minPx = WOBBLE_MIN_ICON_FRACTION * this.iconPixelSize;

                this.wobbleMagnitude = Math.max(minPx, Math.min(rawKick, maxPx));
            }
        }
    }

    /**
     * Performs a physics step scaled by {@code delta}. This is analogous to
     * {@link #updatePhysicsProperty(double, double, double, PropertyUpdater)} but
     * multiplies the acceleration, velocity and position updates by the given
     * fractional tick value. Using this helper allows the same spring and
     * damping constants to be reused for both full-tick and partial-tick
     * integration.
     *
     * @param current  The current value of the property (e.g., position or scale).
     * @param velocity The current velocity of the property.
     * @param target   The target value the property is moving towards.
     * @param delta    The fraction of a tick to simulate. A value of 1.0
     *                 corresponds to a full tick, while values less than 1.0
     *                 represent partial ticks.
     * @param updater  A lambda function that updates the calling fields with the new
     *                 value and velocity.
     */
    private void updatePhysicsPropertyTimed(double current, double velocity, double target, double delta, PropertyUpdater updater) {
        // F_spring = -k * x (Hooke's Law)
        double springForce = -STIFFNESS * (current - target);
        // F_damping = -c * v
        double dampingForce = -DAMPING * velocity;
        // a = F / m (Newton's Second Law)
        double acceleration = (springForce + dampingForce) / MASS;
        // Euler integration with scaled time step
        double newVelocity = velocity + acceleration * delta;
        double newValue = current + newVelocity * delta;
        updater.update(newValue, newVelocity);
    }

    private AnnouncementIconAnimator() {}

    /**
     * Calculates and sets the animator's target X and Y coordinates based on the current
     * screen dimensions and the user's HUD configuration settings. This centralized method
     * is used by both the in-game HUD renderer and the Title Screen widget to ensure
     * consistent positioning.
     *
     * @param screenWidth  The current width of the screen.
     * @param screenHeight The current height of the screen.
     */
    public void updateTargetPosition(int screenWidth, int screenHeight) {
        final AhpConfig config = Configs.AHP;
        IconPositionPreset preset = config.hudIconPositionPreset.get();
        double scale = config.hudIconScale.get();
        int iconWidth = 16;
        int iconHeight = 16;

        // Cache for wobble clamping
        this.iconPixelSize = (float) (Math.max(iconWidth, iconHeight) * scale);

        double newTargetX = switch (preset) {
            case TOP_LEFT, BOTTOM_LEFT -> (double) config.hudIconOffsetX.get();
            case TOP_RIGHT, BOTTOM_RIGHT -> screenWidth - (iconWidth * scale) - config.hudIconOffsetX.get();
        };

        double newTargetY = switch (preset) {
            case TOP_LEFT, TOP_RIGHT -> (double) config.hudIconOffsetY.get();
            case BOTTOM_LEFT, BOTTOM_RIGHT -> screenHeight - (iconHeight * scale) - config.hudIconOffsetY.get();
        };

        // Only start a new physics transition if the target has actually changed.
        if (newTargetX != this.targetX || newTargetY != this.targetY) {
            startTransition(newTargetX, newTargetY);
        }
    }

    /**
     * Updates the physics simulation and discrete animation states. Should be called once per client tick.
     * All visual smoothing is handled in the getRender...() methods.
     * @param isGuiOpen True if any GUI screen is currently open.
     */
    public void tick(boolean isGuiOpen) {
        // --- 1. Store previous state for interpolation ---
        this.prevX = this.currentX;
        this.prevY = this.currentY;
        this.prevScale = this.currentScale;
        this.prevAngle = this.currentAngle;

        // Reset the last render delta so that the first render call of the new tick
        // treats its delta as absolute rather than a difference from the previous frame.
        this.lastRenderDelta = 0.0f;

        // --- 2. Update discrete timers ---
        if (clickAnimationTicks > 0) {
            clickAnimationTicks--;
            targetScale = CLICK_SCALE; // Force target scale during click
        }

        wiggleTimer++;
        if (wiggleTimer > WIGGLE_INTERVAL_TICKS + WIGGLE_DURATION_TICKS) {
            wiggleTimer = 0;
        }

        // --- 3. Settle Wobble Logic ---
        if (settleWobbleTicks > 0) {
            settleWobbleTicks--;
        }

        // --- 4. Calculate Dynamic Targets ---
        // The target angle is dynamically driven by the icon's horizontal velocity.
        // This creates the rotational "wobble" as it moves and settles.
        this.targetAngle = (float) (this.velocityX * ROTATION_KICK_INTENSITY);

        // --- 5. Store final velocity BEFORE running the new physics step ---
        this.lastVelocityX = this.velocityX;
        this.lastVelocityY = this.velocityY;

        // --- 6. Run the physics simulation for a full tick ---
        // Instead of calling updatePhysicsProperty directly for each property (which
        // assumes a fixed time step), delegate to the timed integration helper with
        // delta = 1.0f. This allows the same spring-damper constants to be reused
        // when the simulation is advanced at fractional tick intervals during
        // rendering. See updatePhysicsForRender for the partial updates.
        updatePhysicsPropertyTimed(this.currentX, this.velocityX, this.targetX, 1.0f, (val, vel) -> { this.currentX = val; this.velocityX = vel; });
        updatePhysicsPropertyTimed(this.currentY, this.velocityY, this.targetY, 1.0f, (val, vel) -> { this.currentY = val; this.velocityY = vel; });
        updatePhysicsPropertyTimed(this.currentScale, this.scaleVelocity, this.targetScale, 1.0f, (val, vel) -> { this.currentScale = val; this.scaleVelocity = vel; });
        updatePhysicsPropertyTimed(this.currentAngle, this.angularVelocity, this.targetAngle, 1.0f, (val, vel) -> { this.currentAngle = val; this.angularVelocity = vel; });
    }

    // --- Public Methods to Control State ---

    public void startTransition(double newTargetX, double newTargetY) {
        this.targetX = newTargetX;
        this.targetY = newTargetY;
    }

    public void triggerClickAnimation() {
        this.clickAnimationTicks = CLICK_ANIMATION_DURATION_TICKS;
        this.targetScale = CLICK_SCALE;
    }

    public void setHovered(boolean hovered) {
        // Do not change the target scale if a click animation is active
        if (clickAnimationTicks == 0) {
            this.targetScale = hovered ? HOVER_SCALE : IDLE_SCALE;
        }
    }

    public double getTargetX() {
        return this.targetX;
    }

    public double getTargetY() {
        return this.targetY;
    }

    /**
     * A functional interface to update a property's value and velocity.
     */
    @FunctionalInterface
    private interface PropertyUpdater {
        void update(double value, double velocity);
    }

    /**
     * Calculates the next state of a physical property using a spring-damper model.
     * @param current The current value of the property (e.g., position, scale).
     * @param velocity The current velocity of the property.
     * @param target The target value the property is moving towards.
     * @param updater A lambda function to update the original fields with the new values.
     */
    private void updatePhysicsProperty(double current, double velocity, double target, PropertyUpdater updater) {
        // F_spring = -k * x (Hooke's Law)
        double springForce = -STIFFNESS * (current - target);
        // F_damping = -c * v
        double dampingForce = -DAMPING * velocity;

        // a = F / m (Newton's Second Law)
        double acceleration = (springForce + dampingForce) / MASS;

        // Update velocity and position
        double newVelocity = velocity + acceleration;
        double newValue = current + newVelocity;

        updater.update(newValue, newVelocity);
    }

    /**
     * Instantly updates the icon's target and current position. Used by the HUD renderer
     * when no GUI is open to keep the icon locked to its calculated corner position and
     * prime it for a smooth transition when a GUI opens.
     *
     * @param x The target X position.
     * @param y The target Y position.
     */
    public void updateHudPosition(double x, double y) {
        // Set the target for the physics simulation.
        this.targetX = x;
        this.targetY = y;

        // Instantly snap the current and previous positions to the target.
        // This prevents any visual lag or physics simulation while on the HUD.
        this.currentX = x;
        this.currentY = y;
        this.prevX = x;
        this.prevY = y;

        // Reset velocities to prevent any residual drift from a previous transition.
        this.velocityX = 0;
        this.velocityY = 0;
    }

    // --- Getters for Rendering (with tickDelta interpolation) ---

    /**
     * Gets the interpolated scale for the current frame.
     * @param tickDelta The fraction of a tick that has passed.
     * @return The smoothly interpolated scale.
     */
    public float getRenderScale(float tickDelta) {
        // Advance the physics simulation up to the current partial tick. This call
        // ensures that the underlying state has progressed smoothly between
        // discrete ticks.
        updatePhysicsForRender(tickDelta);
        return (float) this.currentScale;
    }

    /**
     * Gets the interpolated wiggle and physics-driven angle for the current frame.
     * @param tickDelta The fraction of a tick that has passed.
     * @return The smoothly interpolated angle.
     */
    public float getRenderAngle(float tickDelta) {
        // Advance the physics simulation up to the current partial tick.
        updatePhysicsForRender(tickDelta);
        // Use the current angle directly since the simulation has been updated.
        float physicsAngle = (float) this.currentAngle;
        // Maintain the cosmetic wiggle on top of the physics-driven rotation.
        float wiggleTarget = 0.0f;
        if (wiggleTimer > WIGGLE_INTERVAL_TICKS) {
            float progress = (wiggleTimer - WIGGLE_INTERVAL_TICKS + tickDelta) / (float) WIGGLE_DURATION_TICKS;
            wiggleTarget = MathHelper.sin(progress * (float) Math.PI * 2.0f) * WIGGLE_MAX_ANGLE_DEGREES;
        }
        this.wiggleAngle += (wiggleTarget - this.wiggleAngle) * 0.4f * tickDelta;
        return physicsAngle + this.wiggleAngle;
    }

    /**
     * Gets the interpolated X position for the current frame, including the cosmetic settle wobble.
     * @param tickDelta The fraction of a tick that has passed.
     * @return The smoothly interpolated X position.
     */
    public double getRenderX(float tickDelta) {
        // Advance the physics simulation up to the current partial tick.
        updatePhysicsForRender(tickDelta);
        double physicalX = this.currentX;
        if (this.settleWobbleTicks > 0) {
            float progress = (WOBBLE_DURATION_TICKS - (this.settleWobbleTicks - tickDelta)) / (float) WOBBLE_DURATION_TICKS;
            double decay = Math.pow(1.0 - progress, WOBBLE_DECAY_POWER);
            double sineWave = Math.sin(progress * Math.PI * 2.0 * WOBBLE_OSCILLATIONS);
            return physicalX + Math.cos(this.wobbleAngle) * this.wobbleMagnitude * sineWave * decay;
        }
        return physicalX;
    }

    /**
     * Gets the interpolated Y position for the current frame, including the cosmetic settle wobble.
     * @param tickDelta The fraction of a tick that has passed.
     * @return The smoothly interpolated Y position.
     */
    public double getRenderY(float tickDelta) {
        // Advance the physics simulation up to the current partial tick.
        updatePhysicsForRender(tickDelta);
        double physicalY = this.currentY;
        if (this.settleWobbleTicks > 0) {
            float progress = (WOBBLE_DURATION_TICKS - (this.settleWobbleTicks - tickDelta)) / (float) WOBBLE_DURATION_TICKS;
            double decay = Math.pow(1.0 - progress, WOBBLE_DECAY_POWER);
            double sineWave = Math.sin(progress * Math.PI * 2.0 * WOBBLE_OSCILLATIONS);
            return physicalY + Math.sin(this.wobbleAngle) * this.wobbleMagnitude * sineWave * decay;
        }
        return physicalY;
    }
}
```

`AnnouncementIconWidget.java`
```java
package net.dawson.adorablehamsterpets.client.gui.widgets;

// (Imports omitted to save token count)

/**
 * An interactive widget representing the announcement icon, designed to be
 * displayed on top of GUI screens. It handles its own rendering, animations,
 * tooltips, and click actions.
 */
public class AnnouncementIconWidget extends ButtonWidget {
    private static final Identifier ICON_TEXTURE = Identifier.of(AdorableHamsterPets.MOD_ID, "textures/item/announcement_bell_icon.png");
    private static final int ICON_WIDTH = 16;
    private static final int ICON_HEIGHT = 16;

    private final Screen parentScreen;
    private int lastTargetX = -1;
    private int lastTargetY = -1;

    public AnnouncementIconWidget(int x, int y, int width, int height, PressAction onPress, Screen parentScreen) {
        super(x, y, width, height, Text.empty(), onPress, DEFAULT_NARRATION_SUPPLIER);
        this.parentScreen = parentScreen;
    }

    // Override renderButton on 1.20.1 instead of renderWidget
    @Override
    protected void renderButton(DrawContext context, int mouseX, int mouseY, float delta) {
        AnnouncementIconAnimator animator = AnnouncementIconAnimator.INSTANCE;

        // --- 1. Dynamic Position Calculation ---
        if (this.parentScreen instanceof HandledScreen<?> containerScreen) {
            // Logic for inventory screens (uses widget offsets)
            HandledScreenAccessor accessor = (HandledScreenAccessor) containerScreen;
            int guiLeft = accessor.getX();
            int guiTop = accessor.getY();
            int guiWidth = accessor.getBackgroundWidth();

            int targetX;
            int targetY;

            // Forge-specific horizontal offset to avoid overlap with top tabs
            int neoForgeCreativeModeOffset = Platform.isForge() ? -26 : 0;

            // Position slightly outside the corner, with slightly different
            // offsets for creative and survival mode to accommodate their unique shapes.
            if (containerScreen instanceof net.minecraft.client.gui.screen.ingame.CreativeInventoryScreen) {
                // Creative Inventory (above the top right corner, to avoid conflicting with inventory mods like JEI, EMI, and REI)
                targetX = guiLeft + guiWidth - 22 + + neoForgeCreativeModeOffset + Configs.AHP.creativeWidgetIconSettings.get().offsetX.get();
                targetY = guiTop - 47 + Configs.AHP.creativeWidgetIconSettings.get().offsetY.get();
            } else {
                // Survival Inventory (overlapping top right corner)
                targetX = guiLeft + guiWidth - this.width + 4 + Configs.AHP.survivalWidgetIconSettings.get().offsetX.get();
                targetY = guiTop - 4 + Configs.AHP.survivalWidgetIconSettings.get().offsetY.get();
            }

            // If the target position has changed (e.g., recipe book opened), start a new transition.
            if (targetX != this.lastTargetX || targetY != this.lastTargetY) {
                AnnouncementIconAnimator.INSTANCE.startTransition(targetX, targetY);
                this.lastTargetX = targetX;
                this.lastTargetY = targetY;
            }
        } else if (this.parentScreen instanceof TitleScreen) {
            // Logic for Title Screen (uses the global HUD config settings)
            animator.updateTargetPosition(this.parentScreen.width, this.parentScreen.height);
        }

        // --- 2. Get Animation State from Central Animator ---
        animator.setHovered(this.isHovered());

        float animScale = animator.getRenderScale(delta);
        float configScale = Configs.AHP.hudIconScale.get(); // Use HUD scale for title screen too
        float finalScale = animScale * configScale;
        float angle = animator.getRenderAngle(delta);
        double renderX = animator.getRenderX(delta);
        double renderY = animator.getRenderY(delta);

        // Update widget's logical bounds and position for click detection
        this.width = (int) (ICON_WIDTH * configScale);
        this.height = (int) (ICON_HEIGHT * configScale);
        this.setX((int) Math.round(renderX));
        this.setY((int) Math.round(renderY));

        // --- 3. Render the Icon ---
        context.getMatrices().push();
        // Use the precise double values for rendering to avoid pixel-snapping.
        context.getMatrices().translate(renderX + (this.width / 2.0), renderY + (this.height / 2.0), 0);
        context.getMatrices().scale(finalScale, finalScale, 1.0f);
        context.getMatrices().multiply(RotationAxis.POSITIVE_Z.rotationDegrees(angle));
        context.getMatrices().translate(-(ICON_WIDTH / 2.0), -(ICON_HEIGHT / 2.0), 0);

        context.drawTexture(ICON_TEXTURE, 0, 0, 0, 0, ICON_WIDTH, ICON_HEIGHT, ICON_WIDTH, ICON_HEIGHT);

        context.getMatrices().pop();

        // --- 4. Render Tooltip ---
        if (this.isHovered()) {
            List<AnnouncementManager.PendingNotification> notifications = AnnouncementManager.INSTANCE.getPendingNotifications();
            if (!notifications.isEmpty()) {
                List<Text> tooltipLines = new java.util.ArrayList<>();
                Text modNameText = Text.translatable("key.categories.adorablehamsterpets.main").formatted(Formatting.BLUE, Formatting.ITALIC);

                Text mainTooltipLine = null;
                if (this.parentScreen instanceof TitleScreen) {
                    mainTooltipLine = notifications.stream()
                            .filter(n -> n.reason().equals(AnnouncementManager.PendingNotification.UPDATE_AVAILABLE_ANNOUNCEMENT))
                            .findFirst()
                            .map(AnnouncementManager::getTooltipTextForNotification)
                            .orElse(null);
                } else {
                    AnnouncementManager.PendingNotification primary = notifications.get(0);
                    mainTooltipLine = AnnouncementManager.getTooltipTextForNotification(primary);
                }

                if (mainTooltipLine != null) {
                    tooltipLines.add(mainTooltipLine);
                    tooltipLines.add(modNameText);
                    context.drawTooltip(MinecraftClient.getInstance().textRenderer, tooltipLines, mouseX, mouseY);
                }
            }
        }
    }

    /**
     * Called when the widget is clicked.
     */
    @Override
    public void onPress() {
        // --- 1. Trigger Visual & Audio Feedback ---
        AnnouncementIconAnimator.INSTANCE.triggerClickAnimation();
        MinecraftClient.getInstance().getSoundManager().play(PositionedSoundInstance.master(SoundEvents.UI_BUTTON_CLICK, 1.0F));

        // --- 2. Execute Click Logic ---
        // Get notifications directly from the manager so the icon can appear on the title screen
        List<AnnouncementManager.PendingNotification> notifications = AnnouncementManager.INSTANCE.getPendingNotifications();
        if (notifications.isEmpty()) {
            return;
        }

        MinecraftClient client = MinecraftClient.getInstance();
        Identifier bookId = Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_tips_guide_book");

        if (this.parentScreen instanceof TitleScreen) {
            // --- 1. Title Screen Logic ---
            // Find the single LATEST "update available" notification to display. This prevents ambiguity if
            // multiple are pending and avoids opening the Patchouli book GUI, which would crash from the title screen.
            notifications.stream()
                    .filter(n -> n.reason().equals(AnnouncementManager.PendingNotification.UPDATE_AVAILABLE_ANNOUNCEMENT))
                    .max(Comparator.comparing(n -> Semver.parse(n.announcement().semver()))) // Find the highest version
                    .ifPresent(notification -> {
                        Announcement announcement = notification.announcement();
                        Book book = BookRegistry.INSTANCE.books.get(bookId);
                        if (book != null) {
                            Identifier entryId = Identifier.of(AdorableHamsterPets.MOD_ID, "announcement_" + announcement.id());
                            JsonObject json = new JsonObject();
                            json.addProperty("name", announcement.title());
                            json.addProperty("icon", "minecraft:writable_book");
                            json.addProperty("category", "adorablehamsterpets:update_notes");
                            json.add("pages", new JsonArray());
                            BookEntry virtualEntry = new BookEntry(json, entryId, book, AdorableHamsterPets.MOD_ID);

                            // Open the screen with the TitleScreen as its parent
                            client.setScreen(new AnnouncementScreen(announcement, notification.reason(), this.parentScreen, virtualEntry));
                        }
                    });
        } else {
            if (notifications.size() == 1) {
                // --- 2. Direct Open Logic ---
                // Open directly to the custom GUI if only one message is available
                AnnouncementManager.PendingNotification notification = notifications.get(0);
                Announcement announcement = notifications.get(0).announcement();
                Book book = BookRegistry.INSTANCE.books.get(bookId);
                if (book != null) {
                    // Get the "real" virtual entry from the book's contents
                    Identifier entryId = Identifier.of(AdorableHamsterPets.MOD_ID, "announcement_" + announcement.id());
                    BookEntry realVirtualEntry = book.getContents().entries.get(entryId);

                    if (realVirtualEntry != null) {
                        // Open the screen with the real entry and a null parent
                        // Passing null tells the screen to return to the game HUD on close.
                        client.setScreen(new AnnouncementScreen(announcement, notification.reason(), null, realVirtualEntry));
                    } else {
                        AdorableHamsterPets.LOGGER.error("[AHP] Could not find virtual entry '{}' in book contents to open announcement screen.", entryId);
                    }
                }
            } else {
                // --- Multiple Pending Notifications Logic ---
                // If multiple, open the Patchouli book to the main landing page
                Book book = BookRegistry.INSTANCE.books.get(bookId);
                if (book != null) {
                    // By setting the book's current GUI instance to null, we force Patchouli's
                    // internal logic to create a new GuiBookLanding instance upon opening.
                    book.getContents().currentGui = null;
                    // Clear the GUI history to prevent the back button from navigating to the previous entry.
                    book.getContents().guiStack.clear();
                }

                // Use the client-side method that only takes the book's ID.
                // The user will land on the book's main page.
                PatchouliAPI.get().openBookGUI(bookId);
            }
        }
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/client/option/`
`DynamicDismountKeyBinding.java`
```java
package net.dawson.adorablehamsterpets.client.option;

// (Imports omitted to save token count)

/**
 * A custom KeyBinding that dynamically changes its display name in the Controls menu
 * based on the current configuration settings. This prevents user confusion by clearly
 * indicating when the keybind is not active.
 */
public class DynamicDismountKeyBinding extends KeyBinding {

    private final String enabledTranslationKey;
    private final String disabledTranslationKey;


    /**
     * Constructs a new dynamic key binding.
     *
     * @param translationKey The base translation key for the keybind's name when it is enabled.
     * @param code           The default key code.
     * @param category       The translation key for the category this keybind belongs to.
     */
    public DynamicDismountKeyBinding(String translationKey, int code, String category) {
        super(translationKey, InputUtil.Type.KEYSYM, code, category);
        this.enabledTranslationKey = translationKey;
        this.disabledTranslationKey = translationKey + ".disabled";
    }

    /**
     * Overrides the default behavior to dynamically select a translation key.
     * This is called by the Controls screen when rendering the keybind's name.
     *
     * @return The appropriate translation key based on the current config setting.
     */
    @Override
    public String getTranslationKey() {
        // Check the live config value.
        if (Configs.AHP.dismountTriggerType == DismountTriggerType.CUSTOM_KEYBIND) {
            // If the custom keybind is enabled in the config, use the standard name.
            return this.enabledTranslationKey;
        } else {
            // Otherwise, use the special "disabled" name.
            return this.disabledTranslationKey;
        }
    }
}
```

`DynamicForceMountKeyBinding.java`
```java
package net.dawson.adorablehamsterpets.client.option;

// (Imports omitted to save token count)

/**
 * A custom KeyBinding that dynamically changes its display name in the Controls menu
 * based on the "Enable Force-Mount Keybind" configuration setting.
 */
public class DynamicForceMountKeyBinding extends KeyBinding {

    private final String enabledTranslationKey;
    private final String disabledTranslationKey;

    /**
     * Constructs a new dynamic key binding.
     *
     * @param translationKey The base translation key for the keybind's name when it is enabled.
     * @param code           The default key code.
     * @param category       The translation key for the category this keybind belongs to.
     */
    public DynamicForceMountKeyBinding(String translationKey, int code, String category) {
        super(translationKey, InputUtil.Type.KEYSYM, code, category);
        this.enabledTranslationKey = translationKey;
        this.disabledTranslationKey = translationKey + ".disabled";
    }

    /**
     * Overrides the default behavior to dynamically select a translation key.
     * This is called by the Controls screen when rendering the keybind's name.
     *
     * @return The appropriate translation key based on the current config setting.
     */
    @Override
    public String getTranslationKey() {
        if (Configs.AHP.enableShoulderMountKeybind) {
            return this.enabledTranslationKey;
        } else {
            return this.disabledTranslationKey;
        }
    }
}
```

`ModKeyBindings.java`
```java
package net.dawson.adorablehamsterpets.client.option;

// (Imports omitted to save token count)

/** Holds the mod's key mappings. */
public class ModKeyBindings {
    // --- Translation Keys ---
    public static final String KEY_CATEGORY_HAMSTERPETS = "key.categories.adorablehamsterpets.main";
    public static final String KEY_THROW_HAMSTER = "key.adorablehamsterpets.throw_hamster";
    public static final String KEY_DISMOUNT_HAMSTER = "key.adorablehamsterpets.dismount_hamster";
    public static final String KEY_FORCE_MOUNT_HAMSTER = "key.adorablehamsterpets.force_mount_hamster";

    // --- KeyBinding Instances ---
    public static KeyBinding THROW_HAMSTER_KEY;
    public static KeyBinding DISMOUNT_HAMSTER_KEY;
    public static KeyBinding FORCE_MOUNT_HAMSTER_KEY;

    /**
     * Initializes the KeyBinding objects. This should be called during client setup
     * before the keys are registered by the platform-specific loader.
     */
    public static void init() {
        THROW_HAMSTER_KEY = new KeyBinding(
                KEY_THROW_HAMSTER,
                InputUtil.Type.KEYSYM,
                GLFW.GLFW_KEY_G, // Default to 'G'
                KEY_CATEGORY_HAMSTERPETS
        );

        DISMOUNT_HAMSTER_KEY = new DynamicDismountKeyBinding(
                KEY_DISMOUNT_HAMSTER,
                InputUtil.UNKNOWN_KEY.getCode(), // Unbound by default
                KEY_CATEGORY_HAMSTERPETS
        );

        FORCE_MOUNT_HAMSTER_KEY = new DynamicForceMountKeyBinding(
                KEY_FORCE_MOUNT_HAMSTER,
                InputUtil.UNKNOWN_KEY.getCode(), // Unbound by default
                KEY_CATEGORY_HAMSTERPETS
        );
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/client/particle/`
`HamsterBeddingParticle.java`
```java
package net.dawson.adorablehamsterpets.client.particle;

// (Imports omitted to save token count)

/**
 * A particle representing a piece of hamster bedding (a leaf).
 * This particle has two distinct physics behaviors:
 * <p>
 * 1.  <b>Standard Physics:</b> A simple gravity-and-friction model used when particles are spawned
 *     from bed interactions.
 * 2.  <b>Floaty Physics:</b> A complex simulation for particles spawned from the Hamster Bedding item
 *     or a dispenser. This includes a gentle pendulum-like sway and a deterministic, spatially-coherent
 *     wind gust model that creates realistic, synchronized movement among nearby particles.
 */
public class HamsterBeddingParticle extends SpriteBillboardParticle {

    // --- Constants ---
    /** A magic number used in the 'vy' field to signal that this particle should use the "floaty" physics simulation. */
    public static final double BEDDING_ITEM_FLAG = -0.000123;

    // --- Universal Drift ---
    private static final float UNIVERSAL_DRIFT_ACCEL = 0.002f;
    private static final float DRIFT_PERIOD_TICKS = 3 * 60 * 20f; // 3 minutes

    // --- Sway Physics Constants (for floaty mode) ---
    private static final float SWAY_ROTATION_AMPLITUDE = 0.5f;
    private static final float SWAY_ROTATION_SPEED_MOD = 2.8f;
    private static final float UPWARD_BOOST_AT_APEX = 0.004f;
    private static final float HORIZ_SPEED_CAP = 0.08f;

    // --- Gust Physics Constants (for floaty mode) ---
    private static final int   GUST_WINDOW_TICKS   = 100;    // Time window to evaluate gust events.
    private static final float GUST_PROB_PER_WIN   = 0.35f;  // Chance a gust event exists in a window.
    private static final int   GUST_MIN_LEN        = 20;
    private static final int   GUST_MAX_LEN        = 40;
    private static final int   GUST_CELL_BLOCKS    = 12;    // Spatial coherence grid size.
    private static final float GUST_UP_ACCEL       = 0.025f;
    private static final float GUST_HORIZ_ACCEL    = 0.06f;
    private static final float GUST_SPIN_IMPULSE   = 2.0f;
    private static final float GUST_SPIN_DAMP      = 0.85f;
    private static final float COUPLING_MIN        = 0.12f;  // Minimum particle response to a gust.
    private static final float COUPLING_SPAN       = 0.78f;
    private static final int   PER_PARTICLE_DELAY_MAX = 8;   // Staggers the start of a particle's gust response.
    private static final float WIND_DRAG           = 0.10f;  // How strongly particles are pulled toward the wind's target speed.
    private static final float WIND_TARGET_SPEED   = 0.09f;  // Blocks per tick at full strength
    private static final float GUST_RISE_FRAC      = 0.30f;  // The first 30% of a gust's duration is its ramp-up swayPhaseOffset.
    private static final float EXTRA_HCAP          = 0.075f; // Additional horizontal speed allowed during a full gust.

    // --- Sound Management ---
    private static final Set<Long> playedGustSoundsThisTick = new HashSet<>();
    private static final Deque<Long> soundStartTimes = new ArrayDeque<>();
    private static final int MAX_CONCURRENT_SOUNDS = 3;
    private static final int SOUND_DURATION_TICKS = 65; // ~3 seconds
    private static long lastTick = -1L;

    // --- Fields ---
    // --- State ---
    private final boolean useFloatyPhysics;
    private long lastAppliedGustKey = Long.MIN_VALUE;

    // --- Sway Physics ---
    private final float swayFrequency;
    private final float swayAcceleration;
    private final float swayPhaseOffset;
    private final float swayDirectionX, swayDirectionZ;
    private final float constantRollVelocity;

    // --- Gust Physics ---
    private float gustSpinVel = 0f;
    private float gustCoupling = 0f;
    private int gustDelayTicks = 0;

    public HamsterBeddingParticle(ClientWorld world,
                                  double x, double y, double z,
                                  double vx, double vy, double vz,
                                  SpriteProvider sprites) {
        super(world, x, y, z, vx, vy, vz);

        // Use floaty physics if spawned from the Hamster Bedding item
        this.useFloatyPhysics = (vy == BEDDING_ITEM_FLAG);

        // --- Set Physics based on Spawn Type ---
        if (useFloatyPhysics) {
            // "Floaty" physics for item/dispenser use.
            this.velocityY = 0;
            this.gravityStrength = 0.07f;
            this.velocityMultiplier = 0.92f;
            this.maxAge = 140 + world.random.nextInt(200);

            float theta = world.random.nextFloat() * MathHelper.TAU;
            this.swayDirectionX = MathHelper.cos(theta);
            this.swayDirectionZ = MathHelper.sin(theta);

            this.swayFrequency = 0.09f + world.random.nextFloat() * 0.05f; // Period ~ 2π/ω = 45–80 ticks
            this.swayAcceleration = 0.002f + world.random.nextFloat() * 0.0025f; // Swing radius ≈ swayAcceleration / ω^2  → ~0.15–0.35 blocks
            this.swayPhaseOffset = world.random.nextFloat() * MathHelper.TAU;
            this.constantRollVelocity = (world.random.nextFloat() - 0.5f) * 0.12f; // Slow constant roll
        } else {
            // Standard physics for bed interactions.
            this.gravityStrength = HamsterBeddingParticleBehavior.GRAVITY;
            this.velocityMultiplier = HamsterBeddingParticleBehavior.FRICTION;
            this.maxAge = HamsterBeddingParticleBehavior.LIFETIME_MIN
                    + world.random.nextInt(HamsterBeddingParticleBehavior.LIFETIME_EXTRA);

            this.swayDirectionX = 0f;
            this.swayDirectionZ = 0f;
            this.swayFrequency = 0f;
            this.swayAcceleration = 0f;
            this.swayPhaseOffset = 0f;
            this.constantRollVelocity = 0f;
        }

        // --- Set Visuals ---
        this.setSprite(sprites.getSprite(this.random));
        this.setBoundingBoxSpacing(HamsterBeddingParticleBehavior.SIZE_X, HamsterBeddingParticleBehavior.SIZE_Y);
    }

    @Override
    public void tick() {
        long worldTime = this.world.getTime();
        // --- Sound Management ---
        // Prune old sounds and clear per-tick tracker
        if (worldTime != lastTick) {
            playedGustSoundsThisTick.clear();
            // Remove any sound start times that are older than the sound's duration
            while (!soundStartTimes.isEmpty() && worldTime - soundStartTimes.peekFirst() > SOUND_DURATION_TICKS) {
                soundStartTimes.pollFirst();
            }
            lastTick = worldTime;
        }

        // --- Particle Physics ---
        if (useFloatyPhysics) {
            // --- Universal Drift When Outdoors ---
            float universalDriftAngle;
            if (Configs.AHP.enableDynamicDriftAngle.get()) {
                // Dynamic, time-based rotation
                // On 1.20.1, use getTickDelta() directly and use Math.PI * 2 for the circle constant
                float timeWithPartial = worldTime + MinecraftClient.getInstance().getTickDelta();
                universalDriftAngle = (timeWithPartial / DRIFT_PERIOD_TICKS) * (float)(Math.PI * 2D);
            } else {
                // Static angle from config
                universalDriftAngle = (float) Math.toRadians(Configs.AHP.staticDriftAngle.get());
            }

            float driftDirX = MathHelper.cos(universalDriftAngle);
            float driftDirZ = MathHelper.sin(universalDriftAngle);

            boolean isOutdoor = IndoorOutdoorDetector.isOutdoor(this.world, this.x, this.y, this.z);

            // Apply drift only if outdoors
            if (isOutdoor) {
                this.velocityX += driftDirX * UNIVERSAL_DRIFT_ACCEL;
                this.velocityZ += driftDirZ * UNIVERSAL_DRIFT_ACCEL;
            }

            // --- Sway Physics ---
            float phase = (this.age + this.swayPhaseOffset) * this.swayFrequency;
            float sinPhase = MathHelper.sin(phase);
            float cosPhase = MathHelper.cos(phase);
            float positionInSwing = Math.abs(cosPhase);
            // Swing faster in the middle and slower at the edges
            float speedMultiplier = 0.5f + 1.5f * positionInSwing;
            float modifiedAcceleration = sinPhase * this.swayAcceleration * speedMultiplier;

            this.velocityX += this.swayDirectionX * modifiedAcceleration;
            this.velocityZ += this.swayDirectionZ * modifiedAcceleration;

            // Add a gradual upward boost that is strongest at the apex of the swing to create a 'U' shape motion.
            // The boost is proportional to the fourth power of the particle's position in its swing.
            this.velocityY += UPWARD_BOOST_AT_APEX * (float)Math.pow(positionInSwing, 4);

            // --- Gust Simulation ---
            float gustStrengthLocal = 0f;
            if (isOutdoor) { // Reuse the isOutdoor check
                Gust gust = sampleGust(this.world, this.x, this.z);

                if (gust.active) {
                    // Initialize gust response for this particle if it's a new gust event.
                    if (gust.key != lastAppliedGustKey) {
                        // Play sound once per unique gust event per tick, up to MAX_CONCURRENT_SOUNDS simultaneously
                        if (soundStartTimes.size() < MAX_CONCURRENT_SOUNDS && playedGustSoundsThisTick.add(gust.key)) {
                            this.world.playSound(this.x, this.y, this.z, ModSounds.GENTLE_BREEZE.get(), SoundCategory.AMBIENT, 1.0f, 1.0f, false);
                            soundStartTimes.addLast(worldTime);
                        }

                        Random pr = new Random(mix64(gust.key, System.identityHashCode(this)));
                        this.gustCoupling = COUPLING_MIN + pr.nextFloat() * COUPLING_SPAN;
                        this.gustCoupling = (float) Math.sqrt(this.gustCoupling); // Bias toward stronger coupling, most particles affected.
                        this.gustDelayTicks = pr.nextInt(PER_PARTICLE_DELAY_MAX + 1);
                        this.lastAppliedGustKey = gust.key;
                    }

                    int delayedTicksSinceGustStart = Math.max(0, gust.ticksSinceGustStart - this.gustDelayTicks);
                    float gustProgress = delayedTicksSinceGustStart / (float) gust.gustDurationTicks;
                    float rise = smooth01(Math.min(1f, gustProgress / GUST_RISE_FRAC));
                    float decay = (float) Math.exp(-3.0f * gustProgress);
                    gustStrengthLocal = rise * decay * this.gustCoupling;

                    // Apply a one-time spin impulse when the particle first feels the gust.
                    if (delayedTicksSinceGustStart == 0 && gust.ticksSinceGustStart >= this.gustDelayTicks) {
                        this.gustSpinVel += GUST_SPIN_IMPULSE * this.gustCoupling;
                    }

                    // --- Interpolate Gust Angle ---
                    float easeOutFactor = 1.0f - (float) Math.pow(1.0f - gustProgress, 3.0); // Cubic ease-out
                    float finalGustDirX = MathHelper.lerp(easeOutFactor, driftDirX, gust.gustDirX);
                    float finalGustDirZ = MathHelper.lerp(easeOutFactor, driftDirZ, gust.gustDirZ);

                    // Apply drag along the interpolated wind angle toward the wind's target speed.
                    float along = (float)(this.velocityX * finalGustDirX + this.velocityZ * finalGustDirZ);
                    float target = WIND_TARGET_SPEED * gustStrengthLocal;
                    float corr = (target - along) * WIND_DRAG;
                    this.velocityX += finalGustDirX * corr;
                    this.velocityZ += finalGustDirZ * corr;

                    // Apply upward and lateral push from the gust using the interpolated direction.
                    this.velocityY += gustStrengthLocal * GUST_UP_ACCEL;
                    this.velocityX += finalGustDirX * gustStrengthLocal * GUST_HORIZ_ACCEL;
                    this.velocityZ += finalGustDirZ * gustStrengthLocal * GUST_HORIZ_ACCEL;
                }
            }

            // --- Velocity & Rotation Update with Dynamic Horizontal Cap ---
            float dynamicHorizontalCap = HORIZ_SPEED_CAP + gustStrengthLocal * EXTRA_HCAP;
            float horizontalSpeedSquared = (float)(this.velocityX * this.velocityX + this.velocityZ * this.velocityZ);
            if (horizontalSpeedSquared > dynamicHorizontalCap * dynamicHorizontalCap) {
                float scale = dynamicHorizontalCap / MathHelper.sqrt(horizontalSpeedSquared);
                this.velocityX *= scale;
                this.velocityZ *= scale;
            }

            // --- Roll update ---
            this.prevAngle = this.angle;
            this.gustSpinVel *= GUST_SPIN_DAMP;
            // Angular velocity from sway is now based on cos(phase) to make it fastest at the apex of the swing, creating a 'twist'.
            float swayAngularVelocity = cosPhase * this.swayFrequency * SWAY_ROTATION_AMPLITUDE * SWAY_ROTATION_SPEED_MOD;
            this.angle += this.constantRollVelocity + swayAngularVelocity + this.gustSpinVel;
        }

        super.tick();

        // --- Finalization ---
        // Settle quickly after landing on a block.
        if (this.onGround) {
            this.maxAge = Math.min(this.maxAge, this.age + 10);
        }
    }

    @Override
    public ParticleTextureSheet getType() {
        return ParticleTextureSheet.PARTICLE_SHEET_TRANSLUCENT;
    }

    // --- Deterministic Wind Model ---
    /**
     * Represents a single gust event active in the current window at a given position.
     */
    private record Gust(boolean active, long key, int ticksSinceGustStart, int gustDurationTicks, float gustDirX, float gustDirZ) {}

    /**
     * Deterministically samples a wind gust based on the current world time and particle position.
     * This creates spatially and temporally coherent wind effects for groups of particles.
     */
    private static Gust sampleGust(ClientWorld world, double x, double z) {
        long worldTime = world.getTime();
        long gustWindowIndex = Math.floorDiv(worldTime, GUST_WINDOW_TICKS);

        int cellX = MathHelper.floor((float)x) / GUST_CELL_BLOCKS;
        int cellZ = MathHelper.floor((float)z) / GUST_CELL_BLOCKS;

        long baseSeed = mix64(cellX, cellZ, gustWindowIndex);
        Random r = new Random(baseSeed);

        if (r.nextFloat() >= GUST_PROB_PER_WIN) {
            return new Gust(false, baseSeed, 0, 0, 0f, 0f);
        }

        int tickInCurrentWindow = (int)(worldTime % GUST_WINDOW_TICKS);
        int maxStartTickInWindow = Math.max(1, GUST_WINDOW_TICKS - GUST_MAX_LEN - 1);
        int gustStartTick = 1 + r.nextInt(maxStartTickInWindow);
        int gustDurationTicks = GUST_MIN_LEN + r.nextInt(GUST_MAX_LEN - GUST_MIN_LEN + 1);

        if (tickInCurrentWindow < gustStartTick || tickInCurrentWindow > gustStartTick + gustDurationTicks) {
            long key = baseSeed ^ gustStartTick;
            return new Gust(false, key, 0, gustDurationTicks, 0f, 0f);
        }

        float theta = r.nextFloat() * MathHelper.TAU;
        float gustDirX = MathHelper.cos(theta);
        float gustDirZ = MathHelper.sin(theta);
        long key = (baseSeed ^ gustStartTick);
        int ticksSinceGustStart = tickInCurrentWindow - gustStartTick;

        return new Gust(true, key, ticksSinceGustStart, gustDurationTicks, gustDirX, gustDirZ);
    }

    /** A small, fast mixing function for generating stable randomness per cell/window. */
    private static long mix64(long seedA, long seedB) {
        long x = seedA * 0x9E3779B97F4A7C15L + seedB + 0xBF58476D1CE4E5B9L;
        x ^= (x >>> 30);
        x *= 0xBF58476D1CE4E5B9L;
        x ^= (x >>> 27);
        x *= 0x94D049BB133111EBL;
        x ^= (x >>> 31);
        return x;
    }

    private static long mix64(long currentSwayAcceleration, long b, long c) {
        return mix64(mix64(currentSwayAcceleration, b), c);
    }

    /** A smoothing function (ease-in, ease-out) for gust strength envelopes. */
    private static float smooth01(float x) {
        x = MathHelper.clamp(x, 0f, 1f);
        return x * x * (3f - 2f * x);
    }

    // --- Factory ---
    /**
     * The factory for creating instances of {@link HamsterBeddingParticle}.
     */
    public static class Factory implements ParticleFactory<net.minecraft.particle.DefaultParticleType> {
        private final SpriteProvider sprites;

        public Factory(SpriteProvider sprites) {
            this.sprites = sprites;
        }

        @Override
        public Particle createParticle(net.minecraft.particle.DefaultParticleType type, ClientWorld world,
                                       double x, double y, double z,
                                       double vx, double vy, double vz) {
            return new HamsterBeddingParticle(world, x, y, z, vx, vy, vz, this.sprites);
        }
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/client/sound/`
`HamsterCleaningSoundInstance.java`
```java
package net.dawson.adorablehamsterpets.client.sound;

// (Imports omitted to save token count)

public class HamsterCleaningSoundInstance extends AbstractSoundInstance implements TickableSoundInstance {

    private final HamsterEntity hamster;
    private boolean done = false;

    public HamsterCleaningSoundInstance(HamsterEntity hamster) {
        super(ModSounds.HAMSTER_SCRATCH.get(), SoundCategory.NEUTRAL, hamster.getRandom());
        this.hamster = hamster;
        this.x = hamster.getX();
        this.y = hamster.getY();
        this.z = hamster.getZ();

        // --- Properties ---
        this.repeat = true; // Loop the sound
        this.repeatDelay = 0;
        this.volume = 2.0F;
        this.pitch = 1.0F;

        this.relative = false;
        this.attenuationType = AttenuationType.LINEAR;
    }

    public void stop() {
        this.done = true;
    }

    @Override
    public boolean isDone() {
        return this.done;
    }

    @Override
    public void tick() {
        // The only job of this tick method is to check if the sound should stop.
        // It stops if the hamster is no longer cleaning OR if the entity is invalid.
        if (!this.hamster.isCleaning() || !this.hamster.isAlive()) {
            this.done = true;
            return;
        }

        // Update position to follow the hamster
        this.x = this.hamster.getX();
        this.y = this.hamster.getY();
        this.z = this.hamster.getZ();
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/client/state/`
`ClientShoulderHamsterData.java`
```java
package net.dawson.adorablehamsterpets.client.state;

// (Imports omitted to save token count)

/**
 * A client-side data holder attached to each player to manage the state of their shoulder pets.
 * This ensures that all state management is isolated per-player and occurs on the main client thread.
 */
public class ClientShoulderHamsterData {

    // --- Physics Constants ---
    private static final float SPRING_STIFFNESS = 3.0f;
    private static final float DAMPING_FACTOR = 0.7f; // How quickly it stops bouncing
    private static final float BOUNCINESS_FACTOR = 1.7f; // Controls bounce height
    private static final float GRAVITY_FORCE = 0.2f;
    private static final float HAMSTER_MASS = 2.0f;
    private static final float FALL_DRAG_MULTIPLIER = 0.4f; // Slows fall speed
    private static final float SQUASH_STRETCH_INTENSITY = 5.0f;
    private static final float IMPACT_SQUASH_INTENSITY = 5.0f;
    private static final float IMPACT_SQUASH_DECAY = 0.4f; // The speed at which the impact squash wears off

    private final Map<ShoulderLocation, ShoulderHamsterState> hamsterStates = new EnumMap<>(ShoulderLocation.class);
    private final Map<ShoulderLocation, Integer> animationAges = new EnumMap<>(ShoulderLocation.class);
    private final Map<ShoulderLocation, PhysicsState> physicsStates = new EnumMap<>(ShoulderLocation.class);
    private double previousPlayerVelocityY = 0.0;
    private boolean wasPlayerOnGroundLastTick = true;
    private int landingCheckGracePeriod;
    private int landingEventWindow = 0;

    /**
     * A mutable inner class to hold the physics state for a single shoulder pet.
     */
    public static class PhysicsState {
        public float hamsterOffsetY = 0.0f;
        public float previousOffsetY = 0.0f;
        public float hamsterVelocityY = 0.0f;
        public float hamsterScaleY = 1.0f;
        public float previousScaleY = 1.0f;
        public float impactSquashFactor = 0.0f;
        public int soundDelayTicks = 0;
        public int impactCooldown = 0;
        public int jumpCooldown = 0;
    }

    public ClientShoulderHamsterData() {
        this.landingCheckGracePeriod = 20;
    }

    /**
     * Ticks the state machines and animation clocks for all active shoulder pets on this player.
     * This method should be called once per client tick.
     *
     * @param player The client player entity this data is attached to.
     */
    public void clientTick(AbstractClientPlayerEntity player) {
        PlayerEntityAccessor playerAccessor = (PlayerEntityAccessor) player;

        // --- 1. Detect Player Jump Event ---
        boolean playerJustStartedJumping = this.wasPlayerOnGroundLastTick && !player.isOnGround();
        if (playerJustStartedJumping) {AdorableHamsterPets.LOGGER.trace("[PHYSICS DEBUG] Player JUMP detected at tick {}. Previous Velocity Y: {}", player.getWorld().getTime(), String.format("%.4f", this.previousPlayerVelocityY));}

        boolean playerJustLanded = false;
        if (this.landingCheckGracePeriod > 0) {
            this.landingCheckGracePeriod--;
        } else {
            playerJustLanded = !this.wasPlayerOnGroundLastTick && player.isOnGround();
        }
        // Open the landing event window when the player lands
        if (playerJustLanded) {
            this.landingEventWindow = 7;
            AdorableHamsterPets.LOGGER.trace("[PHYSICS DEBUG] Player LANDING detected. Opening 15-tick impact window.");
        }

        // Decrement the window timer
        if (this.landingEventWindow > 0) {
            this.landingEventWindow--;
        }

        // --- 2. Standard State Ticking ---
        // Determine player movement state once
        boolean isSprinting = player.isSprinting();
        // Player is "walking" if they are moving but not sprinting.
        boolean isWalking = player.getVelocity().horizontalLengthSquared() > 1.0E-7 && !isSprinting;

        // Calculate player's vertical acceleration for this tick
        double playerVelocityY = player.getVelocity().y;
        // Introduce a dead zone for near-zero velocities
        // If the player is on the ground and their vertical velocity is very small, treat it as zero.
        if (player.isOnGround() && Math.abs(playerVelocityY) < 0.1) {
            playerVelocityY = 0.0;
        }

        double playerAccelerationY = playerVelocityY - this.previousPlayerVelocityY;

        // --- 3. Per-Hamster Simulation Loop ---
        // Iterate through all possible locations to update states
        int delay = 1; // Initialize delay counter for staggered sounds
        for (ShoulderLocation location : ShoulderLocation.values()) {
            NbtCompound shoulderNbt;
            try {
                // Try to get the data safely
                shoulderNbt = playerAccessor.getShoulderHamster(location);
            } catch (RuntimeException e) {
                // If the player entity is corrupted/uninitialized (Oculus shadow, etc),
                // stop trying to simulate physics for it.
                continue;
            }

            if (!shoulderNbt.isEmpty()) {
                // --- 3.1. Standard State Ticking ---
                ShoulderHamsterState state = this.hamsterStates.computeIfAbsent(location, l -> new ShoulderHamsterState());
                state.tick(isSprinting, isWalking);
                int currentAge = this.animationAges.getOrDefault(location, 0);
                this.animationAges.put(location, currentAge + 1);

                // --- 3.2. Physics Simulation Ticking ---
                PhysicsState physics = this.physicsStates.computeIfAbsent(location, l -> new PhysicsState());
                // Store the previous frame's offset for interpolation
                physics.previousOffsetY = physics.hamsterOffsetY;
                physics.previousScaleY = physics.hamsterScaleY;

                // Decay the impact squash over time
                physics.impactSquashFactor = cosineInterpolate(physics.impactSquashFactor, 0.0f, IMPACT_SQUASH_DECAY);

                // Decrement Cooldowns
                if (physics.impactCooldown > 0) physics.impactCooldown--;
                if (physics.jumpCooldown > 0) physics.jumpCooldown--;

                // Apply Jump Cooldown
                if (playerJustStartedJumping) {
                    // Prevent the impact physics from happening at the start of a jump
                    physics.jumpCooldown = 3;
                }

                // Store previous velocity for impact detection
                float previousHamsterVelocityY = physics.hamsterVelocityY;

                // Vertical Bounce Simulation
                float inertialForce = (float) (-playerVelocityY * HAMSTER_MASS);
                float springForce = -SPRING_STIFFNESS * physics.hamsterOffsetY;
                float dampingForce = -DAMPING_FACTOR * physics.hamsterVelocityY;
                float gravityForce = -GRAVITY_FORCE;
                float totalForce = inertialForce + springForce + dampingForce + gravityForce;
                float acceleration = totalForce / HAMSTER_MASS;
                physics.hamsterVelocityY += acceleration;

                // Apply extra drag only when falling
                if (physics.hamsterVelocityY < 0) {
                    physics.hamsterVelocityY *= FALL_DRAG_MULTIPLIER;
                }
                physics.hamsterOffsetY += physics.hamsterVelocityY;

                // Combined Impact Detection and Collision Logic
                if (physics.hamsterOffsetY < 0) {
                    // This block represents the moment of collision.

                    // Check if this is the FIRST impact in a sequence.
                    if (this.landingEventWindow > 0 && physics.impactCooldown == 0 && physics.jumpCooldown == 0) {
                        // 1. Trigger Impact Squash
                        physics.impactSquashFactor = Math.abs(physics.hamsterVelocityY) * IMPACT_SQUASH_INTENSITY;
                        // 2. Set Staggered Sound Delay
                        physics.soundDelayTicks = delay;
                        delay += player.getRandom().nextBetween(1, 2);
                        // 3. Set Impact Cooldown to prevent re-triggering on small bounces
                        physics.impactCooldown = 5;
                    }

                    // Always apply the bounce physics regardless of cooldowns.
                    physics.hamsterOffsetY = 0;
                    physics.hamsterVelocityY *= -BOUNCINESS_FACTOR;
                }

                // Handle Sound Delay Timer
                if (physics.soundDelayTicks > 0) {
                    physics.soundDelayTicks--;
                    if (physics.soundDelayTicks == 0) {
                        // Check Config Before Playing Sound
                        MinecraftClient client = MinecraftClient.getInstance();
                        boolean shouldPlaySound = !(Configs.AHP.silencePhysicsSoundsInFirstPerson && client.options.getPerspective().isFirstPerson());

                        if (shouldPlaySound) {
                            SoundEvent impactSound = ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_SHOULDER_IMPACT_SOUNDS, player.getRandom());
                            if (impactSound != null) {
                                client.getSoundManager().play(
                                        new net.minecraft.client.sound.PositionedSoundInstance(
                                                impactSound,
                                                net.minecraft.sound.SoundCategory.PLAYERS,
                                                1.0f,
                                                0.9f + player.getRandom().nextFloat() * 0.2f,
                                                player.getRandom(),
                                                player.getX(), player.getY(), player.getZ()
                                        )
                                );
                            }
                        }
                    }
                }

                // Squash and Stretch Simulation
                if (physics.impactSquashFactor > 0.001f) {AdorableHamsterPets.LOGGER.trace("[PHYSICS DEBUG]   -> Decaying impact squash for {}: {}", location, String.format("%.4f", physics.impactSquashFactor));}
                // 1. Calculate the base target scale from player acceleration.
                float accelScale = 1.0f - (float)playerAccelerationY * SQUASH_STRETCH_INTENSITY;
                // 2. Combine the acceleration scale with the impact squash.
                float combinedTargetScale = accelScale - physics.impactSquashFactor;
                // 3. Clamp the final combined value.
                float clampedTargetScale = MathHelper.clamp(combinedTargetScale, 0.65f, 1.25f);
                // 4. Smoothly interpolate towards the final, clamped target.
                physics.hamsterScaleY = cosineInterpolate(physics.hamsterScaleY, clampedTargetScale, 0.6f);

            } else {
                // If a slot becomes empty, remove all its associated data
                this.hamsterStates.remove(location);
                this.animationAges.remove(location);
                this.physicsStates.remove(location);
            }
        }
        // --- 4. Update State for Next Tick ---
        this.previousPlayerVelocityY = playerVelocityY;
        this.wasPlayerOnGroundLastTick = player.isOnGround();
    }

    /**
     * Gets the smoothly interpolated vertical offset for rendering.
     *
     * @param location    The shoulder location being rendered.
     * @param partialTick The fraction of a tick that has passed since the last full tick.
     * @return The interpolated vertical offset.
     */
    public float getRenderOffsetY(ShoulderLocation location, float partialTick) {
        PhysicsState state = this.physicsStates.get(location);
        if (state == null) {
            return 0.0f;
        }
        // Use cosine interpolation for a smoother ease-in/ease-out between ticks.
        return cosineInterpolate(state.previousOffsetY, state.hamsterOffsetY, partialTick);
    }

    /**
     * Gets the smoothly interpolated vertical scale for rendering.
     *
     * @param location    The shoulder location being rendered.
     * @param partialTick The fraction of a tick that has passed since the last full tick.
     * @return The interpolated vertical scale factor.
     */
    public float getRenderScaleY(ShoulderLocation location, float partialTick) {
        PhysicsState state = this.physicsStates.get(location);
        if (state == null) {
            return 1.0f;
        }
        // Interpolate using a cosine curve
        return cosineInterpolate(state.previousScaleY, state.hamsterScaleY, partialTick);
    }

    /**
     * Interpolates between two values using a cosine curve for smooth easing.
     *
     * @param start The starting value.
     * @param end   The target value.
     * @param delta The fraction of the way to interpolate (0.0 to 1.0).
     * @return The interpolated value.
     */
    private float cosineInterpolate(float start, float end, float delta) {
        float transition = (1.0f - (float)Math.cos(delta * Math.PI)) * 0.5f;
        return start + transition * (end - start);
    }

    /**
     * Gets the current animation state for a specific shoulder location.
     *
     * @param location The shoulder location.
     * @return The ShoulderHamsterState, or null if no pet is in that slot.
     */
    @Nullable
    public ShoulderHamsterState getHamsterState(ShoulderLocation location) {
        return this.hamsterStates.get(location);
    }

    /**
     * Gets the unique, persistent animation age for a specific shoulder location.
     *
     * @param location The shoulder location.
     * @return The animation age for that slot.
     */
    public int getAnimationAge(ShoulderLocation location) {
        return this.animationAges.getOrDefault(location, 0);
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/screen/`
`HamsterInventoryScreen.java`
```java
package net.dawson.adorablehamsterpets.screen;

// (Imports omitted to save token count)

public class HamsterInventoryScreen extends HandledScreen<HamsterInventoryScreenHandler> {
    // Path to the background texture for the GUI
    private static final Identifier TEXTURE = Identifier.of(AdorableHamsterPets.MOD_ID, "textures/gui/hamster_inventory_gui.png");

    // Store the player entity for easy access
    private final PlayerEntity player;

    public HamsterInventoryScreen(HamsterInventoryScreenHandler handler, PlayerInventory inventory, Text title) {
        super(handler, inventory, title);
        this.player = inventory.player; // Store the player

        // Adjust background height based on texture file
        this.backgroundHeight = 222; // Needs to match texture height

        // Adjust player inventory label Y position based on the new backgroundHeight and layout
        this.playerInventoryTitleY = 139 - 11; // Position it just above the player inventory (Y=139 - approx text height)
    }

    @Override
    protected void init() {
        super.init();
        // Restore default title centering (or adjust as needed for your specific texture)
        this.titleX = (backgroundWidth - textRenderer.getWidth(title)) / 2;
        this.titleY = 6; // Default Y position near the top

        // Set player inventory title position explicitly based on your layout
        this.playerInventoryTitleX = 7;
        // this.playerInventoryTitleY is set in the constructor
    }

    @Override
    protected void drawBackground(DrawContext context, float delta, int mouseX, int mouseY) {
        RenderSystem.setShader(GameRenderer::getPositionTexProgram);
        RenderSystem.setShaderColor(1.0F, 1.0F, 1.0F, 1.0F);
        RenderSystem.setShaderTexture(0, TEXTURE);
        int x = (this.width - this.backgroundWidth) / 2; // Centered X
        int y = (this.height - this.backgroundHeight) / 2; // Centered Y
        // Draw the background texture
        context.drawTexture(TEXTURE, x, y, 0, 0, this.backgroundWidth, this.backgroundHeight);
    }

    @Override
    public void render(DrawContext context, int mouseX, int mouseY, float delta) {
        // Render the background and slots
        super.render(context, mouseX, mouseY, delta);

        // --- Draw the Hamster Entity ---
        int boxX = this.x + 34;
        int boxY = this.y + 55;
        int size = 60;

        // Get the entity instance directly from the handler
        HamsterEntity hamster = this.handler.getHamsterEntity();

        if (hamster != null) {
            // Call the static helper method with the 1.20.1 signature
            InventoryScreen.drawEntity(
                    context,
                    boxX,
                    boxY,
                    size,
                    (float)boxX - mouseX, // x-rotation based on mouse
                    (float)boxY - 30 - mouseY, // y-rotation based on mouse
                    hamster // Pass the entity instance
            );
        }
        // Draw tooltips last
        drawMouseoverTooltip(context, mouseX, mouseY);
    }

    @Override
    protected void drawForeground(DrawContext context, int mouseX, int mouseY) {
        // Restore drawing the screen title using default positioning fields
        context.drawText(this.textRenderer, this.title, this.titleX, this.titleY, 4210752, false);

        // Draw the player inventory title (remains standard)
        context.drawText(this.textRenderer, this.playerInventoryTitle, this.playerInventoryTitleX, this.playerInventoryTitleY, 4210752, false);

        // --- "Left Cheek" and "Right Cheek" Text ---
        Text customTextLeft = Text.translatable("entity.adorablehamsterpets.hamster.inventory_left_cheek_title");
        int customTextLeftX = 25;
        int customTextLeftY = 80;
        context.drawText(this.textRenderer, customTextLeft, customTextLeftX, customTextLeftY, 4210752, false);

        Text customTextRight = Text.translatable("entity.adorablehamsterpets.hamster.inventory_right_cheek_title");
        int customTextRightX = 95;
        int customTextRightY = 80;
        context.drawText(this.textRenderer, customTextRight, customTextRightX, customTextRightY, 4210752, false);
    }
}
```

`HamsterInventoryScreenHandler.java`
```java
package net.dawson.adorablehamsterpets.screen;

// (Imports omitted to save token count)

/**
 * Manages the inventory screen for a Hamster entity.
 * This screen handler synchronizes the hamster's 6-slot inventory with the client
 * and handles item transfers between the hamster and the player.
 */
public class HamsterInventoryScreenHandler extends ScreenHandler {
    private final Inventory inventory;
    @Nullable
    private final HamsterEntity hamsterEntityInstance;

    /**
     * Constructs the screen handler. This single constructor is used by both the server
     * and the client. On the client, the hamster entity is provided by Architectury's
     * extended menu factory system.
     *
     * @param syncId The synchronization ID for the screen handler.
     * @param playerInventory The player's inventory.
     * @param hamsterEntity The hamster entity whose inventory is being opened. Can be null on the client if the entity isn't found.
     */
    public HamsterInventoryScreenHandler(int syncId, PlayerInventory playerInventory, @Nullable HamsterEntity hamsterEntity) {
        super(ModScreenHandlers.HAMSTER_INVENTORY_SCREEN_HANDLER.get(), syncId);

        if (hamsterEntity != null) {
            this.inventory = hamsterEntity;
            this.hamsterEntityInstance = hamsterEntity;
            checkSize(this.inventory, 6);
        } else {
            // Fallback for client if entity is somehow not found
            AdorableHamsterPets.LOGGER.warn("Could not find HamsterEntity on client, using empty inventory.");
            this.inventory = new SimpleInventory(6);
            this.hamsterEntityInstance = null;
        }

        this.inventory.onOpen(playerInventory.player);
        setupSlots(playerInventory);
    }

    /**
     * Returns the HamsterEntity instance associated with this screen handler.
     * This is used by the client-side screen to know which entity to render.
     *
     * @return The hamster entity instance, or null if not available.
     */
    @Nullable
    public HamsterEntity getHamsterEntity() {
        return this.hamsterEntityInstance;
    }

    /**
     * Sets up the slots for the hamster's inventory and the player's inventory.
     * @param playerInventory The player's inventory.
     */
    private void setupSlots(PlayerInventory playerInventory) {
        // --- Hamster Cheek Pouch Slots ---
        this.addSlot(new HamsterSlot(this.inventory, 0, 26, 95));
        this.addSlot(new HamsterSlot(this.inventory, 1, 44, 95));
        this.addSlot(new HamsterSlot(this.inventory, 2, 62, 95));
        this.addSlot(new Slot(new SimpleInventory(1), 0, 80, 95) { // Visual Gap Slot
            @Override public boolean canInsert(ItemStack stack) { return false; }
            @Override public boolean canTakeItems(PlayerEntity playerEntity) { return false; }
            @Override public boolean isEnabled() { return false; }
        });
        this.addSlot(new HamsterSlot(this.inventory, 3, 98, 95));
        this.addSlot(new HamsterSlot(this.inventory, 4, 116, 95));
        this.addSlot(new HamsterSlot(this.inventory, 5, 134, 95));

        // --- Player Inventory & Hotbar ---
        for (int i = 0; i < 3; ++i) {
            for (int j = 0; j < 9; ++j) {
                this.addSlot(new Slot(playerInventory, j + i * 9 + 9, 8 + j * 18, 140 + i * 18));
            }
        }
        for (int i = 0; i < 9; ++i) {
            this.addSlot(new Slot(playerInventory, i, 8 + i * 18, 198));
        }
    }

    @Override
    public void onSlotClick(int slotIndex, int button, SlotActionType actionType, PlayerEntity player) {
        super.onSlotClick(slotIndex, button, actionType, player);
    }

    @Override
    public boolean canUse(PlayerEntity player) {
        return this.inventory.canPlayerUse(player);
    }

    @Override
    public ItemStack quickMove(PlayerEntity player, int slotIndex) {
        ItemStack itemStack = ItemStack.EMPTY;
        Slot slot = this.slots.get(slotIndex);
        if (slot.hasStack()) {
            ItemStack sourceStack = slot.getStack();
            itemStack = sourceStack.copy();

            int hamsterInvSize = 6;
            int gapSlotIndex = 3;
            int totalHamsterAreaSlots = hamsterInvSize + 1; // Includes the gap slot

            // --- Case 1: Moving FROM Hamster Inventory TO Player ---
            if (slotIndex < totalHamsterAreaSlots && slotIndex != gapSlotIndex) {
                if (!this.insertItem(sourceStack, totalHamsterAreaSlots, this.slots.size(), true)) {
                    return ItemStack.EMPTY;
                }
            }
            // --- Case 2: Moving FROM Player Inventory TO Hamster ---
            else if (slotIndex >= totalHamsterAreaSlots) {
                if (this.hamsterEntityInstance != null && this.hamsterEntityInstance.isItemDisallowed(sourceStack)) {
                    return ItemStack.EMPTY;
                }
                // Try to insert into the hamster's inventory, skipping the gap
                if (!this.insertItem(sourceStack, 0, gapSlotIndex, false) &&
                        !this.insertItem(sourceStack, gapSlotIndex + 1, totalHamsterAreaSlots, false)) {
                    return ItemStack.EMPTY;
                }
            } else {
                return ItemStack.EMPTY; // Clicked the gap slot
            }

            if (sourceStack.isEmpty()) {
                slot.setStack(ItemStack.EMPTY);
            } else {
                slot.markDirty();
            }

            if (sourceStack.getCount() == itemStack.getCount()) {
                return ItemStack.EMPTY;
            }

            slot.onTakeItem(player, sourceStack);
        }

        return itemStack;
    }

    @Override
    public void onClosed(PlayerEntity player) {
        super.onClosed(player);
        this.inventory.onClose(player);
    }
}
```

`HamsterScreenHandlerFactory.java`
```java
package net.dawson.adorablehamsterpets.screen;

// (Imports omitted to save token count)

/**
 * A dedicated factory for creating the Hamster's inventory screen handler.
 * This class separates the screen-opening logic from the HamsterEntity itself,
 * resolving the getDisplayName() conflict between the entity's name and the inventory's title.
 */
public class HamsterScreenHandlerFactory implements ExtendedMenuProvider {
    private final HamsterEntity hamster;

    public HamsterScreenHandlerFactory(HamsterEntity hamster) {
        this.hamster = hamster;
    }

    /**
     * Provides the title for the inventory screen.
     * This is the text that will appear at the top of the GUI.
     */
    @Override
    public Text getDisplayName() {
        return Text.translatable("entity.adorablehamsterpets.hamster.inventory_title");
    }

    /**
     * Creates the server-side instance of the screen handler.
     */
    @Nullable
    @Override
    public ScreenHandler createMenu(int syncId, PlayerInventory playerInventory, PlayerEntity player) {
        return new HamsterInventoryScreenHandler(syncId, playerInventory, this.hamster);
    }

    /**
     * Writes the hamster's entity ID to the network buffer so the client can find it.
     */
    @Override
    public void saveExtraData(PacketByteBuf buf) {
        buf.writeInt(this.hamster.getId());
    }
}
```

`ModScreenHandlers.java`
```java
package net.dawson.adorablehamsterpets.screen;

// (Imports omitted to save token count)

public class ModScreenHandlers {

    // --- 1. DeferredRegister for MenuTypes ---
    public static final DeferredRegister<ScreenHandlerType<?>> SCREEN_HANDLERS =
            DeferredRegister.create(AdorableHamsterPets.MOD_ID, RegistryKeys.SCREEN_HANDLER);

    // --- 2. Register the Extended Menu Type ---
    public static final RegistrySupplier<ScreenHandlerType<HamsterInventoryScreenHandler>> HAMSTER_INVENTORY_SCREEN_HANDLER =
            SCREEN_HANDLERS.register("hamster_inventory", () ->
                    MenuRegistry.ofExtended((syncId, playerInventory, buf) -> {
                        // This is the CLIENT-SIDE factory. It reads the entity ID from the buffer.
                        final int entityId = buf.readInt();
                        final Entity entity = playerInventory.player.getWorld().getEntityById(entityId);
                        // We pass the found entity (or null) to the client-side constructor.
                        // The constructor itself will handle the case where the entity is not a hamster.
                        return new HamsterInventoryScreenHandler(syncId, playerInventory, (HamsterEntity) entity);
                    })
            );

    // --- 3. Main Registration Call ---
    public static void register() {
        SCREEN_HANDLERS.register();
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/screen/slot/`
`HamsterSlot.java`
```java
package net.dawson.adorablehamsterpets.screen.slot;

// (Imports omitted to save token count)

public class HamsterSlot extends Slot {

    public HamsterSlot(Inventory inventory, int index, int x, int y) {
        super(inventory, index, x, y);
    }

    /**
     * Checks if the given ItemStack can be inserted into this slot.
     * Uses the HamsterEntity's disallowed item logic.
     * @param stack The ItemStack to check.
     * @return True if the item is allowed, false otherwise.
     */
    @Override
    public boolean canInsert(ItemStack stack) {
        // --- Description: Check if the item is allowed using the entity's logic ---
        // We need access to the HamsterEntity instance to call the non-static helper.
        // The inventory field of the Slot class holds the inventory it's linked to.
        if (this.inventory instanceof HamsterEntity hamsterEntity) {
            // Call the instance method on the specific hamster entity
            return !hamsterEntity.isItemDisallowed(stack);
        }
        // Fallback: If for some reason the inventory isn't a HamsterEntity (e.g., client-side issue),
        // disallow insertion to be safe. This shouldn't normally happen with the current setup.
        return false;
        // --- End Description ---
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/particles/`
`ModParticles.java`
```java
package net.dawson.adorablehamsterpets.particles;

// (Imports omitted to save token count)

/**
 * Holds all particle type registrations.
 */
public class ModParticles {
    public static final DeferredRegister<ParticleType<?>> PARTICLE_TYPES =
            DeferredRegister.create(AdorableHamsterPets.MOD_ID, RegistryKeys.PARTICLE_TYPE);

    // Map to link each particle type back to its wood variant
    // For 1.20.1, use DefaultParticleType
    public static final Map<WoodVariant, RegistrySupplier<DefaultParticleType>> BEDDING_PARTICLES = new EnumMap<>(WoodVariant.class);

    static {
        for (WoodVariant variant : WoodVariant.values()) {
            String id = "hamster_bedding_" + variant.asString();
            // In 1.20.1, use new DefaultParticleType(false), using an anonymous subclass to bypass the protected constructor
            BEDDING_PARTICLES.put(variant, PARTICLE_TYPES.register(id, () -> new DefaultParticleType(false) {}));
        }
    }

    public static void register() {
        PARTICLE_TYPES.register();
    }

    /**
     * Gets the appropriate particle type for a given wood variant.
     * @param variant The wood variant.
     * @return The corresponding DefaultParticleType.
     */
    public static DefaultParticleType getForVariant(WoodVariant variant) {
        return BEDDING_PARTICLES.getOrDefault(variant, BEDDING_PARTICLES.get(WoodVariant.OAK)).get();
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/particles/common/`
`HamsterBeddingParticleBehavior.java`
```java
package net.dawson.adorablehamsterpets.particles.common;

/**
 * Centralized behavior settings for default hamster_bedding particles.
 * */
public final class HamsterBeddingParticleBehavior {
    private HamsterBeddingParticleBehavior() {}

    // Size (blocks)
    public static final float SIZE_X = 1.0f;
    public static final float SIZE_Y = 1.0f;

    // Lifetime range (ticks)
    public static final int LIFETIME_MIN = 20;
    public static final int LIFETIME_EXTRA = 39;

    // Physics
    public static final float GRAVITY = 0.60f;
    public static final float FRICTION = 0.90f; // i.e., Air resistance
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/accessor/`
`PlayerEntityAccessor.java`
```java
package net.dawson.adorablehamsterpets.accessor;

// (Imports omitted to save token count)

/**
 * Accessor interface to expose custom methods injected into PlayerEntity by PlayerEntityMixin.
 * This allows other parts of the mod to safely call these methods without illegally
 * referencing the mixin class directly.
 */
public interface PlayerEntityAccessor {
    NbtCompound getShoulderHamster(ShoulderLocation location);
    void setShoulderHamster(ShoulderLocation location, NbtCompound nbt);

    boolean hasAnyShoulderHamster();

    int ahp_getLastGoldMessageIndex();
    void ahp_setLastGoldMessageIndex(int index);

    void adorablehamsterpets$dismountShoulderHamster(boolean isThrow);

    default void adorablehamsterpets$dismountShoulderHamster() {
        adorablehamsterpets$dismountShoulderHamster(false);
    }

    void adorablehamsterpets$setRawShoulderData(net.minecraft.nbt.NbtCompound nbt);

    /**
     * Triggers the synchronization of shoulder data to the client.
     * This must be called AFTER the player has fully joined and the connection is established.
     */
    void adorablehamsterpets$syncShoulderData();

    ArrayDeque<ShoulderLocation> adorablehamsterpets$getMountOrderQueue();

    ClientShoulderHamsterData adorablehamsterpets$getClientShoulderData();
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/integration/jade/`
`AHPJadePlugin.java`
```java
package net.dawson.adorablehamsterpets.integration.jade;

// (Imports omitted to save token count)

@WailaPlugin // This annotation marks this class as a Jade plugin
public final class AHPJadePlugin implements IWailaPlugin {

    @Override
    public void registerClient(IWailaClientRegistration registration) {
        // Block components
        registration.registerBlockComponent(WildBushComponentProvider.INSTANCE, WildCucumberBushBlock.class);
        registration.registerBlockComponent(WildBushComponentProvider.INSTANCE, WildGreenBeanBushBlock.class);
        registration.registerBlockComponent(HamsterBedComponentProvider.INSTANCE, HamsterBedBlock.class);
        registration.usePickedResult(ModBlocks.HAMSTER_BED.get());

        // Entity component for Hamster debugging
        registration.registerEntityComponent(HamsterDebugComponentProvider.INSTANCE, HamsterEntity.class);
    }

    @Override
    public void register(IWailaCommonRegistration registration) {
        // Server-side data providers
        registration.registerBlockDataProvider(HamsterBedComponentProvider.INSTANCE, HamsterBedBlockEntity.class);
        registration.registerEntityDataProvider(HamsterDebugComponentProvider.INSTANCE, HamsterEntity.class);
    }
}
```

`HamsterBedComponentProvider.java`
```java
package net.dawson.adorablehamsterpets.integration.jade;

// (Imports omitted to save token count)

public enum HamsterBedComponentProvider implements IBlockComponentProvider, IServerDataProvider<BlockAccessor> {
    INSTANCE;

    private static final Identifier UID = Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_bed_info");

    @Override
    public void appendTooltip(ITooltip tooltip, BlockAccessor accessor, IPluginConfig config) {
        NbtCompound serverData = accessor.getServerData();
        RegistryWrapper.WrapperLookup registryLookup = accessor.getLevel().getRegistryManager();
        PlayerEntity player = accessor.getPlayer();

        if (serverData.contains("LinkedHamsterName")) {
            // --- Linked Bed Tooltip ---
            Text hamsterName = Text.Serializer.fromJson(serverData.getString("LinkedHamsterName"));
            if (hamsterName != null) {
                tooltip.add(Text.translatable("tooltip.adorablehamsterpets.hamster_bed.linked_to", hamsterName).formatted(Formatting.GREEN));
            }

            // Wander Mode Status and Distance
            boolean isWanderActive = serverData.getBoolean("WanderModeActive");
            Text wanderStatus = isWanderActive ? Text.literal("ACTIVE").formatted(Formatting.GREEN) : Text.literal("INACTIVE").formatted(Formatting.RED);
            WanderDistance distance = WanderDistance.valueOf(serverData.getString("WanderDistance").toUpperCase());
            int radius = switch (distance) {
                case NEAR -> Configs.AHP.wanderDistanceNear.get();
                case FAR -> Configs.AHP.wanderDistanceFar.get();
                default -> Configs.AHP.wanderDistanceMedium.get();
            };
            tooltip.add(Text.translatable("tooltip.adorablehamsterpets.jade.wander_status", wanderStatus, distance.asString(), radius));

            if (player.isSneaking()) {
                // --- Expanded Tooltip (Sneaking) ---
                boolean allowSleep = serverData.getBoolean("AllowSleepInBed");
                Text sleepStatus = allowSleep
                        ? Text.literal("TRUE").formatted(Formatting.GREEN)
                        : Text.literal("FALSE").formatted(Formatting.RED);
                tooltip.add(Text.translatable("tooltip.adorablehamsterpets.jade.sleep_status", sleepStatus));
                tooltip.add(Text.translatable("tooltip.adorablehamsterpets.jade.wander_controls").formatted(Formatting.GRAY));
                tooltip.add(Text.translatable("tooltip.adorablehamsterpets.jade.lure_hint").formatted(Formatting.GRAY));
                tooltip.add(Text.translatable("tooltip.adorablehamsterpets.jade.repellent_hint").formatted(Formatting.GRAY));
                tooltip.add(Text.translatable("tooltip.adorablehamsterpets.jade.unlink_hint").formatted(Formatting.GRAY));
            } else {
                // --- Default (Condensed) Tooltip ---
                tooltip.add(Text.translatable("tooltip.adorablehamsterpets.sneak_for_info").formatted(Formatting.GRAY));
            }

        } else {
            // --- Unlinked Bed Tooltip (shows regardless of sneak) ---
            tooltip.add(Text.translatable("tooltip.adorablehamsterpets.jade.unlinked").formatted(Formatting.GOLD));
        }
    }

    @Override
    public void appendServerData(NbtCompound data, BlockAccessor accessor) {
        BlockEntity blockEntity = accessor.getBlockEntity();
        if (blockEntity instanceof HamsterBedBlockEntity bedEntity) {
            if (accessor.getPlayer() instanceof ServerPlayerEntity player) {
                ServerWorld serverWorld = player.getServerWorld();

                // Dynamic Name Resolution
                Optional<Text> liveName = bedEntity.getLinkedHamsterUuid()
                        .map(serverWorld::getEntity)
                        .filter(e -> e instanceof HamsterEntity)
                        .map(entity -> {
                            HamsterEntity hamster = (HamsterEntity) entity;
                            if (hamster.hasCustomName()) {
                                return hamster.getName();
                            } else {
                                // Use getDisplayName() to respect the "Hampter" config and append the ID
                                return hamster.getDisplayName().copy().append(" " + hamster.getId());
                            }
                        });

                // Use the live name if found; otherwise, fall back to the name stored in the BlockEntity.
                Text nameToShow = liveName.or(bedEntity::getLinkedHamsterName).orElse(null);

                if (nameToShow != null) {
                    data.putString("LinkedHamsterName", Text.Serializer.toJson(nameToShow));
                }
            }

            data.putBoolean("WanderModeActive", bedEntity.isWanderModeActive());
            data.putString("WanderDistance", bedEntity.getWanderDistance().asString());
            data.putBoolean("AllowSleepInBed", bedEntity.isSleepingAllowed());
        }
    }

    @Override
    public Identifier getUid() {
        return UID;
    }
}
```

`HamsterDebugComponentProvider.java`
```java
package net.dawson.adorablehamsterpets.integration.jade;

// (Imports omitted to save token count)

public enum HamsterDebugComponentProvider implements IEntityComponentProvider, IServerDataProvider<EntityAccessor> {
    INSTANCE;

    private static final Identifier UID = Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_debug_info");

    @Override
    public void appendTooltip(ITooltip tooltip, EntityAccessor accessor, IPluginConfig config) {
        if (!Configs.AHP.enableJadeHamsterDebugInfo) {
            return;
        }

        Entity entity = accessor.getEntity();
        if (!(entity instanceof HamsterEntity hamster)) {
            return;
        }

        // --- Animation State ---
        tooltip.add(Text.literal("--- Current Animation ---").formatted(Formatting.GRAY));
        AnimationController<?> controller = hamster.getAnimatableInstanceCache().getManagerForId(hamster.getId()).getAnimationControllers().get("mainController");
        if (controller != null) {
            // Get the currently playing animation object from the controller
            AnimationProcessor.QueuedAnimation currentAnim = controller.getCurrentAnimation();

            if (currentAnim != null) {
                // Get the name from the animation record itself
                tooltip.add(fText("Current Anim: %s", Text.literal(currentAnim.animation().name()).formatted(Formatting.AQUA)));
            } else {
                tooltip.add(fText("Current Anim: %s", Text.literal("None").formatted(Formatting.GRAY)));
            }
        }

        // --- AI Goal & Action States ---
        tooltip.add(Text.literal("--- AI & Action States ---").formatted(Formatting.GRAY));
        tooltip.add(fText("Sitting (Command): %s", (hamster.isSitting() ? Text.literal("true").formatted(Formatting.GREEN) : Text.literal("false").formatted(Formatting.RED))));
        tooltip.add(fText("Sitting (Vanilla Pose): %s", (hamster.isInSittingPose() ? Text.literal("true").formatted(Formatting.GREEN) : Text.literal("false").formatted(Formatting.RED))));
        tooltip.add(fText("Sleeping (Wild/General): %s", (hamster.isSleeping() ? Text.literal("true").formatted(Formatting.GREEN) : Text.literal("false").formatted(Formatting.RED))));
        tooltip.add(fText("Cleaning: %s", (hamster.isCleaning() ? Text.literal("true").formatted(Formatting.GREEN) : Text.literal("false").formatted(Formatting.RED))));

        if (hamster.isKnockedOut()) {
            tooltip.add(fText("State: %s", Text.literal("Knocked Out").formatted(Formatting.RED, Formatting.BOLD)));
        } else if (hamster.isThrown()) {
            tooltip.add(fText("State: %s", Text.literal("Thrown").formatted(Formatting.AQUA)));
        } else if (hamster.isSulking()) {
            tooltip.add(fText("State: %s", Text.literal("Sulking").formatted(Formatting.DARK_PURPLE, Formatting.BOLD)));
        } else if (hamster.isCelebratingDiamond()) {
            tooltip.add(fText("State: %s", Text.literal("Celebrating Diamond").formatted(Formatting.AQUA, Formatting.BOLD)));
        }

        tooltip.add(fText("Is Navigating: %s", (!hamster.getNavigation().isIdle() ? Text.literal("true").formatted(Formatting.GREEN) : Text.literal("false").formatted(Formatting.RED)) ));
        LivingEntity target = hamster.getTarget();
        tooltip.add(fText("Has Target: %s", (target != null ? Text.literal("true").formatted(Formatting.GREEN) : Text.literal("false").formatted(Formatting.RED))));
        if (target != null) {
            tooltip.add(fText("  Target: %s", Text.literal(target.getName().getString()).formatted(Formatting.WHITE)));
        }
        String activeGoalName = hamster.getActiveCustomGoalDebugName();
        tooltip.add(fText("Current Custom Goal: %s", Text.literal(activeGoalName).formatted(activeGoalName.equals("None") ? Formatting.GRAY : Formatting.AQUA)));

        // --- Bed Link Status ---
        tooltip.add(Text.literal("--- Bed Link ---").formatted(Formatting.GRAY));
        NbtCompound serverData = accessor.getServerData();
        boolean isWanderActive = serverData.getBoolean("IsWanderModeActive");
        boolean isOnTheWayToBed = serverData.getBoolean("IsOnTheWayToBed");
        int goToBedDelay = serverData.getInt("GoToBedDelay");

        // Display wander mode status
        tooltip.add(fText("Wander Mode: %s", isWanderActive ? Text.literal("ACTIVE").formatted(Formatting.GREEN) : Text.literal("INACTIVE").formatted(Formatting.RED)));

        // If wandering, show distance. If pathfinding to bed, show that instead.
        if (isWanderActive) {
            if (isOnTheWayToBed) {
                if (goToBedDelay > 0) {
                    tooltip.add(fText("  Status: %s", Text.literal(String.format("Waiting... (starts in %.1f s)", goToBedDelay / 20.0)).formatted(Formatting.YELLOW)));
                } else {
                    tooltip.add(fText("  Status: %s", Text.literal("Pathfinding to bed...").formatted(Formatting.YELLOW)));
                }
            } else if (serverData.contains("WanderDistance")) {
                String distanceStr = serverData.getString("WanderDistance");
                tooltip.add(fText("  Wander Distance: %s", Text.literal(distanceStr).formatted(Formatting.AQUA)));
            }
        }

        // --- Tamed Sleep Sequence ---
        if (hamster.isTamed()) {
            tooltip.add(Text.literal("--- Tamed Sleep Sequence ---").formatted(Formatting.GRAY));
            HamsterEntity.DozingPhase phase = hamster.getDozingPhase();
            tooltip.add(fText("Dozing Phase: %s", Text.literal(phase.name()).formatted(phase != HamsterEntity.DozingPhase.NONE ? Formatting.AQUA : Formatting.WHITE)));
            if (phase == HamsterEntity.DozingPhase.DEEP_SLEEP || phase == HamsterEntity.DozingPhase.SETTLING_INTO_SLUMBER) {
                tooltip.add(fText("  Deep Sleep Anim: %s", Text.literal(hamster.getCurrentDeepSleepAnimationIdFromTracker()).formatted(Formatting.AQUA)));
            }
        }

        // --- Ore Seeking States  ---
        tooltip.add(Text.literal("--- Ore Seeking ---").formatted(Formatting.GRAY));
        tooltip.add(fText("Primed to Seek: %s", hamster.isPrimedToSeekDiamonds ? Text.literal("true").formatted(Formatting.GREEN) : Text.literal("false").formatted(Formatting.RED)));
        if (hamster.currentOreTarget != null) {
            tooltip.add(fText("  Current Ore Target: %s", Text.literal(hamster.currentOreTarget.toString()).formatted(Formatting.AQUA)));
        } else {
            tooltip.add(fText("  Current Ore Target: %s", Text.literal("None").formatted(Formatting.GRAY)));
        }
        long foundOreCooldown = hamster.foundOreCooldownEndTick - hamster.getWorld().getTime();
        if (Configs.AHP.enableIndependentDiamondSeekCooldown && foundOreCooldown > 0) {
            tooltip.add(fText("  Found Ore Cooldown: %s sec", Text.literal(String.format("%.1f", foundOreCooldown / 20.0)).formatted(Formatting.YELLOW)));
        } else if (Configs.AHP.enableIndependentDiamondSeekCooldown) {
            tooltip.add(fText("  Found Ore Cooldown: %s", Text.literal("Ready").formatted(Formatting.GREEN)));
        } else {
            tooltip.add(fText("  Found Ore Cooldown: %s", Text.literal("Disabled").formatted(Formatting.GRAY)));
        }

        // --- Diamond Stealing States ---
        tooltip.add(Text.literal("--- Diamond Stealing ---").formatted(Formatting.GRAY));
        tooltip.add(fText("Is Stealing: %s", hamster.isStealingDiamond() ? Text.literal("true").formatted(Formatting.GREEN) : Text.literal("false").formatted(Formatting.RED)));
        if (hamster.isStealingDiamond()) {
            int remainingTicks = hamster.getStealDurationTimer();
            tooltip.add(fText("  Time Remaining: %s sec", Text.literal(String.format("%.1f", remainingTicks / 20.0)).formatted(Formatting.YELLOW)));
        }

        // --- Love & Interaction States ---
        tooltip.add(Text.literal("--- Love & Interaction ---").formatted(Formatting.GRAY));
        tooltip.add(fText("Begging: %s", (hamster.isBegging() ? Text.literal("true").formatted(Formatting.GREEN) : Text.literal("false").formatted(Formatting.RED))));
        tooltip.add(fText("Refusing Food: %s", (hamster.isRefusingFood() ? Text.literal("true").formatted(Formatting.GREEN) : Text.literal("false").formatted(Formatting.RED))));
        boolean inLoveDataTracker = hamster.isInLove(); // Checks DataTracker IS_IN_LOVE
        boolean inLoveCustomTimer = hamster.customLoveTimer > 0; // Checks the breeding timer directly
        tooltip.add(fText("In Love (Tracker): %s", (inLoveDataTracker ? Text.literal("true").formatted(Formatting.GREEN) : Text.literal("false").formatted(Formatting.RED))));
        tooltip.add(fText("In Love (Timer): %s (%d ticks)", (inLoveCustomTimer ? Text.literal("true").formatted(Formatting.GREEN) : Text.literal("false").formatted(Formatting.RED)), hamster.customLoveTimer));

        // --- General Info ---
        tooltip.add(Text.literal("--- General Info ---").formatted(Formatting.GRAY));
        tooltip.add(fText("Tamed: %s", hamster.isTamed() ? Text.literal("Yes").formatted(Formatting.GREEN) : Text.literal("No").formatted(Formatting.RED)));
        if (hamster.isTamed() && hamster.getOwner() != null) {
            tooltip.add(fText("  Owner: %s", Text.literal(hamster.getOwner().getName().getString()).formatted(Formatting.WHITE)));
        }
        tooltip.add(fText("Variant: %s (ID: %d)", Text.literal(hamster.getVariantEnum().name()).formatted(Formatting.AQUA), hamster.getVariant()));
        tooltip.add(fText("Age: %s", hamster.isBaby() ? Text.literal("Baby").formatted(Formatting.AQUA) : Text.literal("Adult").formatted(Formatting.WHITE)));
    }

    @Override
    public Identifier getUid() {
        return UID;
    }

    @Override
    public void appendServerData(NbtCompound data, EntityAccessor accessor) {
        Entity entity = accessor.getEntity();
        if (entity instanceof HamsterEntity hamster) {
            data.putBoolean("IsWanderModeActive", hamster.isWanderModeActive());
            data.putBoolean("IsOnTheWayToBed", hamster.isOnTheWayToBed());
            data.putInt("GoToBedDelay", hamster.getGoToBedDelayTicks());

            if (hamster.isWanderModeActive()) {
                hamster.getLinkedBedPos().ifPresent(globalPos -> {
                    World world = hamster.getWorld();
                    if (world instanceof ServerWorld serverWorld && serverWorld.getRegistryKey() == globalPos.getDimension()) {
                        if (serverWorld.getBlockEntity(globalPos.getPos()) instanceof HamsterBedBlockEntity bedEntity) {
                            data.putString("WanderDistance", bedEntity.getWanderDistance().asString());
                        }
                    }
                });
            }
        }
    }

    // Helper for formatted text
    private Text fText(String format, Object... args) {
        Text[] formattedArgs = new Text[args.length];
        for (int i = 0; i < args.length; i++) {
            if (args[i] instanceof Text textComponent) {
                formattedArgs[i] = textComponent;
            } else {
                formattedArgs[i] = Text.literal(String.valueOf(args[i])).formatted(Formatting.WHITE);
            }
        }
        MutableText result = Text.empty();
        String[] parts = format.split("%s", -1);
        for (int i = 0; i < parts.length; i++) {
            result.append(Text.literal(parts[i]).formatted(Formatting.GOLD));
            if (i < formattedArgs.length) {
                result.append(formattedArgs[i]);
            }
        }
        return result;
    }
}
```

`WildBushComponentProvider.java`
```java
package net.dawson.adorablehamsterpets.integration.jade;

// (Imports omitted to save token count)

public enum WildBushComponentProvider implements IBlockComponentProvider {
    INSTANCE; // Singleton instance

    // A unique identifier for this tooltip provider.
    // Used by Jade for configuration and internal tracking.
    private static final Identifier UID = Identifier.of(AdorableHamsterPets.MOD_ID, "wild_bush_tooltips");

    @Override
    public void appendTooltip(ITooltip tooltip, BlockAccessor accessor, IPluginConfig config) {
        // This method is called by Jade when the player looks at a block
        // that this provider is registered for.

        // Check if the block being looked at is a WildCucumberBushBlock
        if (accessor.getBlock() instanceof WildCucumberBushBlock) {
            // Add the same tooltip lines as your item
            tooltip.add(Text.translatable("block.adorablehamsterpets.wild_cucumber_bush.hint1").formatted(Formatting.YELLOW));
            tooltip.add(Text.translatable("block.adorablehamsterpets.wild_cucumber_bush.hint2").formatted(Formatting.GRAY));
        }
        // Check if the block being looked at is a WildGreenBeanBushBlock
        else if (accessor.getBlock() instanceof WildGreenBeanBushBlock) {
            // Add the same tooltip lines as your item
            tooltip.add(Text.translatable("block.adorablehamsterpets.wild_green_bean_bush.hint1").formatted(Formatting.YELLOW));
            tooltip.add(Text.translatable("block.adorablehamsterpets.wild_green_bean_bush.hint2").formatted(Formatting.GRAY));
        }
    }

    @Override
    public Identifier getUid() {
        return UID; // Return the unique ID for this provider
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/integration/patchouli/`
`OpenConfigComponent.java`
```java
package net.dawson.adorablehamsterpets.integration.patchouli;

// (Imports omitted to save token count)

/**
 * Draws a clickable “Open Config” label in a Patchouli page and uses Fzzy‑Config
 * to open the Adorable Hamster Pets config.
 */
public class OpenConfigComponent implements ICustomComponent {
    private static final Text LABEL = Text.translatable(
            "book.adorablehamsterpets.entry.config_heaven.page2.link_text");

    private transient ButtonWidget button; // created on first display
    private transient boolean added; // tracks whether the widget is in the GUI
    private int pageIndex;

    // Patchouli gives the page index here, so storing it for addWidget(...)
    @Override
    public void build(int componentX, int componentY, int pageNum) {
        this.pageIndex = pageNum;
        this.added = false;
    }

    @Override
    public void onDisplayed(IComponentRenderContext ctx) {
        // When the page becomes visible, force a fresh widget next frame.
        button = null;
        added = false;
    }

    @Override
    public void render(DrawContext gfx, IComponentRenderContext ctx,
                       float pt, int mouseX, int mouseY) {
        if (button == null) {
            button = ButtonWidget.builder(
                            LABEL,
                            b -> {
                                added = false;
                                // Open Config
                                ConfigApiJava.INSTANCE.openScreen("adorablehamsterpets");
                            }
                    )
                    // Template needs a slightly lower baseline than PageText’s 121
                    .position(8, 136)
                    .size(100, 20)
                    .build();
        }
        if (!added) {
            ctx.addWidget(button, pageIndex); // anchor to the correct page
            added = true;
        }
    }

    @Override
    public void onVariablesAvailable(UnaryOperator<IVariable> lookup) {
        // Not using Patchouli template variables here, so nothing to do.
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/mixin/accessor/`
`BookContentsBuilderAccessor.java`
```java
package net.dawson.adorablehamsterpets.mixin.accessor;

// (Imports omitted to save token count)

@Mixin(value = BookContentsBuilder.class, remap = false)
public interface BookContentsBuilderAccessor {
    @Accessor("book")
    Book getBook();

    @Accessor("categories")
    Map<Identifier, BookCategory> getCategories();

    @Accessor("entries")
    Map<Identifier, BookEntry> getEntries();
}
```

`FollowOwnerGoalAccessor.java`
```java
package net.dawson.adorablehamsterpets.mixin.accessor;

// (Imports omitted to save token count)

@Mixin(FollowOwnerGoal.class)
public interface FollowOwnerGoalAccessor {

    @Accessor("owner")
    LivingEntity getOwner();

    @Accessor("minDistance")
    float getMinDistance();

    @Accessor("maxDistance")
    float getMaxDistance();

    @Accessor("speed")
    double getSpeed();

    @Accessor("updateCountdownTicks")
    int getUpdateCountdownTicks();

    @Accessor("updateCountdownTicks")
    void setUpdateCountdownTicks(int value);
}
```

`LandPathNodeMakerInvoker.java`
```java
package net.dawson.adorablehamsterpets.mixin.accessor;

// (Imports omitted to save token count)

/**
 * Invoker interface to grant access to the protected static method
 * {@code getCommonNodeType} in {@link LandPathNodeMaker}.
 * This allows the use of vanilla's internal logic for determining a block's
 * pathfinding type without altering any vanilla code.
 */
@Mixin(LandPathNodeMaker.class)
public interface LandPathNodeMakerInvoker {

    /**
     * Invokes the protected static method {@code getCommonNodeType}.
     * @param world The world view.
     * @param pos The position to check.
     * @return The determined PathNodeType.
     */
    @Invoker("getCommonNodeType")
    static PathNodeType callGetCommonNodeType(BlockView world, BlockPos pos) {
        // This is a Mixin Invoker; the body is empty and will be implemented at runtime.
        throw new AssertionError();
    }
}
```

`LookAroundGoalAccessor.java`
```java
package net.dawson.adorablehamsterpets.mixin.accessor;

// (Imports omitted to save token count)

@Mixin(LookAroundGoal.class)
public interface LookAroundGoalAccessor {
    @Accessor("mob")
    MobEntity getMob();

    @Accessor("deltaX")
    double getDeltaX();

    @Accessor("deltaZ")
    double getDeltaZ();

    @Accessor("lookTime")
    int getLookTime();

    @Accessor("lookTime")
    void setLookTime(int lookTime);
}
```

`LookAtEntityGoalAccessor.java`
```java
package net.dawson.adorablehamsterpets.mixin.accessor;

// (Imports omitted to save token count)

@Mixin(LookAtEntityGoal.class)
public interface LookAtEntityGoalAccessor {
    @Accessor("target")
    Entity getTarget();

    @Accessor("lookTime")
    int getLookTime();

    @Accessor("lookTime")
    void setLookTime(int lookTime);

    @Accessor("lookForward")
    boolean getLookForward();
}
```

`MeleeAttackGoalAccessor.java`
```java
package net.dawson.adorablehamsterpets.mixin.accessor;


// (Imports omitted to save token count)

/**
 * Accessor interface to expose the protected 'cooldown' field from MeleeAttackGoal.
 * This allows us to set the cooldown from our custom goal class in a cross-platform way.
 */
@Mixin(MeleeAttackGoal.class)
public interface MeleeAttackGoalAccessor {
    /**
     * Provides write access to the cooldown field in MeleeAttackGoal.
     * @param cooldown The new value for the cooldown timer.
     */
    @Accessor("cooldown")
    void setCooldown(int cooldown);
}
```

`ScreenWidgetAdder.java`
```java
package net.dawson.adorablehamsterpets.mixin.accessor;

// (Imports omitted to save token count)

/**
 * Provides a cross-loader way to call Screen#addDrawableChild (Fabric/Yarn) or
 * Screen#addRenderableWidget (Forge/Mojang). The method name is remapped by
 * Architectury when building for each loader.
 */
@Mixin(Screen.class)
public interface ScreenWidgetAdder {
    @Invoker("addDrawableChild")
    <T extends Element & Drawable & Selectable> T adorablehamsterpets$addWidget(T widget);
}
```

`SlotAccessor.java`
```java
package net.dawson.adorablehamsterpets.mixin.accessor;

// (Imports omitted to save token count)

/**
 * Provides safe, cross-loader access to the inventory/container field within a Slot.
 * The Architectury remapper will automatically change the target of the "inventory" accessor
 * to "container" when building for the Forge platform.
 */
@Mixin(Slot.class)
public interface SlotAccessor {
    /**
     * Gets the inventory associated with this slot.
     * @return The slot's inventory.
     */
    @Accessor("inventory")
    Inventory adorablehamsterpets$getInventory();
}
```

`TemptGoalAccessor.java`
```java
package net.dawson.adorablehamsterpets.mixin.accessor;

// (Imports omitted to save token count)

@Mixin(TemptGoal.class)
public interface TemptGoalAccessor {
    @Accessor("cooldown")
    int getCooldown();

    @Accessor("cooldown")
    void setCooldown(int cooldown);
}
```

`ValidatedFieldAccessor.java`
```java
package net.dawson.adorablehamsterpets.mixin.accessor;

// (Imports omitted to save token count)

@Mixin(value = ValidatedField.class, remap = false)
public interface ValidatedFieldAccessor<T> {

    /**
     * Invokes the protected 'set' method on a ValidatedField.
     * @param value The new value to set.
     */
    @Invoker("set")
    void adorablehamsterpets$set(T value);
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/mixin/client/`
`AbstractClientPlayerEntityMixin.java`
```java
package net.dawson.adorablehamsterpets.mixin.client;

// (Imports omitted to save token count)

@Mixin(AbstractClientPlayerEntity.class)
public abstract class AbstractClientPlayerEntityMixin {

    /**
     * Injects into the end of the player's tick method on the client.
     * This ensures that the animation state for any shoulder-mounted hamsters is updated
     * for ALL player entities on the client, including the local player, remote players,
     * and playback actors from mods like Flashback.
     */
    @Inject(method = "tick", at = @At("TAIL"))
    private void adorablehamsterpets$onTick(CallbackInfo ci) {
        AbstractClientPlayerEntity thisPlayer = (AbstractClientPlayerEntity) (Object) this;
        // The tick method can be called on the integrated server thread, so we must check.
        if (thisPlayer.getWorld().isClient) {
            ClientShoulderHamsterData clientData = ((PlayerEntityAccessor) thisPlayer).adorablehamsterpets$getClientShoulderData();
            if (clientData != null) {
                clientData.clientTick(thisPlayer);
            }
        }
    }
}
```

`BookContentsBuilderMixin.java`
```java
package net.dawson.adorablehamsterpets.mixin.client;

// (Imports omitted to save token count)

/**
 * Mixin to inject virtual, dynamically-loaded announcement categories and entries
 * into the Hamster Tips guide book.
 * <p>
 * Requires careful interaction with Patchouli's internal book-building lifecycle.
 * The injection happens at the HEAD of the `build` method to ensure my virtual
 * content is present before Patchouli finalizes its data structures into
 * immutable maps for the GUI.
 */
@Mixin(value = BookContentsBuilder.class, remap = false)
public class BookContentsBuilderMixin {

    /**
     * Injects virtual content at the beginning of the book-building process.
     * The sequence of operations is critical:
     * 1. Create virtual categories and add them to the builder's master map.
     * 2. Create virtual entries.
     * 3. Link each entry to its parent category using {@link BookEntry#initCategory}. This is the
     *    step that populates the category's internal list of entries.
     * 4. Add the linked entries to the builder's master map.
     * 5. Build the entries to process their (empty) pages.
     * 6. Build the categories to resolve their parentage and call {@link BookCategory#updateLockStatus}
     *    to ensure they are visible in the GUI.
     *
     * @param level The world instance, required by the build methods.
     * @param cir   The mixin callback info.
     */
    @Inject(method = "build", at = @At("HEAD"))
    private void adorablehamsterpets$onBuild(World level, CallbackInfoReturnable<BookContents> cir) {
        // --- 1. Initial Setup & Safety Check ---
        BookContentsBuilderAccessor accessor = (BookContentsBuilderAccessor) this;
        Book hamsterBook = accessor.getBook();

        // Only modify the Hamster Tips guide book
        if (hamsterBook == null || !hamsterBook.id.equals(Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_tips_guide_book"))) {
            return;
        }

        AdorableHamsterPets.LOGGER.debug("[AHP Mixin] Found target book. Starting virtual content injection.");

        // --- 2. Get mutable maps from the builder ---
        // Inject at HEAD to ensure these maps are still mutable HashMaps.
        Map<Identifier, BookCategory> categories = accessor.getCategories();
        Map<Identifier, BookEntry> entries = accessor.getEntries();
        AdorableHamsterPets.LOGGER.debug("[AHP Mixin] Before injection: {} categories, {} entries.", categories.size(), entries.size());

        // --- 3. Create and Add Virtual Categories to the Master Map ---
        // Categories must exist in the master map *before* entries try to link to them.
        Identifier updatesId = Identifier.of(AdorableHamsterPets.MOD_ID, "update_notes");
        if (!categories.containsKey(updatesId)) {
            BookCategory updatesCategory = createVirtualCategory(hamsterBook, "book.adorablehamsterpets.category.update_notes", "minecraft:writable_book", 99, updatesId);
            categories.put(updatesId, updatesCategory);
        }

        Identifier announcementsId = Identifier.of(AdorableHamsterPets.MOD_ID, "announcements");
        if (!categories.containsKey(announcementsId)) {
            BookCategory announcementsCategory = createVirtualCategory(hamsterBook, "book.adorablehamsterpets.category.announcements", "adorablehamsterpets:announcement_bell_icon", 98, announcementsId);
            categories.put(announcementsId, announcementsCategory);
        }

        // --- 4. Create, Link, and Build Virtual Entries ---
        BookContentsBuilder self = (BookContentsBuilder)(Object)this;
        List<Announcement> allMessages = AnnouncementManager.INSTANCE.getAllManifestMessages();

        allMessages.stream()
                .sorted(Comparator.comparing(Announcement::published, Comparator.reverseOrder()))
                .forEach(announcement -> {
                    Identifier entryId = Identifier.of(AdorableHamsterPets.MOD_ID, "announcement_" + announcement.id());

                    // Do not re-process an entry if it's already in the map.
                    if (!entries.containsKey(entryId)) {
                        AdorableHamsterPets.LOGGER.debug("[AHP Mixin] -> Creating virtual entry '{}'", entryId);
                        boolean isUpdate = "update".equals(announcement.kind());
                        Identifier categoryId = isUpdate ? updatesId : announcementsId;
                        String icon = isUpdate ? "minecraft:writable_book" : "adorablehamsterpets:announcement_bell_icon";

                        BookEntry entry = createVirtualEntry(hamsterBook, announcement.title(), icon, isUpdate, categoryId, entryId);

                        // Critical Step: Link the entry to its category.
                        // This calls `category.addEntry()` internally, populating the category's own list.
                        // I provide `categories::get` as a lookup function for the entry to find its parent.
                        entry.initCategory(entryId, categories::get);

                        // Add the now-linked entry to the book's master map.
                        entries.put(entryId, entry);

                        // Build the entry to process its pages and other properties.
                        try {
                            entry.build(level, self);
                        } catch (Exception e) {
                            AdorableHamsterPets.LOGGER.error("[AHP Mixin] Failed to build virtual entry {}", entryId, e);
                        }
                    }
                });

        // --- 5. Build and Finalize Virtual Categories ---
        // This must be done AFTER all entries have been created and linked.
        if (categories.containsKey(updatesId)) {
            BookCategory cat = categories.get(updatesId);
            cat.build(self); // Resolves parentage (important for root categories).
            cat.updateLockStatus(true); // Initializes lock state to ensure it's not hidden.
            AdorableHamsterPets.LOGGER.debug("[AHP Mixin] Built 'update_notes' category with {} entries.", cat.getEntries().size());
        }
        if (categories.containsKey(announcementsId)) {
            BookCategory cat = categories.get(announcementsId);
            cat.build(self);
            cat.updateLockStatus(true);
            AdorableHamsterPets.LOGGER.debug("[AHP Mixin] Built 'announcements' category with {} entries.", cat.getEntries().size());
        }

        AdorableHamsterPets.LOGGER.debug("[AHP Mixin] After injection: {} categories, {} entries.", categories.size(), entries.size());
    }

    /**
     * Helper method to construct a virtual {@link BookCategory} from a JSON definition.
     *
     * @param book The parent book object.
     * @param nameKey The translation key for the category's name.
     * @param icon The resource location string for the category's icon.
     * @param sortnum The sorting number for ordering.
     * @param id The unique identifier for the category.
     * @return A new {@code BookCategory} instance.
     */
    private BookCategory createVirtualCategory(Book book, String nameKey, String icon, int sortnum, Identifier id) {
        JsonObject json = new JsonObject();
        json.addProperty("name", nameKey);
        json.addProperty("description", nameKey + ".desc");
        json.addProperty("icon", icon);
        json.addProperty("sortnum", sortnum);
        // Critical: An empty "parent" string designates this as a root category, making it appear on the landing page.
        json.addProperty("parent", "");
        return new BookCategory(json, id, book);
    }

    /**
     * Helper method to construct a virtual {@link BookEntry} from a JSON definition.
     *
     * @param book The parent book object.
     * @param name The display name of the entry.
     * @param icon The resource location string for the entry's icon.
     * @param priority Whether the entry should have a priority flag (star icon).
     * @param categoryId The ID of the parent category.
     * @param entryId The unique identifier for the entry.
     * @return A new {@code BookEntry} instance.
     */
    private BookEntry createVirtualEntry(Book book, String name, String icon, boolean priority, Identifier categoryId, Identifier entryId) {
        JsonObject json = new JsonObject();
        json.addProperty("name", name);
        json.addProperty("icon", icon);
        json.addProperty("priority", priority);
        json.addProperty("category", categoryId.toString());
        // The pages array is empty because I'm intercepting the click event to show my own GUI.
        json.add("pages", new JsonArray());
        return new BookEntry(json, entryId, book, AdorableHamsterPets.MOD_ID);
    }
}
```

`BookContentsMixin.java`
```java
package net.dawson.adorablehamsterpets.mixin.client;

// (Imports omitted to save token count)

@Mixin(value = BookContents.class, remap = false)
public class BookContentsMixin {

    @Inject(method = "openLexiconGui", at = @At("HEAD"), cancellable = true)
    private void adorablehamsterpets$onOpenLexiconGui(GuiBook gui, boolean push, CallbackInfo ci) {
        if (gui instanceof GuiBookEntry entryGui) {
            Identifier entryId = entryGui.getEntry().getId();
            if (entryId.getNamespace().equals(AdorableHamsterPets.MOD_ID) && entryId.getPath().startsWith("announcement_")) {
                String announcementId = entryId.getPath().substring("announcement_".length());

                Announcement announcement = AnnouncementManager.INSTANCE.getAnnouncementById(announcementId);

                if (announcement != null) {
                    // Use the canonical method to get a stable, context-independent reason.
                    String reason = AnnouncementManager.INSTANCE.getCanonicalReasonForAnnouncement(announcementId);

                    Screen parentScreen = MinecraftClient.getInstance().currentScreen;
                    MinecraftClient.getInstance().setScreen(new AnnouncementScreen(announcement, reason, parentScreen, entryGui.getEntry()));
                }

                ci.cancel(); // Prevent Patchouli from opening its screen
            }
        }
    }
}
```

`GuiBookEntryListMixin.java`
```java
package net.dawson.adorablehamsterpets.mixin.client;

// (Imports omitted to save token count)

@Mixin(value = GuiBookEntryList.class, remap = false)
public abstract class GuiBookEntryListMixin extends GuiBook {

    // Shadowed fields from target class
    @Shadow @Final protected List<ButtonWidget> entryButtons;
    @Shadow @Final private List<BookEntry> visibleEntries;
    @Shadow private List<BookEntry> allEntries;
    @Shadow private TextFieldWidget searchField;

    // Abstract methods need to be able to call
    @Shadow protected abstract void addSubcategoryButtons();

    // Required constructor for the Mixin to compile
    public GuiBookEntryListMixin(Book book, Text title) {
        super(book, title);
    }

    /**
     * Helper method to check if the currently rendered book is Hamster Tips guide book.
     */
    private boolean isHamsterBook() {
        return this.book != null && this.book.id.equals(Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_tips_guide_book"));
    }

    /**
     * Injects into the start of buildEntryButtons to completely replace its logic for Hamster Tips guide book.
     * This new implementation dynamically calculates page breaks based on the actual rendered height of each entry.
     */
    @Inject(method = "buildEntryButtons", at = @At("HEAD"), cancellable = true)
    private void adorablehamsterpets$buildWrappedEntryButtons(CallbackInfo ci) {
        if (!isHamsterBook()) {
            // --- SAFETY CHECK ---
            return; // If not the Hamster Tips guide book, let the original method run.
        }

        ci.cancel(); // Replacing the entire method.

        GuiBookAccessor accessor = (GuiBookAccessor) this;

        // --- 1. Replicate Initial Setup from Original Method ---
        this.removeDrawablesIn(this.entryButtons);
        this.entryButtons.clear();
        this.visibleEntries.clear();
        String query = this.searchField.getText().toLowerCase();
        Stream<BookEntry> stream = this.allEntries.stream().filter((e) -> e.isFoundByQuery(query));
        Objects.requireNonNull(this.visibleEntries);
        stream.forEach(this.visibleEntries::add);

        // --- 2. Dynamic Page Layout Simulation ---
        List<Integer> pageStartIndices = new ArrayList<>();
        if (!this.visibleEntries.isEmpty()) {
            pageStartIndices.add(0); // Page 0 always starts at entry 0

            TextRenderer textRenderer = MinecraftClient.getInstance().textRenderer;
            int availableWidth = 116 - 12;
            int firstPageHeightLimit = 156 - 38; // Page height limit was 168. Reduced to create more bottom padding.
            int subsequentPageHeightLimit = 156 - 18;

            int currentEntryIndex = 0;
            boolean isFirstPage = true;

            while (currentEntryIndex < this.visibleEntries.size()) {
                int pageHeightLimit = isFirstPage ? firstPageHeightLimit : subsequentPageHeightLimit;
                int currentY = 0;

                // Left column
                while (currentEntryIndex < this.visibleEntries.size()) {
                    BookEntry entry = this.visibleEntries.get(currentEntryIndex);
                    MutableText name = entry.isLocked() ? Text.translatable("patchouli.gui.lexicon.locked") : entry.getName().copy();
                    int buttonHeight = textRenderer.wrapLines(name, availableWidth).size() * 10;

                    // This entry doesn't fit; starts the next page.
                    if (currentY + buttonHeight > pageHeightLimit) break;

                    currentY += buttonHeight + 1;
                    currentEntryIndex++;
                }

                if (isFirstPage) {
                    isFirstPage = false;
                } else {
                    // Right column (for spreads > 0)
                    currentY = 0;
                    while (currentEntryIndex < this.visibleEntries.size()) {
                        BookEntry entry = this.visibleEntries.get(currentEntryIndex);
                        MutableText name = entry.isLocked() ? Text.translatable("patchouli.gui.lexicon.locked") : entry.getName().copy();
                        int buttonHeight = textRenderer.wrapLines(name, availableWidth).size() * 10;

                        if (currentY + buttonHeight > pageHeightLimit) break;

                        currentY += buttonHeight + 1;
                        currentEntryIndex++;
                    }
                }

                if (currentEntryIndex < this.visibleEntries.size()) {
                    pageStartIndices.add(currentEntryIndex);
                }
            }
        }

        // --- 3. Calculate maxSpreads and Validate Current Spread ---
        int numPages = pageStartIndices.size();
        accessor.adorablehamsterpets$setMaxSpreads(1 + (int) Math.ceil((numPages - 1) / 2.0));
        if (accessor.adorablehamsterpets$getMaxSpreads() < 1) {
            accessor.adorablehamsterpets$setMaxSpreads(1);
        }

        // Ensure the current spread is not out of bounds if the number of pages changed
        if (accessor.adorablehamsterpets$getSpread() >= accessor.adorablehamsterpets$getMaxSpreads()) {
            accessor.adorablehamsterpets$setSpread(Math.max(0, accessor.adorablehamsterpets$getMaxSpreads() - 1));
        }

        // --- 4. Draw Buttons for the Current Page ---
        if (accessor.adorablehamsterpets$getSpread() == 0) {
            int start = pageStartIndices.isEmpty() ? 0 : pageStartIndices.get(0);
            int end = numPages > 1 ? pageStartIndices.get(1) : this.visibleEntries.size();
            addWrappedEntryButtons(141, 38, start, end - start);
            this.addSubcategoryButtons();
        } else {
            int leftPageIndex = accessor.adorablehamsterpets$getSpread() * 2 - 1;
            int rightPageIndex = accessor.adorablehamsterpets$getSpread() * 2;

            int leftStartIndex = numPages > leftPageIndex ? pageStartIndices.get(leftPageIndex) : this.visibleEntries.size();
            int rightStartIndex = numPages > rightPageIndex ? pageStartIndices.get(rightPageIndex) : this.visibleEntries.size();
            int leftCount = rightStartIndex - leftStartIndex;

            addWrappedEntryButtons(15, 18, leftStartIndex, leftCount);
            addWrappedEntryButtons(141, 18, rightStartIndex, this.visibleEntries.size() - rightStartIndex);
        }
    }

    /**
     * A helper method to add entry buttons with dynamic heights.
     */
    private void addWrappedEntryButtons(int x, int y, int start, int count) {
        GuiBookEntryList self = (GuiBookEntryList) (Object) this;
        GuiBookAccessor accessor = (GuiBookAccessor) self;
        TextRenderer textRenderer = MinecraftClient.getInstance().textRenderer;

        int bookLeft = accessor.adorablehamsterpets$getBookLeft();
        int bookTop = accessor.adorablehamsterpets$getBookTop();
        int availableWidth = 116 - 12;
        int yOffset = y;

        for (int i = 0; i < count; i++) {
            int entryIndex = start + i;
            if (entryIndex >= this.visibleEntries.size()) break;

            BookEntry entry = this.visibleEntries.get(entryIndex);
            MutableText name = entry.isLocked() ? Text.translatable("patchouli.gui.lexicon.locked") : entry.getName().copy();
            int buttonHeight = textRenderer.wrapLines(name, availableWidth).size() * 10;

            ButtonWidget button = new GuiButtonEntry(self, bookLeft + x, bookTop + yOffset, entry, self::handleButtonEntry);
            // Use accessor to set the height on 1.20.1
            ((ClickableWidgetAccessor) button).adorablehamsterpets$setHeight(buttonHeight);

            // Use ScreenWidgetAdder accessor to add the widget for cross-loader compatibility
            ((ScreenWidgetAdder)(Object)self).adorablehamsterpets$addWidget(button);
            this.entryButtons.add(button);

            yOffset += buttonHeight + 1;
        }
    }
}
```

`GuiBookIndexMixin.java`
```java
package net.dawson.adorablehamsterpets.mixin.client;

// (Imports omitted to save token count)

@Mixin(value = GuiBookIndex.class, remap = false)
public abstract class GuiBookIndexMixin {

    /**
     * Intercepts getEntries() to hide the virtual entries from the main entry index.
     * This prevents the "all entries" list from being cluttered with announcements and update notes.
     */
    @Inject(method = "getEntries", at = @At("RETURN"), cancellable = true)
    private void adorablehamsterpets$filterVirtualEntries(CallbackInfoReturnable<Collection<BookEntry>> cir) {
        // --- 1. Get Context and Perform Safety Check ---
        // This cast gives us access to the 'book' field on the parent GuiBook.
        GuiBook self = (GuiBook) (Object) this;
        Book thisBook = self.book;

        // Only filter entries for our Hamster Tips guide book.
        Identifier hamsterBookId = Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_tips_guide_book");
        if (thisBook == null || !hamsterBookId.equals(thisBook.id)) {
            return;
        }

        // --- 2. Filter and Replace the Return Value ---
        // Get the original list of all entries that Patchouli was about to return.
        Collection<BookEntry> originalEntries = cir.getReturnValue();

        // Use a stream to create a new list, excluding any entry whose category is one of our virtual ones.
        Collection<BookEntry> filteredEntries = originalEntries.stream()
                .filter(entry -> {
                    Identifier categoryId = entry.getCategory().getId();
                    boolean isVirtualCategory = categoryId.getNamespace().equals(AdorableHamsterPets.MOD_ID) &&
                            (categoryId.getPath().equals("update_notes") || categoryId.getPath().equals("announcements"));
                    // Keep the entry only if it's NOT in a virtual category.
                    return !isVirtualCategory;
                })
                .collect(Collectors.toList());

        // Set the return value of the getEntries() method to our new, filtered list.
        cir.setReturnValue(filteredEntries);
    }
}
```

`GuiBookLandingMixin.java`
```java
package net.dawson.adorablehamsterpets.mixin.client;

// (Imports omitted to save token count)

/**
 * Mixin to customize the Patchouli {@link GuiBookLanding} screen specifically for the
 * Adorable Hamster Pets guide book. This class implements two key visual overrides:
 * <p>
 * 1.  <b>Custom Header Rendering:</b> It replaces the default header drawing logic to render a
 *     custom-positioned, multi-line wrapped subtitle that would otherwise overflow onto the opposite page.
 * 2.  <b>Centered Category Grid:</b> It intercepts the category button layout logic to
 *     recalculate icon positions, ensuring that the final row of the category grid is
 *     centered on the page for a more balanced appearance.
 * <p>
 * All modifications are gated behind a check to ensure they only apply to the Hamster Tips guide book.
 */
@Mixin(value = GuiBookLanding.class, remap = false)
public abstract class GuiBookLandingMixin extends GuiBook {

    // This constructor is required by the compiler because GuiBook has a constructor.
    public GuiBookLandingMixin(Book book, Text title) {
        super(book, title);
    }

    /**
     * A simple helper method to check if the currently rendered book is the
     * Adorable Hamster Pets guide book. All mixin modifications will be gated
     * behind this check to prevent them from affecting other mods' books.
     *
     * @return True if the current book is the hamster guide, false otherwise.
     */
    private boolean isHamsterBook() {
        // The 'book' field is inherited from the parent GuiBook class.
        return this.book != null && this.book.id.equals(Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_tips_guide_book"));
    }

    /**
     * Computes the total number of category buttons (visible categories + index).
     * This is used to calculate the centered grid layout.
     */
    private int getTotalIcons() {
        // Do not alter pamphlet (non-category) mode
        if (this.book.getContents().pamphletCategory != null) {
            return 0;
        }
        int count = 0;
        for (BookCategory cat : this.book.getContents().categories.values()) {
            if (cat.getParentCategory() == null && !cat.shouldHide()) {
                count++;
            }
        }
        // +1 for the index button
        return count + 1;
    }

    /**
     * Injects at the beginning of the drawHeader method to completely replace its rendering logic
     * for the Adorable Hamster Pets guide book. This allows for custom positioning and text wrapping
     * of the title and subtitle without affecting other Patchouli books.
     *
     * @param graphics The DrawContext for rendering.
     * @param ci       The CallbackInfo, used to cancel the original method.
     */
    @Inject(method = "drawHeader", at = @At("HEAD"), cancellable = true)
    private void adorablehamsterpets$onDrawHeader(DrawContext graphics, CallbackInfo ci) {
        // --- SAFETY CHECK ---
        // If this is not the Hamster Tips guide book, do nothing and let the original method run.
        if (!isHamsterBook()) {
            return;
        }

        // --- 1. Set Render Color ---
        RenderSystem.setShaderColor(1.0F, 1.0F, 1.0F, 1.0F);

        // --- 2. Render the Header Ribbon Texture ---
        // We use a taller texture to fit the wrapped subtitle.
        int ribbonX = -8;
        int ribbonY = 12;
        int ribbonU = 0;
        int ribbonV = 180;
        int ribbonWidth = 140;
        int ribbonHeight = 43; // MODIFIED: Was 31
        drawFromTexture(graphics, this.book, ribbonX, ribbonY, ribbonU, ribbonV, ribbonWidth, ribbonHeight);

        // --- 3. Render the Main Book Title ---
        int titleColor = this.book.nameplateColor;
        Text titleText = this.book.getBookItem().getName();
        int titleX = 13 + 7; // MODIFIED: Shifted right by 7
        int titleY = 16;
        graphics.drawText(MinecraftClient.getInstance().textRenderer, titleText, titleX, titleY, titleColor, false);

        // --- 4. Render the Wrapped Subtitle ---
        Text subtitleText = this.book.getSubtitle().fillStyle(this.book.getFontStyle());
        int subtitleX = 24 - 5; // MODIFIED: Shifted left by 5
        int subtitleY = 24 + 2; // MODIFIED: Shifted down by 2
        int wrapWidth = 100;    // The available width for the text
        graphics.drawTextWrapped(MinecraftClient.getInstance().textRenderer, subtitleText, subtitleX, subtitleY, wrapWidth, titleColor);

        // --- 5. Cancel the Original Method ---
        ci.cancel();
    }

    /**
     * Intercepts category button placement to center the last row.
     */
    @Inject(method = "addCategoryButton", at = @At("HEAD"), cancellable = true)
    private void adorablehamsterpets$onAddCategoryButton(int i, BookCategory category, CallbackInfo ci) {
        // Only affect the Hamster guide and normal category pages
        if (!isHamsterBook() || this.book.getContents().pamphletCategory != null) {
            return;
        }

        int total = getTotalIcons();
        if (total == 0) {
            return;
        }

        int columns = 4;
        int row = i / columns;
        int lastRow = (total - 1) / columns;
        int rowItems = (row == lastRow) ? (total - lastRow * columns) : columns;
        int shift = (columns - rowItems) * 12; // 12px = half of a column (24px)

        int x = RIGHT_PAGE_X + 10 + shift + (i % columns) * 24;
        int y = TOP_PADDING + 25 + row * 24;

        // Create the appropriate button
        GuiButtonCategory button;
        GuiBookLanding self = (GuiBookLanding) (Object) this;
        if (category == null) {
            button = new GuiButtonCategory(this, x, y, this.book.getIcon(), Text.translatable("patchouli.gui.lexicon.index"), self::handleButtonIndex);
        } else {
            button = new GuiButtonCategory(this, x, y, category, self::handleButtonCategory);
        }
        // Use ScreenWidgetAdder accessor to add the widget for cross-loader compatibility
        ((ScreenWidgetAdder)(Object)this).adorablehamsterpets$addWidget(button);

        // Cancel original positioning
        ci.cancel();
    }
}
```

`GuiButtonBookMarkReadMixin.java`
```java
package net.dawson.adorablehamsterpets.mixin.client;

// (Imports omitted to save token count)

/**
 * Intercepts the 'onPress' action of Patchouli's 'Mark All as Read' button.
 * <p>
 * This mixin is necessary to prevent the button from clearing the 'unread' status
 * of Adorable Hamster Pets' virtual announcement and update note entries. It ensures that players
 * cannot dismiss these important notifications without viewing them in the custom
 * announcement GUI.
 * <p>
 */
@Mixin(value = GuiButtonBookMarkRead.class)
public abstract class GuiButtonBookMarkReadMixin {

    @Shadow(remap = false) private Book book;

    /** Access the private markEntry() in the target class. */
    @Invoker(value = "markEntry", remap = false)
    abstract void adorablehamsterpets$markEntry(BookEntry entry);

    /** Access the private markCategoryAsRead() in the target class. */
    @Invoker(value = "markCategoryAsRead", remap = false)
    abstract void adorablehamsterpets$markCategoryAsRead(BookEntry entry, BookCategory category, int maxRecursion);

    @Inject(method = "onPress", at = @At("HEAD"), cancellable = true)
    private void adorablehamsterpets$onPress(CallbackInfo ci) {
        // Only intercept for the Hamster Tips book
        Identifier hamsterBookId = Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_tips_guide_book");
        if (!this.book.id.equals(hamsterBookId)) {
            return; // not our book; fall back to original logic
        }

        // Determine if this is the “mark all” (main page) action
        boolean onMainPage = !this.book.getContents().currentGui.canSeeBackButton();

        // Iterate over all entries in the book
        for (BookEntry entry : this.book.getContents().entries.values()) {
            Identifier entryId = entry.getId();

            // --- Announcement Logic: Handle Virtual Announcement Entries ---
            if (entryId.getNamespace().equals(AdorableHamsterPets.MOD_ID)
                    && entryId.getPath().startsWith("announcement_")) {

                String announcementId = entryId.getPath().substring("announcement_".length());
                Announcement announcement = AnnouncementManager.INSTANCE.getAnnouncementById(announcementId);

                if (announcement != null) {
                    // Mark as seen in my system
                    AnnouncementManager.INSTANCE.markAsSeen(announcement.id());
                    // Acknowledge in my system if it's an update-related message
                    if ("update".equals(announcement.kind())) {
                        AnnouncementManager.INSTANCE.setLastAcknowledgedUpdate(announcement.semver());
                    }
                }
            }

            // --- Universal Logic: Mark entry as read in Patchouli's system ---
            if (onMainPage) {
                adorablehamsterpets$markEntry(entry);
            } else {
                adorablehamsterpets$markCategoryAsRead(entry, entry.getCategory(), this.book.getContents().entries.size());
            }
        }

        // Cancel the default Patchouli logic
        ci.cancel();
    }
}
```

`GuiButtonEntryMixin.java`
```java
package net.dawson.adorablehamsterpets.mixin.client;

// (Imports omitted to save token count)

@Mixin(value = GuiButtonEntry.class)
public abstract class GuiButtonEntryMixin extends ButtonWidget {

    @Shadow(remap = false) @Final private GuiBook parent;
    @Shadow(remap = false) @Final private BookEntry entry;
    @Shadow(remap = false) private float timeHovered;

    // Required constructor Mixin to compile
    public GuiButtonEntryMixin(int x, int y, int width, int height, Text message, PressAction onPress, NarrationSupplier narrationSupplier) {
        super(x, y, width, height, message, onPress, narrationSupplier);
    }

    /**
     * Helper method to determine if this button belongs to the Hamster Tips guide book.
     * @return True if the parent book is the hamster guide, false otherwise.
     */
    private boolean isHamsterBook() {
        return this.parent.book != null && this.parent.book.id.equals(Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_tips_guide_book"));
    }

    /**
     * Injects into the start of the renderButton method to replace its logic, but ONLY for the Hamster Tips guide book.
     * This new implementation draws the entry title with text wrapping.
     */
    @Inject(method = "renderButton", at = @At("HEAD"), cancellable = true)
    private void adorablehamsterpets$renderWrappedWidget(DrawContext graphics, int mouseX, int mouseY, float partialTicks, CallbackInfo ci) {
        // --- SAFETY CHECK ---
        // If this button is not the Hamster Tips guide book, do nothing and let the original method run.
        if (!isHamsterBook()) {
            return;
        }

        ci.cancel(); // Replacing the entire method.

        if (this.active) {
            // --- 1. Replicate Hover Animation Logic ---
            if (this.isSelected()) {
                this.timeHovered = Math.min(5.0F, this.timeHovered + ClientTicker.delta);
            } else {
                this.timeHovered = Math.max(0.0F, this.timeHovered - ClientTicker.delta);
            }
            float time = Math.max(0.0F, Math.min(5.0F, this.timeHovered + (this.isSelected() ? partialTicks : -partialTicks)));
            float widthFract = time / 5.0F;

            // --- 2. Replicate Background, Icon, and Lock Rendering ---
            boolean locked = this.entry.isLocked();
            graphics.getMatrices().scale(0.5F, 0.5F, 0.5F);
            graphics.fill(this.getX() * 2, this.getY() * 2, (this.getX() + (int)((float)this.width * widthFract)) * 2, (this.getY() + this.height) * 2, 570425344);
            RenderSystem.enableBlend();
            if (locked) {
                graphics.setShaderColor(1.0F, 1.0F, 1.0F, 0.7F);
                GuiBook.drawLock(graphics, this.parent.book, this.getX() * 2 + 2, this.getY() * 2 + 2);
            } else {
                this.entry.getIcon().render(graphics, this.getX() * 2 + 2, this.getY() * 2 + 2);
            }
            graphics.getMatrices().scale(2.0F, 2.0F, 2.0F);

            // --- 3. Prepare Text for Wrapping ---
            MutableText name = locked
                    ? Text.translatable("patchouli.gui.lexicon.locked")
                    : this.entry.getName().copy();
            if (!locked && this.entry.isPriority()) {
                name.formatted(Formatting.ITALIC);
            }
            name.fillStyle(this.entry.getBook().getFontStyle());

            // --- 4. Wrap and Render Text ---
            TextRenderer textRenderer = MinecraftClient.getInstance().textRenderer;
            int availableWidth = this.width - 12; // Width of button minus icon/padding
            List<OrderedText> lines = textRenderer.wrapLines(name, availableWidth);

            for (int i = 0; i < lines.size(); i++) {
                OrderedText line = lines.get(i);
                // Calculate Y position for each line, adding a small top margin
                int lineY = this.getY() + 1 + (i * 10);
                graphics.drawText(textRenderer, line, this.getX() + 12, lineY, ((GuiButtonEntryAccessor) this).adorablehamsterpets$invokeGetColor(), false);
            }

            // --- 5. Replicate Read-State Marking ---
            if (!this.entry.isLocked()) {
                GuiBook.drawMarking(graphics, this.parent.book, this.getX() + this.width - 5, this.getY() + 1, this.entry.hashCode(), this.entry.getReadState());
            }
        }
    }
}
```

`LivingEntityRendererInvoker.java`
```java
package net.dawson.adorablehamsterpets.mixin.client;

// (Imports omitted to save token count)

// Target LivingEntityRenderer directly
@Mixin(LivingEntityRenderer.class)
public interface LivingEntityRendererInvoker {

    // Use @Invoker to call the protected addFeature method
    @Invoker("addFeature")
    boolean callAddFeature(FeatureRenderer<?, ?> feature);
}
```

`PlayerEntityRendererMixin.java`
```java
package net.dawson.adorablehamsterpets.mixin.client;

// (Imports omitted to save token count)

@Mixin(value = PlayerEntityRenderer.class, remap = false)
public abstract class PlayerEntityRendererMixin {

    // Inject into the constructor
    @Inject(method = "<init>", at = @At("RETURN"))
    private void onInit(EntityRendererFactory.Context ctx, boolean slim, CallbackInfo ci) {
        AdorableHamsterPets.LOGGER.trace("[AHP Mixin] PlayerEntityRendererMixin constructor injection is RUNNING.");

        // Cast 'this' (PlayerEntityRenderer) to LivingEntityRenderer first
        LivingEntityRenderer<?, ?> livingRenderer = (LivingEntityRenderer<?, ?>) (Object) this;
        // Then cast the LivingEntityRenderer instance to my separate Invoker interface
        LivingEntityRendererInvoker invoker = (LivingEntityRendererInvoker) livingRenderer;
        // Cast 'this' to PlayerEntityRenderer to pass to the FeatureRenderer constructor
        PlayerEntityRenderer thisRenderer = (PlayerEntityRenderer)(Object)this;

        AdorableHamsterPets.LOGGER.trace("[PlayerRendererMixin] Adding HamsterShoulderFeatureRenderer via Invoker...");
        // Call the protected method using the invoker interface
        boolean added = invoker.callAddFeature(new HamsterShoulderFeatureRenderer(thisRenderer));

        AdorableHamsterPets.LOGGER.trace("[AHP Mixin] Attempted to add HamsterShoulderFeatureRenderer. Success: {}", added);
        if (!added) {
            AdorableHamsterPets.LOGGER.trace("[AHP Mixin] FAILED to add HamsterShoulderFeatureRenderer!");
        }
    }
}
```

`TitleScreenMixin.java`
```java
package net.dawson.adorablehamsterpets.mixin.client;

// (Imports omitted to save token count)

@Mixin(TitleScreen.class)
public abstract class TitleScreenMixin extends Screen {

    protected TitleScreenMixin(Text title) {
        super(title);
    }

    @Inject(method = "init", at = @At("TAIL"))
    private void adorablehamsterpets$onInit(CallbackInfo ci) {
        AdorableHamsterPets.LOGGER.trace("[AHP TitleScreen] Mixin init called. Scheduling manifest refresh.");

        // Asynchronously refresh the announcement manifest when the title screen loads.
        // This returns a CompletableFuture to prevent race conditions with the network request.
        AnnouncementManager.INSTANCE.refreshManifestOnce().thenAcceptAsync(v -> {
            // This code needs to run after the manifest is ready.
            AdorableHamsterPets.LOGGER.trace("[AHP TitleScreen] Manifest refresh future completed.");
            // Get notifications directly from the manager, not the stale client cache
            List<AnnouncementManager.PendingNotification> notifications = AnnouncementManager.INSTANCE.getPendingNotifications();
            AdorableHamsterPets.LOGGER.trace("[AHP TitleScreen] Pending notifications count: {}", notifications.size());

            // Only add the widget to the title screen if there is a pending "update available" notification.  
            // This code runs AFTER the manifest has been fetched/loaded.
            boolean shouldShowIcon = notifications.stream()
                    .anyMatch(n -> n.reason().equals(AnnouncementManager.PendingNotification.UPDATE_AVAILABLE_ANNOUNCEMENT));

            AdorableHamsterPets.LOGGER.trace("[AHP TitleScreen] Should show icon: {}", shouldShowIcon);

            if (shouldShowIcon && Configs.AHP.enableHudIcon.get()) {
                // The initial x/y and size don't matter much as they are controlled by the animator.
                // Pass the current screen instance as the parent.
                // Add widget if on title screen
                if (MinecraftClient.getInstance().currentScreen == (TitleScreen) (Object) this) {
                    AdorableHamsterPets.LOGGER.trace("[AHP TitleScreen] Adding AnnouncementIconWidget to the screen.");
                    // Use ScreenWidgetAdder accessor to add the widget for cross-loader compatibility
                    ((ScreenWidgetAdder)(Object)this).adorablehamsterpets$addWidget(new AnnouncementIconWidget(
                            0, 0, 16, 16,
                            button -> ((AnnouncementIconWidget) button).onPress(),
                            (Screen) (Object) this // 'this' is the TitleScreen instance
                    ));
                } else {
                    AdorableHamsterPets.LOGGER.trace("[AHP TitleScreen] Screen changed before widget could be added. Current screen: {}", MinecraftClient.getInstance().currentScreen);
                }
            }
        }, MinecraftClient.getInstance()); // Ensure callback runs on the render thread
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/mixin/client/accessor/`
`ClickableWidgetAccessor.java`
```java
package net.dawson.adorablehamsterpets.mixin.client.accessor;

// (Imports omitted to save token count)

@Mixin(ClickableWidget.class)
@Environment(EnvType.CLIENT)
public interface ClickableWidgetAccessor {
    @Accessor("height")
    void adorablehamsterpets$setHeight(int height);
}
```

`GuiBookAccessor.java`
```java
package net.dawson.adorablehamsterpets.mixin.client.accessor;

// (Imports omitted to save token count)

@Mixin(value = GuiBook.class, remap = false)
public interface GuiBookAccessor {
    @Accessor("bookLeft")
    int adorablehamsterpets$getBookLeft();

    @Accessor("bookTop")
    int adorablehamsterpets$getBookTop();

    @Accessor("spread")
    int adorablehamsterpets$getSpread();

    @Accessor("maxSpreads")
    int adorablehamsterpets$getMaxSpreads();

    @Accessor("spread")
    void adorablehamsterpets$setSpread(int spread);

    @Accessor("maxSpreads")
    void adorablehamsterpets$setMaxSpreads(int maxSpreads);
}
```

`GuiButtonEntryAccessor.java`
```java
package net.dawson.adorablehamsterpets.mixin.client.accessor;

// (Imports omitted to save token count)

@Mixin(value = GuiButtonEntry.class, remap = false)
public interface GuiButtonEntryAccessor {
    @Invoker("getColor")
    int adorablehamsterpets$invokeGetColor();
}
```

`HandledScreenAccessor.java`
```java
package net.dawson.adorablehamsterpets.mixin.client.accessor;

// (Imports omitted to save token count)

@Mixin(HandledScreen.class)
public interface HandledScreenAccessor {
    @Accessor("x")
    int getX();

    @Accessor("y")
    int getY();

    @Accessor("backgroundWidth")
    int getBackgroundWidth();
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/mixin/server/`
`PlayerEntityMixin.java`
```java
package net.dawson.adorablehamsterpets.mixin.server;

// (Imports omitted to save token count)

@Mixin(PlayerEntity.class)
public abstract class PlayerEntityMixin extends LivingEntity implements PlayerEntityAccessor {

    // --- 1. Data Storage ---
    @Unique
    private NbtCompound ahp$shoulderData = new NbtCompound();

    @Unique
    private transient ClientShoulderHamsterData adorablehamsterpets$clientShoulderData;

    // --- Constants and Static Utilities ---
    @Unique private static final int CHECK_INTERVAL_TICKS = 20;
    @Unique private static final List<String> DISMOUNT_MESSAGE_KEYS = Arrays.asList(
            "message.adorablehamsterpets.dismount.1", "message.adorablehamsterpets.dismount.2",
            "message.adorablehamsterpets.dismount.3", "message.adorablehamsterpets.dismount.4",
            "message.adorablehamsterpets.dismount.5", "message.adorablehamsterpets.dismount.6"
    );

    // --- Fields ---
    @Unique private int adorablehamsterpets$diamondCheckTimer = 0;
    @Unique private int adorablehamsterpets$creeperCheckTimer = 0;
    @Unique private int adorablehamsterpets$diamondSoundCooldownTicks = 0;
    @Unique private int adorablehamsterpets$creeperSoundCooldownTicks = 0;
    @Unique private String adorablehamsterpets$lastDismountMessageKey = "";
    @Unique private boolean adorablehamsterpets$isDiamondAlertConditionMet = false;
    @Unique private int adorablehamsterpets$lastGoldMessageIndex = -1;
    @Unique private final transient ArrayDeque<ShoulderLocation> adorablehamsterpets$mountOrderQueue = new ArrayDeque<>();
    @Unique private final List<ScheduledTask> adorablehamsterpets$scheduledTasks = new ArrayList<>();
    @Unique private record ScheduledTask(long executionTick, Runnable action) {}

    // --- Constructor Injection ---
    @Inject(method = "<init>", at = @At("TAIL"))
    private void adorablehamsterpets$onInit(World world, BlockPos pos, float yaw, GameProfile gameProfile, CallbackInfo ci) {
        if (world.isClient) {
            this.adorablehamsterpets$clientShoulderData = new ClientShoulderHamsterData();
        }
    }

    protected PlayerEntityMixin(EntityType<? extends LivingEntity> entityType, World world) {
        super(entityType, world);
    }

    // --- 2. NBT Read/Write ---
    @Inject(method = "writeCustomDataToNbt", at = @At("TAIL"))
    private void adorablehamsterpets$writeNbt(NbtCompound nbt, CallbackInfo ci) {
        // Save from local field
        if (!this.ahp$shoulderData.isEmpty()) {
            nbt.put("ShoulderHamsters", this.ahp$shoulderData);
        }

        // Save Mount Order Queue
        if (!this.adorablehamsterpets$mountOrderQueue.isEmpty()) {
            NbtList mountOrderList = new NbtList();
            for (ShoulderLocation location : this.adorablehamsterpets$mountOrderQueue) {
                mountOrderList.add(NbtString.of(location.name()));
            }
            nbt.put("MountOrderQueue", mountOrderList);
        }

        if (this.adorablehamsterpets$lastGoldMessageIndex != -1) {
            nbt.putInt("LastGoldMessageIndex", this.adorablehamsterpets$lastGoldMessageIndex);
        }
    }

    @Inject(method = "readCustomDataFromNbt", at = @At("TAIL"))
    private void adorablehamsterpets$readNbt(NbtCompound nbt, CallbackInfo ci) {
        // --- Backward Compatibility: Check for old single hamster data ---
        if (nbt.contains("ShoulderHamster", NbtElement.COMPOUND_TYPE)) {
            NbtCompound oldHamsterNbt = nbt.getCompound("ShoulderHamster");
            if (!oldHamsterNbt.isEmpty()) {
                NbtCompound newShoulderPetsNbt = new NbtCompound();
                newShoulderPetsNbt.put(ShoulderLocation.RIGHT_SHOULDER.name(), oldHamsterNbt);
                this.ahp$shoulderData = newShoulderPetsNbt; // Update local field
                this.adorablehamsterpets$mountOrderQueue.clear();
                this.adorablehamsterpets$mountOrderQueue.add(ShoulderLocation.RIGHT_SHOULDER);
                nbt.remove("ShoulderHamster"); // Remove old tag to complete migration
                AdorableHamsterPets.LOGGER.info("Migrated legacy shoulder hamster data for player {}.", this.getDisplayName().getString());
            }
        } else if (nbt.contains("ShoulderHamsters", NbtElement.COMPOUND_TYPE)) {
            // Standard Read
            this.ahp$shoulderData = nbt.getCompound("ShoulderHamsters");
        }

        // Read Mount Order Queue with Auto-Sanitization
        this.adorablehamsterpets$mountOrderQueue.clear();
        if (nbt.contains("MountOrderQueue", NbtElement.LIST_TYPE)) {
            NbtList mountOrderList = nbt.getList("MountOrderQueue", NbtElement.STRING_TYPE);

            // Track seen locations to prevent duplicates
            Set<ShoulderLocation> seenLocations = new HashSet<>();

            for (NbtElement element : mountOrderList) {
                try {
                    ShoulderLocation location = ShoulderLocation.valueOf(element.asString());

                    // Sanitize: Only add if:
                    // 1. Haven't added this location already (Deduplication)
                    // 2. The shoulder slot actually contains data (Ghost cleanup)
                    if (!seenLocations.contains(location) && !this.getShoulderHamster(location).isEmpty()) {
                        this.adorablehamsterpets$mountOrderQueue.add(location);
                        seenLocations.add(location);
                    }
                } catch (IllegalArgumentException e) {
                    AdorableHamsterPets.LOGGER.warn("Found invalid ShoulderLocation name in NBT: {}", element.asString());
                }
            }
        }

        // --- Self-Healing Logic for Potential Corrupted State ---
        // If sanitization cleared everything but there's still data, rebuild cleanly.
        if (this.adorablehamsterpets$mountOrderQueue.isEmpty() && this.hasAnyShoulderHamster()) {
            AdorableHamsterPets.LOGGER.info("Player {} has shoulder hamsters but an empty mount queue. Rebuilding queue...", this.getDisplayName().getString());
            for (ShoulderLocation location : ShoulderLocation.values()) {
                if (!this.getShoulderHamster(location).isEmpty()) {
                    this.adorablehamsterpets$mountOrderQueue.addLast(location);
                }
            }
            AdorableHamsterPets.LOGGER.info("Successfully rebuilt mount queue for player {}. New queue: {}", this.getDisplayName().getString(), this.adorablehamsterpets$mountOrderQueue);
        }

        if (nbt.contains("LastGoldMessageIndex", NbtElement.INT_TYPE)) {
            this.adorablehamsterpets$lastGoldMessageIndex = nbt.getInt("LastGoldMessageIndex");
        } else {
            this.adorablehamsterpets$lastGoldMessageIndex = -1;
        }
    }

    /**
     * Injects the start tracking logic using the vanilla/Yarn mapped method.
     * This fires when another player starts tracking this player entity.
     * We use this moment to send the shoulder data to the watcher so they can render the hamsters.
     */
    @Override
    public void onStartedTrackingBy(ServerPlayerEntity player) {
        // Call super first (vanilla logic)
        super.onStartedTrackingBy(player);

        // If this player has shoulder data, send it to the player who just started watching
        if (!this.ahp$shoulderData.isEmpty()) {
            ModPackets.SyncShoulderDataS2CPacket packet = new ModPackets.SyncShoulderDataS2CPacket(this.getId(), this.ahp$shoulderData);
            ModPackets.CHANNEL.sendToPlayer(player, packet);
        }
    }

    @Inject(method = "remove(Lnet/minecraft/entity/Entity$RemovalReason;)V", at = @At("HEAD"))
    private void adorablehamsterpets$onRemove(Entity.RemovalReason reason, CallbackInfo ci) {
        if (!this.getWorld().isClient()) {
            net.dawson.adorablehamsterpets.util.HamsterRenderTracker.onPlayerDisconnect(this.getUuid());
        }
    }

    // --- 3. Public Accessors ---
    @Unique
    @Override
    public NbtCompound getShoulderHamster(ShoulderLocation location) {
        return this.ahp$shoulderData.getCompound(location.name());
    }

    @Unique
    @Override
    public void setShoulderHamster(ShoulderLocation location, NbtCompound nbt) {
        // Update local NBT
        if (nbt == null || nbt.isEmpty()) {
            this.ahp$shoulderData.remove(location.name());
        } else {
            this.ahp$shoulderData.put(location.name(), nbt);
        }

        // Sync with clients manually
        if (!this.getWorld().isClient()) {
            ModPackets.SyncShoulderDataS2CPacket packet = new ModPackets.SyncShoulderDataS2CPacket(this.getId(), this.ahp$shoulderData);
            PlayerEntity self = (PlayerEntity) (Object) this;

            // Send to self
            if (self instanceof ServerPlayerEntity serverSelf) {
                ModPackets.CHANNEL.sendToPlayer(serverSelf, packet);
            }

            // Send to tracking players (Manual loop on 1.20.1)
            if (self.getWorld() instanceof ServerWorld serverWorld) {
                for (ServerPlayerEntity otherPlayer : serverWorld.getPlayers()) {
                    if (otherPlayer != self && otherPlayer.squaredDistanceTo(self) < 6400) {
                        ModPackets.CHANNEL.sendToPlayer(otherPlayer, packet);
                    }
                }
            }
        }
    }

    @Unique
    @Override
    public void adorablehamsterpets$setRawShoulderData(NbtCompound nbt) {
        // Called by client packet handler to update local state
        this.ahp$shoulderData = nbt;
    }

    @Unique
    @Override
    public void adorablehamsterpets$syncShoulderData() {
        // Called via PlayerEvent.PLAYER_JOIN to ensure connection is ready before sending
        if (!this.getWorld().isClient() && !this.ahp$shoulderData.isEmpty()) {
            PlayerEntity self = (PlayerEntity) (Object) this;
            if (self instanceof ServerPlayerEntity serverPlayer) {
                // On 1.20.1, use ModPackets.CHANNEL and the inner record class
                var packet = new ModPackets.SyncShoulderDataS2CPacket(this.getId(), this.ahp$shoulderData);
                ModPackets.CHANNEL.sendToPlayer(serverPlayer, packet);
            }
        }
    }

    // --- 4. Tick Logic ---
    @Inject(method = "tick", at = @At("TAIL"))
    private void adorablehamsterpets$onTick(CallbackInfo ci) {
        // Initial Setup and Server-Side Check
        PlayerEntity self = (PlayerEntity) (Object) this;
        World world = self.getWorld();
        if (world.isClient) {
            return;
        }
        Random random = world.getRandom();
        final AhpConfig config = AdorableHamsterPets.CONFIG;

        // Process Scheduled Tasks
        long currentTime = world.getTime();
        adorablehamsterpets$scheduledTasks.removeIf(task -> {
            if (currentTime >= task.executionTick()) {
                task.action().run();
                return true;
            }
            return false;
        });

        // Cooldown Decrement
        if (adorablehamsterpets$diamondSoundCooldownTicks > 0) adorablehamsterpets$diamondSoundCooldownTicks--;
        if (adorablehamsterpets$creeperSoundCooldownTicks > 0) adorablehamsterpets$creeperSoundCooldownTicks--;

        // Shoulder Pet Logic
        if (this.hasAnyShoulderHamster()) {

            // Shoulder Diamond Detection
            if (config.enableShoulderDiamondDetection) {
                adorablehamsterpets$diamondCheckTimer++;
                if (adorablehamsterpets$diamondCheckTimer >= CHECK_INTERVAL_TICKS) {
                    adorablehamsterpets$diamondCheckTimer = 0;
                    // The isDiamondNearby method internally prioritizes exposed ore.
                    if (isDiamondNearby(self, config.shoulderDiamondDetectionRadius.get())) {
                        this.adorablehamsterpets$isDiamondAlertConditionMet = true;
                        if (adorablehamsterpets$diamondSoundCooldownTicks == 0) {
                            world.playSound(null, self.getBlockPos(),
                                    ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_DIAMOND_SNIFF_SOUNDS, random),
                                    SoundCategory.NEUTRAL, 2.5f, 1.0f);
                            self.sendMessage(Text.translatable("message.adorablehamsterpets.diamond_nearby").formatted(Formatting.AQUA), true);
                            adorablehamsterpets$diamondSoundCooldownTicks = random.nextBetween(140, 200);
                            ModCriteria.HAMSTER_DIAMOND_ALERT_TRIGGERED.trigger((ServerPlayerEntity) self);
                        }
                    } else {
                        this.adorablehamsterpets$isDiamondAlertConditionMet = false;
                    }
                }
            }

            // Shoulder Creeper Detection
            if (config.enableShoulderCreeperDetection) {
                adorablehamsterpets$creeperCheckTimer++;
                if (adorablehamsterpets$creeperCheckTimer >= CHECK_INTERVAL_TICKS) {
                    adorablehamsterpets$creeperCheckTimer = 0;
                    if (creeperSeesPlayer(self, config.shoulderCreeperDetectionRadius.get())) {
                        if (adorablehamsterpets$creeperSoundCooldownTicks == 0) {
                            world.playSound(null, self.getBlockPos(),
                                    ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_CREEPER_DETECT_SOUNDS, random),
                                    SoundCategory.NEUTRAL, 1.0f, 1.0f);
                            self.sendMessage(Text.translatable("message.adorablehamsterpets.creeper_detected").formatted(Formatting.RED), true);
                            adorablehamsterpets$creeperSoundCooldownTicks = random.nextBetween(100, 160);
                            ModCriteria.HAMSTER_CREEPER_ALERT_TRIGGERED.trigger((ServerPlayerEntity) self);
                        }
                    }
                }
            }
        }
    }

    // --- Dismount Logic ---
    /**
     * Executes the server-side logic to dismount a hamster from the player's shoulder.
     * This method is triggered upon receiving a {@code DismountHamsterPayload} from the client.
     * It handles choosing which hamster to dismount if there are more than one,
     * spawning the hamster entity from its stored data, clearing the player's
     * shoulder data, and playing the necessary sounds and messages.
     */
    @Unique
    @Override
    public void adorablehamsterpets$dismountShoulderHamster(boolean isThrow) {
        PlayerEntity self = (PlayerEntity) (Object) this;
        World world = self.getWorld();
        if (world.isClient) {
            return;
        }

        // Self-Healing: Rebuild Queue if Desynced
        if (this.adorablehamsterpets$mountOrderQueue.isEmpty() && this.hasAnyShoulderHamster()) {
            AdorableHamsterPets.LOGGER.warn("[HamsterDismount] Player {} has shoulder hamsters but empty queue. Rebuilding...", self.getName().getString());
            for (ShoulderLocation location : ShoulderLocation.values()) {
                if (!this.getShoulderHamster(location).isEmpty()) {
                    this.adorablehamsterpets$mountOrderQueue.addLast(location);
                }
            }
        }

        if (this.adorablehamsterpets$mountOrderQueue.isEmpty()) {
            return;
        }

        final AhpConfig config = AdorableHamsterPets.CONFIG;
        Random random = world.getRandom();

        // Determine which hamster to dismount/throw
        ShoulderLocation locationToProcess = config.dismountOrder.get() == DismountOrder.LIFO
                ? this.adorablehamsterpets$mountOrderQueue.peekLast()
                : this.adorablehamsterpets$mountOrderQueue.peekFirst();

        if (locationToProcess == null) return;

        NbtCompound shoulderNbt = this.getShoulderHamster(locationToProcess);
        if (shoulderNbt.isEmpty()) {
            AdorableHamsterPets.LOGGER.warn("Dismount queue pointed to an empty slot ({}). This may indicate a desync.", locationToProcess);
            // Remove the bad entry from the queue
            if (config.dismountOrder.get() == DismountOrder.LIFO) this.adorablehamsterpets$mountOrderQueue.pollLast();
            else this.adorablehamsterpets$mountOrderQueue.pollFirst();
            return;
        }

        // Create Hamster Instance for Validation
        HamsterEntity hamster = HamsterEntity.createFromNbt((ServerWorld) world, self, shoulderNbt);
        if (hamster == null) {
            this.setShoulderHamster(locationToProcess, new NbtCompound());
            // Remove from queue
            if (config.dismountOrder.get() == DismountOrder.LIFO) this.adorablehamsterpets$mountOrderQueue.pollLast();
            else this.adorablehamsterpets$mountOrderQueue.pollFirst();
            return;
        }

        // Handle Throw-Specific Logic
        if (isThrow) {
            if (hamster.isBaby()) {
                self.sendMessage(Text.translatable("message.adorablehamsterpets.baby_throw_refusal").formatted(Formatting.RED), true);
                return;
            }

            long currentTime = world.getTime();
            if (hamster.throwCooldownEndTick > currentTime) {
                long remainingTicks = hamster.throwCooldownEndTick - currentTime;
                long totalSecondsRemaining = remainingTicks / 20;
                long minutes = totalSecondsRemaining / 60;
                long seconds = totalSecondsRemaining % 60;
                self.sendMessage(Text.translatable("message.adorablehamsterpets.throw_cooldown", minutes, seconds).formatted(Formatting.RED), true);
                return;
            }

            // Set the initial position to the player's eye level
            hamster.refreshPositionAndAngles(self.getX(), self.getEyeY() - 0.1, self.getZ(), self.getYaw(), self.getPitch());

            // Set Throw States
            hamster.setThrown(true);
            hamster.interactionCooldown = 10;
            hamster.throwCooldownEndTick = currentTime + config.hamsterThrowCooldown.get();

            // Dynamic Velocity Logic
            boolean isBuffed = hamster.hasGreenBeanBuff();
            float throwSpeed = isBuffed ? config.hamsterThrowVelocityBuffed.get().floatValue() : config.hamsterThrowVelocity.get().floatValue();
            Vec3d lookVec = self.getRotationVec(1.0f);
            Vec3d throwVec = new Vec3d(lookVec.x, lookVec.y + 0.1f, lookVec.z).normalize();
            hamster.setVelocity(throwVec.multiply(throwSpeed));
            hamster.velocityDirty = true;
        }

        // Finalize Dismount/Throw
        if (config.dismountOrder.get() == DismountOrder.LIFO) this.adorablehamsterpets$mountOrderQueue.pollLast();
        else this.adorablehamsterpets$mountOrderQueue.pollFirst();

        // Clear the data and trigger the manual sync packet
        this.setShoulderHamster(locationToProcess, new NbtCompound());

        // Spawn and Play Effects
        HamsterEntity.spawnFromNbt((ServerWorld) world, self, shoulderNbt, this.adorablehamsterpets$isDiamondAlertConditionMet, hamster);
        this.adorablehamsterpets$isDiamondAlertConditionMet = false;

        if (isThrow) {
            // --- Throw-Specific Effects ---
            // Play throw sound at the player's location
            world.playSound(null, self.getX(), self.getY(), self.getZ(), ModSounds.HAMSTER_THROW.get(), SoundCategory.PLAYERS, 1.0f, 1.0f);

            // Schedule airborne celebration sound with a 3-tick delay
            this.adorablehamsterpets$scheduledTasks.add(new ScheduledTask(world.getTime() + 3, () -> {
                SoundEvent celebrationSound = ModSounds.getRandomSoundFrom(ModSounds.HAMSTER_FLYING_SOUNDS, random);
                if (celebrationSound != null) {
                    world.playSound(null, self.getX(), self.getY(), self.getZ(), celebrationSound, SoundCategory.PLAYERS, 1.0f, 1.0f);
                }
            }));

            ModCriteria.HAMSTER_THROWN.trigger((ServerPlayerEntity) self);
        } else {
            // --- Standard Dismount Effects ---
            world.playSound(null, self.getBlockPos(), ModSounds.HAMSTER_DISMOUNT.get(), SoundCategory.PLAYERS, 0.7f, 1.0f + random.nextFloat() * 0.2f);
            if (config.enableShoulderDismountMessages && !DISMOUNT_MESSAGE_KEYS.isEmpty()) {
                String chosenKey;
                if (DISMOUNT_MESSAGE_KEYS.size() == 1) {
                    chosenKey = DISMOUNT_MESSAGE_KEYS.get(0);
                } else {
                    List<String> availableKeys = new ArrayList<>(DISMOUNT_MESSAGE_KEYS);
                    availableKeys.remove(this.adorablehamsterpets$lastDismountMessageKey);
                    chosenKey = availableKeys.isEmpty() ? this.adorablehamsterpets$lastDismountMessageKey : availableKeys.get(random.nextInt(availableKeys.size()));
                }
                self.sendMessage(Text.translatable(chosenKey), true);
                this.adorablehamsterpets$lastDismountMessageKey = chosenKey;
            }
        }
    }

    // --- Helper Methods ---
    /**
     * Scans a spherical area around the player for diamond ore blocks, prioritizing exposed ores.
     *
     * @param player The player to check around.
     * @param radius The radius of the sphere to scan, in blocks.
     * @return {@code true} if any diamond ore is found (with exposed ones taking precedence), otherwise {@code false}.
     */
    @Unique
    private boolean isDiamondNearby(PlayerEntity player, double radius) {
        World world = player.getWorld();
        BlockPos center = player.getBlockPos();
        int intRadius = (int) Math.ceil(radius);

        List<BlockPos> exposedOres = new ArrayList<>();
        List<BlockPos> buriedOres = new ArrayList<>();

        for (BlockPos checkPos : BlockPos.iterate(center.add(-intRadius, -intRadius, -intRadius), center.add(intRadius, intRadius, intRadius))) {
            if (checkPos.getSquaredDistance(center) <= radius * radius) {
                BlockState state = world.getBlockState(checkPos);
                if (state.isOf(Blocks.DIAMOND_ORE) || state.isOf(Blocks.DEEPSLATE_DIAMOND_ORE)) {
                    // Use the public static helper from the HamsterSeekDiamondGoal
                    if (HamsterSeekDiamondGoal.isOreExposed(checkPos, world)) {
                        exposedOres.add(checkPos.toImmutable());
                    } else {
                        buriedOres.add(checkPos.toImmutable());
                    }
                }
            }
        }
        // Prioritize exposed ores. If any are found, the condition is met.
        // If not, check if any buried ores were found as a fallback.
        return !exposedOres.isEmpty() || !buriedOres.isEmpty();
    }

    /**
     * Checks for nearby creepers that are actively targeting the player.
     * This is used for the shoulder hamster's creeper alert feature.
     *
     * @param player The player being targeted.
     * @param radius The search radius for creepers.
     * @return {@code true} if at least one creeper is found with the player as its current attack target, otherwise {@code false}.
     */
    @Unique
    private boolean creeperSeesPlayer(PlayerEntity player, double radius) {
        World world = player.getWorld();
        Box searchBox = new Box(player.getPos().subtract(radius, radius, radius), player.getPos().add(radius, radius, radius));
        List<CreeperEntity> nearbyCreepers = world.getEntitiesByClass(
                CreeperEntity.class,
                searchBox,
                creeper -> creeper.isAlive() && creeper.getTarget() == player && EntityPredicates.VALID_ENTITY.test(creeper)
        );
        return !nearbyCreepers.isEmpty();
    }

    @Unique
    @Override
    public boolean hasAnyShoulderHamster() {
        return !getShoulderHamster(ShoulderLocation.RIGHT_SHOULDER).isEmpty() ||
                !getShoulderHamster(ShoulderLocation.LEFT_SHOULDER).isEmpty() ||
                !getShoulderHamster(ShoulderLocation.HEAD).isEmpty();
    }

    @Unique
    @Override
    public int ahp_getLastGoldMessageIndex() {
        return this.adorablehamsterpets$lastGoldMessageIndex;
    }

    @Unique
    @Override
    public void ahp_setLastGoldMessageIndex(int index) {
        this.adorablehamsterpets$lastGoldMessageIndex = index;
    }

    @Unique
    @Override
    public ArrayDeque<ShoulderLocation> adorablehamsterpets$getMountOrderQueue() {
        return this.adorablehamsterpets$mountOrderQueue;
    }

    @Unique
    @Override
    public ClientShoulderHamsterData adorablehamsterpets$getClientShoulderData() {
        // Lazy initialization to support shader/fake players
        if (this.adorablehamsterpets$clientShoulderData == null && this.getWorld().isClient) {
            this.adorablehamsterpets$clientShoulderData = new ClientShoulderHamsterData();
        }
        return this.adorablehamsterpets$clientShoulderData;
    }
}
```

`RavagerEntityMixin.java`
```java
package net.dawson.adorablehamsterpets.mixin.server;

// (Imports omitted to save token count)

@Mixin(RavagerEntity.class)
public abstract class RavagerEntityMixin extends RaiderEntity {

    protected RavagerEntityMixin(EntityType<? extends RaiderEntity> entityType, World world) {
        super(entityType, world);
    }

    @Inject(method = "initGoals", at = @At("TAIL"))
    private void adorablehamsterpets$addFleeHamsterGoal(CallbackInfo ci) {
        // This predicate will read the live config value.
        Predicate<LivingEntity> fleeCondition = (livingEntity) -> AdorableHamsterPets.CONFIG.enableRavagerFlee;

        this.goalSelector.add(3, new FleeEntityGoal<>(
                this,
                HamsterEntity.class,
                6.0F,
                1.0D,
                1.2D,
                fleeCondition
        ));
    }
}
```

`SpiderEntityMixin.java`
```java
package net.dawson.adorablehamsterpets.mixin.server;

// (Imports omitted to save token count)

@Mixin(SpiderEntity.class)
public abstract class SpiderEntityMixin extends HostileEntity {

    protected SpiderEntityMixin(EntityType<? extends HostileEntity> entityType, World world) {
        super(entityType, world);
    }

    @Inject(method = "initGoals", at = @At("TAIL"))
    private void adorablehamsterpets$addFleeHamsterGoal(CallbackInfo ci) {
        // This predicate will read the live config value.
        Predicate<LivingEntity> fleeCondition = (livingEntity) -> AdorableHamsterPets.CONFIG.enableSpiderFlee;

        this.goalSelector.add(3, new FleeEntityGoal<>(
                this,
                HamsterEntity.class,
                6.0F,
                1.0D,
                1.2D,
                fleeCondition
        ));
    }
}
```

### 📂 `common/src/main/java/net/dawson/adorablehamsterpets/util/`
`HamsterRenderTracker.java`
```java
package net.dawson.adorablehamsterpets.util;

// (Imports omitted to save token count)

/**
 * A server-side utility to track which players are currently rendering which hamsters.
 * This is used to determine when to play server-side fallback sounds (like footsteps)
 * versus relying on client-side animation keyframed sounds.
 */
public class HamsterRenderTracker {
    // A thread-safe map where Key = Hamster Entity ID, Value = Set of Player UUIDs rendering it.
    private static final Map<Integer, Set<UUID>> RENDER_TRACKING_MAP = new ConcurrentHashMap<>();

    public static void addPlayer(int hamsterId, UUID playerId) {
        RENDER_TRACKING_MAP.computeIfAbsent(hamsterId, k -> Collections.newSetFromMap(new ConcurrentHashMap<>())).add(playerId);
    }

    public static void removePlayer(int hamsterId, UUID playerId) {
        Set<UUID> players = RENDER_TRACKING_MAP.get(hamsterId);
        if (players != null) {
            players.remove(playerId);
            if (players.isEmpty()) {
                RENDER_TRACKING_MAP.remove(hamsterId);
            }
        }
    }

    public static void onPlayerDisconnect(UUID playerId) {
        RENDER_TRACKING_MAP.forEach((hamsterId, playerSet) -> playerSet.remove(playerId));
        RENDER_TRACKING_MAP.entrySet().removeIf(entry -> entry.getValue().isEmpty());
    }

    public static void onEntityUnload(int hamsterId) {
        RENDER_TRACKING_MAP.remove(hamsterId);
    }

    public static boolean isBeingRendered(int hamsterId) {
        Set<UUID> players = RENDER_TRACKING_MAP.get(hamsterId);
        return players != null && !players.isEmpty();
    }
}
```

`IndoorOutdoorDetector.java`
```java
package net.dawson.adorablehamsterpets.util;

// (Imports omitted to save token count)

/**
 * A client-side utility for robust indoor vs. outdoor detection.
 * This class combines three signals with hysteresis and a small shared cache to determine if a location
 * should be considered "outdoors" for visual effects like wind.
 * <ul>
 *     <li><b>Horizontal Openness:</b> Checks for open directions around the position.</li>
 *     <li><b>Roof Clearance:</b> Measures the distance to any covering above.</li>
 *     <li><b>Corrected Skylight:</b> Checks skylight levels while accounting for glass, which blocks wind.</li>
 * </ul>
 * The results are deterministic and cached per chunk region to ensure high performance. Hysteresis is used
 * to prevent visual flickering when near an indoor/outdoor threshold.
 */
public final class IndoorOutdoorDetector {
    private IndoorOutdoorDetector() {}

    // --- Constants ---
    // --- Sampling and Cache ---
    private static final int CACHE_SIZE_BUCKETS = 1024; // Must be a power of two
    private static final int CACHE_MAX_AGE_TICKS = 18;
    private static final int MIN_RECHECK_INTERVAL_TICKS = 8;
    private static final int MAX_RECHECK_INTERVAL_JITTER_TICKS = 6; // Results in a recheck every 8-14 ticks

    // --- Horizontal Openness (A roof with open sides should feel windy) ---
    private static final int HORIZONTAL_OPENNESS_RAY_COUNT = 12;
    private static final int HORIZONTAL_OPENNESS_RAY_MAX_DISTANCE_BLOCKS = 6;
    private static final int HORIZONTAL_OPENNESS_WALL_COLUMN_HEIGHT_BLOCKS = 2;
    private static final int HORIZONTAL_OPENNESS_STRONG_SKYLIGHT_THRESHOLD = 12;
    private static final float HORIZONTAL_OPENNESS_MIN_FRACTION_THRESHOLD = 0.35f;

    // --- Roof Clearance (Nearby cover reduces wind) ---
    private static final int ROOF_CLEARANCE_VERTICAL_SEARCH_RANGE_BLOCKS = 6;

    // --- Skylight (Corrected by a clear column test so glass blocks wind) ---
    private static final int SKYLIGHT_CLEAR_COLUMN_MAX_STEPS = 16;

    // --- Score Weights and Hysteresis ---
    private static final float WEIGHT_HORIZONTAL_OPENNESS = 0.50f;
    private static final float WEIGHT_ROOF_CLEARANCE = 0.30f;
    private static final float WEIGHT_SKYLIGHT = 0.20f;
    private static final float OUTDOOR_SCORE_THRESHOLD = 0.56f; // Must exceed to flip to OUTDOOR
    private static final float INDOOR_SCORE_THRESHOLD = 0.44f;  // Must go below to flip to INDOOR

    // --- Cache ---
    private static final long[] cacheKeys = new long[CACHE_SIZE_BUCKETS];
    private static final long[] cacheLastTick = new long[CACHE_SIZE_BUCKETS];
    private static final int[] cacheNextInterval = new int[CACHE_SIZE_BUCKETS];
    private static final float[] cacheLastScore = new float[CACHE_SIZE_BUCKETS];
    private static final byte[] cacheLastState = new byte[CACHE_SIZE_BUCKETS]; // -1 unknown, 0 indoor, 1 outdoor
    static {
        for (int i = 0; i < cacheLastState.length; i++) cacheLastState[i] = -1;
    }

    // --- Public API ---

    /**
     * Determines if a given world position should be considered "outdoors" for visual effects.
     *
     * @param world The client world.
     * @param x The X coordinate.
     * @param y The Y coordinate.
     * @param z The Z coordinate.
     * @return True if the position is considered outdoors, false otherwise.
     */
    public static boolean isOutdoor(ClientWorld world, double x, double y, double z) {
        if (!world.getDimension().hasSkyLight()) return false; // Nether/End are always indoors for wind

        final long nowTick = world.getTime();
        final BlockPos basePos = BlockPos.ofFloored(x, y + 0.2, z);
        final long key = keyFor(world, basePos);
        final int idx = bucketIndex(key);

        // Create or refresh entry if missing or expired
        if (cacheKeys[idx] != key || (nowTick - cacheLastTick[idx]) > CACHE_MAX_AGE_TICKS) {
            cacheKeys[idx] = key;
            cacheLastTick[idx] = nowTick;
            cacheNextInterval[idx] = randomRecheckInterval(key);
            cacheLastState[idx] = -1; // unknown
        }

        // Recompute if interval has elapsed or state is unknown
        boolean needRecheck = (cacheLastState[idx] == -1) || ((nowTick - cacheLastTick[idx]) >= cacheNextInterval[idx]);
        if (needRecheck) {
            float score = computeOutdoorScore(world, basePos);
            cacheLastScore[idx] = score;
            cacheLastTick[idx] = nowTick;
            cacheNextInterval[idx] = randomRecheckInterval(key);

            // Hysteresis logic to prevent flickering at thresholds
            byte previous = cacheLastState[idx];
            boolean newIsOutdoor;
            if (previous == -1) { // Was unknown
                newIsOutdoor = score >= OUTDOOR_SCORE_THRESHOLD;
            } else if (previous == 1) { // Was outdoor
                newIsOutdoor = score >= INDOOR_SCORE_THRESHOLD; // Stay outdoor unless score is strongly indoor
            } else { // Was indoor
                newIsOutdoor = score >= OUTDOOR_SCORE_THRESHOLD; // Need a stronger score to flip to outdoor
            }
            cacheLastState[idx] = newIsOutdoor ? (byte)1 : (byte)0;
        }

        return cacheLastState[idx] == 1;
    }

    // --- Scoring Logic ---

    private static float computeOutdoorScore(ClientWorld world, BlockPos pos) {
        float horizontalOpenFrac = horizontalOpennessFraction(world, pos);
        float roofClearanceScore = roofClearanceFactor(world, pos);
        float skylightScore = skylightFactorCorrected(world, pos);

        // Weighted sum of all factors
        float score = WEIGHT_HORIZONTAL_OPENNESS * horizontalOpenFrac
                + WEIGHT_ROOF_CLEARANCE * roofClearanceScore
                + WEIGHT_SKYLIGHT * skylightScore;

        return MathHelper.clamp(score, 0f, 1f);
    }

    /** More open directions result in a score closer to 1.0. */
    private static float horizontalOpennessFraction(ClientWorld world, BlockPos base) {
        int openDirections = 0;
        for (int i = 0; i < HORIZONTAL_OPENNESS_RAY_COUNT; i++) {
            double ang = (MathHelper.TAU * i) / HORIZONTAL_OPENNESS_RAY_COUNT;
            double cos = Math.cos(ang), sin = Math.sin(ang);

            boolean reachedOpening = false;

            // March outward from the base position
            for (int d = 1; d <= HORIZONTAL_OPENNESS_RAY_MAX_DISTANCE_BLOCKS && !reachedOpening; d++) {
                int sx = base.getX() + (int)Math.round(cos * d);
                int sz = base.getZ() + (int)Math.round(sin * d);

                // A two-block non-porous column counts as a wall
                boolean hardBlocked = false;
                for (int h = 0; h < HORIZONTAL_OPENNESS_WALL_COLUMN_HEIGHT_BLOCKS; h++) {
                    BlockPos p = new BlockPos(sx, base.getY() + h, sz);
                    if (isNonPorousWindBlock(world.getBlockState(p), world, p)) {
                        hardBlocked = true;
                        break;
                    }
                }
                if (hardBlocked) break; // This direction is closed

                // If this column can see the sky or has strong skylight, it's an opening
                BlockPos check = new BlockPos(sx, base.getY() + 1, sz);
                if (world.isSkyVisible(check) || world.getLightLevel(LightType.SKY, check) >= HORIZONTAL_OPENNESS_STRONG_SKYLIGHT_THRESHOLD) {
                    reachedOpening = true;
                    break;
                }
            }
            if (reachedOpening) openDirections++;
        }
        float frac = openDirections / (float) HORIZONTAL_OPENNESS_RAY_COUNT;
        // Nudge score toward zero if extremely closed to avoid misclassifying tiny slits
        return frac < HORIZONTAL_OPENNESS_MIN_FRACTION_THRESHOLD ? frac * 0.8f : frac;
    }

    /** More clearance up to the search range results in a score closer to 1.0. */
    private static float roofClearanceFactor(ClientWorld world, BlockPos pos) {
        int clearance = 0;
        // Scan upwards from the particle's position.
        for (int i = 1; i <= ROOF_CLEARANCE_VERTICAL_SEARCH_RANGE_BLOCKS; i++) {
            BlockPos checkPos = pos.up(i);
            BlockState state = world.getBlockState(checkPos);
            // A non-porous block is considered a roof.
            if (isNonPorousWindBlock(state, world, checkPos)) {
                break; // Found the roof, stop counting.
            }
            clearance++; // The number of clear blocks above
        }
        return MathHelper.clamp(clearance / (float) ROOF_CLEARANCE_VERTICAL_SEARCH_RANGE_BLOCKS, 0f, 1f);
    }

    /** Skylight scaled to [0,1], but clamped to zero if a blocking or glass block is found above. */
    private static float skylightFactorCorrected(ClientWorld world, BlockPos pos) {
        if (!columnToSkyIsClear(world, pos, SKYLIGHT_CLEAR_COLUMN_MAX_STEPS)) return 0.0f;
        int sky = world.getLightLevel(LightType.SKY, pos);
        return MathHelper.clamp(sky / 15.0f, 0f, 1f);
    }

    // --- Block Property Checks ---

    /** Checks if there is no solid or glass-like block within maxSteps above the position. */
    private static boolean columnToSkyIsClear(ClientWorld world, BlockPos from, int maxSteps) {
        for (int dy = 1; dy <= maxSteps; dy++) {
            BlockPos p = from.up(dy);
            BlockState s = world.getBlockState(p);
            if (isGlassLike(s) || s.getBlock() instanceof PaneBlock) return false;
            if (!s.isAir() && !s.getCollisionShape(world, p).isEmpty()) return false;
        }
        return true;
    }

    /** A non-porous wind blocker has a solid collision shape and is not a porous block like a fence or leaves. */
    private static boolean isNonPorousWindBlock(BlockState s, ClientWorld world, BlockPos at) {
        if (s.isAir()) return false;
        Block block = s.getBlock();
        if (block instanceof FenceBlock || block instanceof LeavesBlock) return false;
        if (isGlassLike(s) || block instanceof PaneBlock) return true; // Glass blocks wind
        return !s.getCollisionShape(world, at).isEmpty();
    }

    /** Checks if a block is a solid glass-type block (clear, stained, or tinted). */
    private static boolean isGlassLike(BlockState state) {
        Block block = state.getBlock();
        return block == Blocks.GLASS || block instanceof StainedGlassBlock || block instanceof TintedGlassBlock;
    }

    // --- Cache Management ---

    private static long keyFor(ClientWorld world, BlockPos pos) {
        int cellX = pos.getX() >> 1;
        int cellZ = pos.getZ() >> 1;
        int yQuart = pos.getY() >> 1;
        long dimHint = world.getDimension().hasSkyLight() ? 1L : 2L;
        long k = (dimHint << 48)
                ^ (((long)cellX & 0xFFFFL) << 32)
                ^ (((long)cellZ & 0xFFFFL) << 16)
                ^ ((long)yQuart & 0xFFFFL);
        return mix64(k, 0xD1B54A32D192ED03L);
    }

    private static int bucketIndex(long key) {
        return (int)(key & (CACHE_SIZE_BUCKETS - 1));
    }

    private static int randomRecheckInterval(long key) {
        long m = mix64(key, 0x9E3779B97F4A7C15L);
        int jitter = (int)((m >>> 57) & MAX_RECHECK_INTERVAL_JITTER_TICKS);
        return MIN_RECHECK_INTERVAL_TICKS + jitter;
    }

    private static long mix64(long seedA, long seedB) {
        long x = seedA * 0x9E3779B97F4A7C15L + seedB + 0xBF58476D1CE4E5B9L;
        x ^= (x >>> 30);
        x *= 0xBF58476D1CE4E5B9L;
        x ^= (x >>> 27);
        x *= 0x94D049BB133111EBL;
        x ^= (x >>> 31);
        return x;
    }
}
```

`ModNbtKeys.java`
```java
package net.dawson.adorablehamsterpets.util;

public class ModNbtKeys {
    public static final String LINKED_HAMSTER_UUID = "LinkedHamsterUuid";
    public static final String LINKED_HAMSTER_NAME = "LinkedHamsterName";
    public static final String WANDER_DISTANCE = "WanderDistance";
    public static final String WOOD_VARIANT = "WoodVariant";
}
```

`ParticleBreadcrumbHelper.java`
```java
package net.dawson.adorablehamsterpets.util;

// (Imports omitted to save token count)

/**
 * A utility class for spawning a trail of mycelium particles along the future nodes of a given path.
 */
public class ParticleBreadcrumbHelper {

    public static void spawnBreadcrumbs(ServerWorld world, @Nullable Path path) {
        if (path == null) {
            return;
        }

        int currentNodeIndex = path.getCurrentNodeIndex();
        int pathLength = path.getLength();

        // Iterate from the current node to the end of the path
        for (int i = currentNodeIndex; i < pathLength; i++) {
            PathNode node = path.getNode(i);
            Vec3d directionVector = Vec3d.ZERO; // Default to no direction

            // 1. Determine the direction to the next node in the path.
            if (i + 1 < pathLength) {
                PathNode nextNode = path.getNode(i + 1);
                // Create a normalized (length of 1) vector pointing from the current node to the next.
                directionVector = new Vec3d(nextNode.x - node.x, 0, nextNode.z - node.z).normalize();
            }
            // For the very last node, directionVector will remain (0,0,0), so particles will cluster around it.

            // Loop to spawn multiple particles with randomized origins
            for (int p = 0; p < 3; p++) {
                // 2. Calculate a random distance to spread the particle along the direction vector.
                double distanceAlongPath = world.getRandom().nextDouble(); // Random value from 0.0 to 1.0
                Vec3d pathOffset = directionVector.multiply(distanceAlongPath);

                // 3. Calculate limited vertical offset.
                double offsetY = (world.getRandom().nextDouble() - 0.5) * 0.1;

                world.spawnParticles(
                        ParticleTypes.MYCELIUM,
                        node.x + 0.5 + pathOffset.x,      // Center X + directional offset X
                        (node.y + 0.5) - 0.38 + offsetY,     // Center Y + limited vertical offset
                        node.z + 0.5 + pathOffset.z,         // Center Z + directional offset Z
                        1,                                   // Count is 1
                        0.2, 0.0, 0.2,          // Vertical Spread is 0
                        3                                    // Speed
                );
            }
        }
    }
}
```

### 📂 `common/src/main/resources/`
`adorablehamsterpets.mixins.json`
```json
{
  "required": true,
  "package": "net.dawson.adorablehamsterpets.mixin",
  "compatibilityLevel": "JAVA_17",
  "refmap": "adorablehamsterpets-common-refmap.json",
  "mixins": [
    "server.RavagerEntityMixin",
    "server.SpiderEntityMixin",
    "server.PlayerEntityMixin",
    "accessor.SlotAccessor",
    "accessor.MeleeAttackGoalAccessor",
    "accessor.LandPathNodeMakerInvoker",
    "accessor.LookAtEntityGoalAccessor",
    "accessor.LookAroundGoalAccessor",
    "accessor.FollowOwnerGoalAccessor",
    "accessor.TemptGoalAccessor",
    "accessor.ValidatedFieldAccessor"
  ],
  "client": [
    "client.GuiBookLandingMixin",
    "client.GuiButtonEntryMixin",
    "client.GuiBookEntryListMixin",
    "client.PlayerEntityRendererMixin",
    "client.LivingEntityRendererInvoker",
    "client.AbstractClientPlayerEntityMixin",
    "client.TitleScreenMixin",
    "client.BookContentsMixin",
    "client.BookContentsBuilderMixin",
    "client.accessor.HandledScreenAccessor",
    "client.GuiButtonBookMarkReadMixin",
    "client.GuiBookIndexMixin",
    "client.accessor.GuiBookAccessor",
    "client.accessor.GuiButtonEntryAccessor",
    "accessor.ScreenWidgetAdder",
    "accessor.BookContentsBuilderAccessor",
    "client.accessor.ClickableWidgetAccessor"
  ],
  "injectors": {
    "defaultRequire": 1
  }
}
```

`pack.mcmeta`
```json
{
  "pack": {
    "pack_format": 15,
    "description": "Adorable Hamster Pets resources"
  }
}
```

### 📂 `common/src/main/resources/assets/`
`LICENSE_NOTICE.txt`
```text
ASSET LICENSE NOTICE

All non-code assets in this folder (including textures, models, animations, sounds, and other media)
are NOT licensed under the GNU LGPL.

These assets are All Rights Reserved.
See the repository root file "ASSETS_LICENSE.txt" for the full terms.
```

### 📂 `common/src/main/resources/assets/adorablehamsterpets/`
`sounds.json`
```json
{
  "hamster_impact": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_impact",
    "sounds": [ "adorablehamsterpets:cartoon_punches" ]
  },
  "hamster_throw": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_throw",
    "sounds": [ "adorablehamsterpets:hamster_throw" ]
  },
  "hamster_throw_reversed": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_throw",
    "sounds": [ "adorablehamsterpets:hamster_throw_reversed" ]
  },
  "hamster_airborne_celebration": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_flying",
    "sounds": [ "adorablehamsterpets:hamster_airborne_celebration" ]
  },
  "hamster_wow": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_flying",
    "sounds": [ "adorablehamsterpets:hamster_wow" ]
  },
  "hamster_attack1": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_attack",
    "sounds": [ "adorablehamsterpets:hamster_attack1" ]
  },
  "hamster_attack2": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_attack",
    "sounds": [ "adorablehamsterpets:hamster_attack2" ]
  },
  "hamster_attack3": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_attack",
    "sounds": [ "adorablehamsterpets:hamster_attack3" ]
  },
  "hamster_attack4": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_attack",
    "sounds": [ "adorablehamsterpets:hamster_attack4" ]
  },
  "hamster_beg1": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_beg",
    "sounds": [ "adorablehamsterpets:hamster_beg1" ]
  },
  "hamster_beg2": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_beg",
    "sounds": [ "adorablehamsterpets:hamster_beg2" ]
  },
  "hamster_beg3": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_beg",
    "sounds": [ "adorablehamsterpets:hamster_beg3" ]
  },
  "hamster_beg4": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_beg",
    "sounds": [ "adorablehamsterpets:hamster_beg4" ]
  },
  "hamster_beg5": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_beg",
    "sounds": [ "adorablehamsterpets:hamster_beg5" ]
  },
  "hamster_celebrate1": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_celebrate",
    "sounds": [ "adorablehamsterpets:hamster_celebrate1" ]
  },
  "hamster_celebrate2": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_celebrate",
    "sounds": [ "adorablehamsterpets:hamster_celebrate2" ]
  },
  "hamster_celebrate3": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_celebrate",
    "sounds": [ "adorablehamsterpets:hamster_celebrate3" ]
  },
  "hamster_celebrate4": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_celebrate",
    "sounds": [ "adorablehamsterpets:hamster_celebrate4" ]
  },
  "hamster_creeper_detect1": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_creeper_detect",
    "sounds": [ "adorablehamsterpets:hamster_creeper_detect1" ]
  },
  "hamster_creeper_detect2": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_creeper_detect",
    "sounds": [ "adorablehamsterpets:hamster_creeper_detect2" ]
  },
  "hamster_creeper_detect3": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_creeper_detect",
    "sounds": [ "adorablehamsterpets:hamster_creeper_detect3" ]
  },
  "hamster_creeper_detect4": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_creeper_detect",
    "sounds": [ "adorablehamsterpets:hamster_creeper_detect4" ]
  },
  "hamster_sniff1": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_sniff",
    "sounds": [ "adorablehamsterpets:hamster_sniff1" ]
  },
  "hamster_sniff2": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_sniff",
    "sounds": [ "adorablehamsterpets:hamster_sniff2" ]
  },
  "hamster_sniff3": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_sniff",
    "sounds": [ "adorablehamsterpets:hamster_sniff3" ]
  },
  "hamster_sniff4": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_sniff",
    "sounds": [ "adorablehamsterpets:hamster_sniff4" ]
  },
  "hamster_death1": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_death",
    "sounds": [ "adorablehamsterpets:hamster_death1" ]
  },
  "hamster_death2": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_death",
    "sounds": [ "adorablehamsterpets:hamster_death2" ]
  },
  "hamster_death3": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_death",
    "sounds": [ "adorablehamsterpets:hamster_death3" ]
  },
  "hamster_death4": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_death",
    "sounds": [ "adorablehamsterpets:hamster_death4" ]
  },
  "hamster_hurt1": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_hurt",
    "sounds": [ "adorablehamsterpets:hamster_hurt1" ]
  },
  "hamster_hurt2": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_hurt",
    "sounds": [ "adorablehamsterpets:hamster_hurt2" ]
  },
  "hamster_hurt3": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_hurt",
    "sounds": [ "adorablehamsterpets:hamster_hurt3" ]
  },
  "hamster_hurt4": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_hurt",
    "sounds": [ "adorablehamsterpets:hamster_hurt4" ]
  },
  "hamster_hurt5": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_hurt",
    "sounds": [ "adorablehamsterpets:hamster_hurt5" ]
  },
  "hamster_hurt6": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_hurt",
    "sounds": [ "adorablehamsterpets:hamster_hurt6" ]
  },
  "hamster_hurt7": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_hurt",
    "sounds": [ "adorablehamsterpets:hamster_hurt7" ]
  },
  "hamster_hurt8": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_hurt",
    "sounds": [ "adorablehamsterpets:hamster_hurt8" ]
  },
  "hamster_hurt9": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_hurt",
    "sounds": [ "adorablehamsterpets:hamster_hurt9" ]
  },
  "hamster_hurt10": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_hurt",
    "sounds": [ "adorablehamsterpets:hamster_hurt10" ]
  },
  "hamster_idle1": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_idle",
    "sounds": [ "adorablehamsterpets:hamster_idle1" ]
  },
  "hamster_idle2": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_idle",
    "sounds": [ "adorablehamsterpets:hamster_idle2" ]
  },
  "hamster_idle3": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_idle",
    "sounds": [ "adorablehamsterpets:hamster_idle3" ]
  },
  "hamster_idle4": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_idle",
    "sounds": [ "adorablehamsterpets:hamster_idle4" ]
  },
  "hamster_idle5": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_idle",
    "sounds": [ "adorablehamsterpets:hamster_idle5" ]
  },
  "hamster_idle6": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_idle",
    "sounds": [ "adorablehamsterpets:hamster_idle6" ]
  },
  "hamster_idle7": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_idle",
    "sounds": [ "adorablehamsterpets:hamster_idle7" ]
  },
  "hamster_idle8": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_idle",
    "sounds": [ "adorablehamsterpets:hamster_idle8" ]
  },
  "hamster_idle9": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_idle",
    "sounds": [ "adorablehamsterpets:hamster_idle9" ]
  },
  "hamster_idle10": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_idle",
    "sounds": [ "adorablehamsterpets:hamster_idle10" ]
  },
  "hamster_idle11": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_idle",
    "sounds": [ "adorablehamsterpets:hamster_idle11" ]
  },
  "hamster_sleep1": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_sleep",
    "sounds": [ "adorablehamsterpets:hamster_sleep1" ]
  },
  "hamster_sleep2": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_sleep",
    "sounds": [ "adorablehamsterpets:hamster_sleep2" ]
  },
  "hamster_sleep3": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_sleep",
    "sounds": [ "adorablehamsterpets:hamster_sleep3" ]
  },
  "hamster_sleep4": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_sleep",
    "sounds": [ "adorablehamsterpets:hamster_sleep4" ]
  },
  "hamster_sleep5": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_sleep",
    "sounds": [ "adorablehamsterpets:hamster_sleep5" ]
  },
  "hamster_sleep6": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_sleep",
    "sounds": [ "adorablehamsterpets:hamster_sleep6" ]
  },
  "hamster_sleep7": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_sleep",
    "sounds": [ "adorablehamsterpets:hamster_sleep7" ]
  },
  "hamster_sleep8": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_sleep",
    "sounds": [ "adorablehamsterpets:hamster_sleep8" ]
  },
  "hamster_sleep9": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_sleep",
    "sounds": [ "adorablehamsterpets:hamster_sleep9" ]
  },
  "hamster_wake_up1": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_wake_up",
    "sounds": [ "adorablehamsterpets:hamster_wake_up1" ]
  },
  "hamster_wake_up2": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_wake_up",
    "sounds": [ "adorablehamsterpets:hamster_wake_up2" ]
  },
  "hamster_wake_up3": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_wake_up",
    "sounds": [ "adorablehamsterpets:hamster_wake_up3" ]
  },
  "cheese_use": {
    "subtitle": "subtitles.adorablehamsterpets.cheese_use",
    "sounds": [
      "adorablehamsterpets:cheese_use"
    ]
  },
  "cheese_eat1": {
    "subtitle": "subtitles.adorablehamsterpets.cheese_eat",
    "sounds": [ "adorablehamsterpets:cheese_eat1" ]
  },
  "cheese_eat2": {
    "subtitle": "subtitles.adorablehamsterpets.cheese_eat",
    "sounds": [ "adorablehamsterpets:cheese_eat2" ]
  },
  "cheese_eat3": {
    "subtitle": "subtitles.adorablehamsterpets.cheese_eat",
    "sounds": [ "adorablehamsterpets:cheese_eat3" ]
  },
  "hamster_mount1": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_mount",
    "sounds": [ "adorablehamsterpets:hamster_mount1" ]
  },
  "hamster_mount2": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_mount",
    "sounds": [ "adorablehamsterpets:hamster_mount2" ]
  },
  "hamster_mount3": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_mount",
    "sounds": [ "adorablehamsterpets:hamster_mount3" ]
  },
  "hamster_dismount": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_dismount",
    "sounds": [ "adorablehamsterpets:hamster_dismount" ]
  },
  "hamster_scratch": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_scratch",
    "sounds": [ "adorablehamsterpets:hamster_scratch" ]
  },
  "hamster_bounce": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_bounce",
    "sounds": [ "adorablehamsterpets:hamster_bounce" ]
  },
  "alarm_orchestra_hit": {
    "subtitle": "subtitles.adorablehamsterpets.alarm_orchestra_hit",
    "sounds": [ "adorablehamsterpets:alarm_orchestra_hit" ]
  },
  "hamster_shocked": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_shocked",
    "sounds": [ "adorablehamsterpets:hamster_shocked" ]
  },
  "hamster_affection1": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_affection",
    "sounds": [ "adorablehamsterpets:hamster_affection1" ]
  },
  "hamster_affection2": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_affection",
    "sounds": [ "adorablehamsterpets:hamster_affection2" ]
  },
  "hamster_affection3": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_affection",
    "sounds": [ "adorablehamsterpets:hamster_affection3" ]
  },
  "diamond_sparkle1": {
    "subtitle": "subtitles.adorablehamsterpets.diamond_sparkle",
    "sounds": [ "adorablehamsterpets:diamond_sparkle1" ]
  },
  "diamond_sparkle2": {
    "subtitle": "subtitles.adorablehamsterpets.diamond_sparkle",
    "sounds": [ "adorablehamsterpets:diamond_sparkle2" ]
  },
  "diamond_sparkle3": {
    "subtitle": "subtitles.adorablehamsterpets.diamond_sparkle",
    "sounds": [ "adorablehamsterpets:diamond_sparkle3" ]
  },
  "hamster_diamond_pounce": {
    "subtitle": "subtitles.adorablehamsterpets.diamond_pounce",
    "sounds": [
      "adorablehamsterpets:hamster_diamond_pounce"
    ]
  },
  "hamster_shoulder_impact1": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_bounce",
    "sounds": [ "adorablehamsterpets:hamster_shoulder_impact1" ]
  },
  "hamster_shoulder_impact2": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_bounce",
    "sounds": [ "adorablehamsterpets:hamster_shoulder_impact2" ]
  },
  "hamster_shoulder_impact3": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_bounce",
    "sounds": [ "adorablehamsterpets:hamster_shoulder_impact3" ]
  },
  "hamster_bed_leaves_rustle1": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_bed_rustle",
    "sounds": [ "adorablehamsterpets:hamster_bed_leaves_rustle1" ]
  },
  "hamster_bed_leaves_rustle2": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_bed_rustle",
    "sounds": [ "adorablehamsterpets:hamster_bed_leaves_rustle2" ]
  },
  "hamster_bed_leaves_rustle3": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_bed_rustle",
    "sounds": [ "adorablehamsterpets:hamster_bed_leaves_rustle3" ]
  },
  "hamster_thump": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_thump",
    "sounds": [ "adorablehamsterpets:hamster_thump" ]
  },
  "hamster_swish": {
    "subtitle": "subtitles.adorablehamsterpets.hamster_swish",
    "sounds": [ "adorablehamsterpets:hamster_swish" ]
  },
  "gentle_breeze": {
    "subtitle": "subtitles.adorablehamsterpets.gentle_breeze",
    "sounds": [ "adorablehamsterpets:gentle_breeze" ]
  }
}
```

### 📂 `common/src/main/resources/assets/xaerominimap/entity/icon/definition/adorablehamsterpets/`
`hamster.json`
```json
{
    "variants": {
	"default" : "outlined_sprite:adorablehamsterpets/xaerosminimap_hamster_icon.png",
	"layersAllowed": true
    }
}
```

### 📂 `common/src/main/resources/assets/xaerominimap/entity/icon/sprite/adorablehamsterpets/`
`xaerosminimap_hamster_icon.png`

### 📂 `common/src/main/resources/assets/adorablehamsterpets/patchouli_books/hamster_tips_guide_book/en_us/categories/`
`accessories.json` (Content omitted)
`advanced_rodentry.json` (Content omitted)
`crops_food.json` (Content omitted)
`shoulder_hamsters.json` (Content omitted)
`the_hamster_life.json` (Content omitted)
`the_kitchen_drawer.json` (Content omitted)

### 📂 `common/src/main/resources/assets/adorablehamsterpets/patchouli_books/hamster_tips_guide_book/en_us/entries/accessories/`
`haute_couter.json` (Content omitted)

### 📂 `common/src/main/resources/assets/adorablehamsterpets/patchouli_books/hamster_tips_guide_book/en_us/entries/advanced_rodentry/`
`cheek_pouches.json` (Content omitted)
`hamster_bed.json` (Content omitted)
`psychological_warfare.json` (Content omitted)
`subterranean_shinies.json` (Content omitted)

### 📂 `common/src/main/resources/assets/adorablehamsterpets/patchouli_books/hamster_tips_guide_book/en_us/entries/crops_food/`
`cheese.json` (Content omitted)
`cucumber.json` (Content omitted)
`green_beans.json` (Content omitted)
`hamster_food_mix.json` (Content omitted)
`sunflower.json` (Content omitted)

### 📂 `common/src/main/resources/assets/adorablehamsterpets/patchouli_books/hamster_tips_guide_book/en_us/entries/shoulder_hamsters/`
`creeper_paranoia.json` (Content omitted)
`the_hamster_yeet.json` (Content omitted)
`tiny_prospector.json` (Content omitted)

### 📂 `common/src/main/resources/assets/adorablehamsterpets/patchouli_books/hamster_tips_guide_book/en_us/entries/the_hamster_life/`
`basic_care.json` (Content omitted)
`feeding.json` (Content omitted)
`regional_rodents.json` (Content omitted)
`taming.json` (Content omitted)

### 📂 `common/src/main/resources/assets/adorablehamsterpets/patchouli_books/hamster_tips_guide_book/en_us/entries/the_kitchen_drawer/`
`config_heaven.json` (Content omitted)
`join_the_discord.json` (Content omitted)
`missing_book.json` (Content omitted)
`support_the_mod.json` (Content omitted)

### 📂 `common/src/main/resources/data/adorablehamsterpets/patchouli_books/hamster_tips_guide_book/`
`book.json`
```json
{
  "name": "book.adorablehamsterpets.hamster_guide_book.title",
  "subtitle": "book.adorablehamsterpets.hamster_guide_book.subtitle",
  "landing_text": "book.adorablehamsterpets.category.landing_page.desc",
  "version": 0,
  "book_texture": "adorablehamsterpets:textures/gui/hamster_guide_book_ui.png",
  "model": "adorablehamsterpets:hamster_guide_book",
  "index_icon": "adorablehamsterpets:hamster_guide_book",
  "text_color": "000000",
  "header_color": "333333",
  "link_color": "00AAAA",
  "link_hover_color": "FFC366",
  "use_blocky_font": true,
  "use_resource_pack": true,
  "show_progress": false,
  "text_overflow_mode": "overflow",
  "enable_editor": false,
  "filler_texture": "adorablehamsterpets:textures/gui/blank_page_filler.png",
  "i18n": true,
  "pause_game": true,
  "macros": {
    "<b>": "$(l)",
    "<i>": "$(o)",
    "<u>": "$(n)",
    "</>": "$()",
    "<red>": "$(#AA0000)",
    "<gold>": "$(#FFAA00)",
    "<dark_green>": "$(#00AA00)",
    "<dark_aqua>": "$(#00AAAA)",
    "<pink>": "$(#FF55FF)",
    "<light_gray>": "$(#938a80)"
  }
}
```

### 📂 `common/src/main/resources/assets/adorablehamsterpets/blockstates/`
`hamster_bed.json`
```json
{
  "variants": {
    "occupied=false,orientation=north,upside_down=false,wood_variant=oak": { "model": "adorablehamsterpets:block/hamster_bed_oak" },
    "occupied=false,orientation=south,upside_down=false,wood_variant=oak": { "model": "adorablehamsterpets:block/hamster_bed_oak" },
    "occupied=false,orientation=west,upside_down=false,wood_variant=oak": { "model": "adorablehamsterpets:block/hamster_bed_oak" },
    "occupied=false,orientation=east,upside_down=false,wood_variant=oak": { "model": "adorablehamsterpets:block/hamster_bed_oak" },
    "occupied=true,orientation=north,upside_down=false,wood_variant=oak": { "model": "adorablehamsterpets:block/hamster_bed_oak" },
    "occupied=true,orientation=south,upside_down=false,wood_variant=oak": { "model": "adorablehamsterpets:block/hamster_bed_oak" },
    "occupied=true,orientation=west,upside_down=false,wood_variant=oak": { "model": "adorablehamsterpets:block/hamster_bed_oak" },
    "occupied=true,orientation=east,upside_down=false,wood_variant=oak": { "model": "adorablehamsterpets:block/hamster_bed_oak" },
    "occupied=false,orientation=north,upside_down=true,wood_variant=oak": { "model": "adorablehamsterpets:block/hamster_bed_oak" },
    "occupied=false,orientation=south,upside_down=true,wood_variant=oak": { "model": "adorablehamsterpets:block/hamster_bed_oak" },
    "occupied=false,orientation=west,upside_down=true,wood_variant=oak": { "model": "adorablehamsterpets:block/hamster_bed_oak" },
    "occupied=false,orientation=east,upside_down=true,wood_variant=oak": { "model": "adorablehamsterpets:block/hamster_bed_oak" },
    "occupied=true,orientation=north,upside_down=true,wood_variant=oak": { "model": "adorablehamsterpets:block/hamster_bed_oak" },
    "occupied=true,orientation=south,upside_down=true,wood_variant=oak": { "model": "adorablehamsterpets:block/hamster_bed_oak" },
    "occupied=true,orientation=west,upside_down=true,wood_variant=oak": { "model": "adorablehamsterpets:block/hamster_bed_oak" },
    "occupied=true,orientation=east,upside_down=true,wood_variant=oak": { "model": "adorablehamsterpets:block/hamster_bed_oak" },

    "occupied=false,orientation=north,upside_down=false,wood_variant=spruce": { "model": "adorablehamsterpets:block/hamster_bed_spruce" },
    "occupied=false,orientation=south,upside_down=false,wood_variant=spruce": { "model": "adorablehamsterpets:block/hamster_bed_spruce" },
    "occupied=false,orientation=west,upside_down=false,wood_variant=spruce": { "model": "adorablehamsterpets:block/hamster_bed_spruce" },
    "occupied=false,orientation=east,upside_down=false,wood_variant=spruce": { "model": "adorablehamsterpets:block/hamster_bed_spruce" },
    "occupied=true,orientation=north,upside_down=false,wood_variant=spruce": { "model": "adorablehamsterpets:block/hamster_bed_spruce" },
    "occupied=true,orientation=south,upside_down=false,wood_variant=spruce": { "model": "adorablehamsterpets:block/hamster_bed_spruce" },
    "occupied=true,orientation=west,upside_down=false,wood_variant=spruce": { "model": "adorablehamsterpets:block/hamster_bed_spruce" },
    "occupied=true,orientation=east,upside_down=false,wood_variant=spruce": { "model": "adorablehamsterpets:block/hamster_bed_spruce" },
    "occupied=false,orientation=north,upside_down=true,wood_variant=spruce": { "model": "adorablehamsterpets:block/hamster_bed_spruce" },
    "occupied=false,orientation=south,upside_down=true,wood_variant=spruce": { "model": "adorablehamsterpets:block/hamster_bed_spruce" },
    "occupied=false,orientation=west,upside_down=true,wood_variant=spruce": { "model": "adorablehamsterpets:block/hamster_bed_spruce" },
    "occupied=false,orientation=east,upside_down=true,wood_variant=spruce": { "model": "adorablehamsterpets:block/hamster_bed_spruce" },
    "occupied=true,orientation=north,upside_down=true,wood_variant=spruce": { "model": "adorablehamsterpets:block/hamster_bed_spruce" },
    "occupied=true,orientation=south,upside_down=true,wood_variant=spruce": { "model": "adorablehamsterpets:block/hamster_bed_spruce" },
    "occupied=true,orientation=west,upside_down=true,wood_variant=spruce": { "model": "adorablehamsterpets:block/hamster_bed_spruce" },
    "occupied=true,orientation=east,upside_down=true,wood_variant=spruce": { "model": "adorablehamsterpets:block/hamster_bed_spruce" },

    "occupied=false,orientation=north,upside_down=false,wood_variant=birch": { "model": "adorablehamsterpets:block/hamster_bed_birch" },
    "occupied=false,orientation=south,upside_down=false,wood_variant=birch": { "model": "adorablehamsterpets:block/hamster_bed_birch" },
    "occupied=false,orientation=west,upside_down=false,wood_variant=birch": { "model": "adorablehamsterpets:block/hamster_bed_birch" },
    "occupied=false,orientation=east,upside_down=false,wood_variant=birch": { "model": "adorablehamsterpets:block/hamster_bed_birch" },
    "occupied=true,orientation=north,upside_down=false,wood_variant=birch": { "model": "adorablehamsterpets:block/hamster_bed_birch" },
    "occupied=true,orientation=south,upside_down=false,wood_variant=birch": { "model": "adorablehamsterpets:block/hamster_bed_birch" },
    "occupied=true,orientation=west,upside_down=false,wood_variant=birch": { "model": "adorablehamsterpets:block/hamster_bed_birch" },
    "occupied=true,orientation=east,upside_down=false,wood_variant=birch": { "model": "adorablehamsterpets:block/hamster_bed_birch" },
    "occupied=false,orientation=north,upside_down=true,wood_variant=birch": { "model": "adorablehamsterpets:block/hamster_bed_birch" },
    "occupied=false,orientation=south,upside_down=true,wood_variant=birch": { "model": "adorablehamsterpets:block/hamster_bed_birch" },
    "occupied=false,orientation=west,upside_down=true,wood_variant=birch": { "model": "adorablehamsterpets:block/hamster_bed_birch" },
    "occupied=false,orientation=east,upside_down=true,wood_variant=birch": { "model": "adorablehamsterpets:block/hamster_bed_birch" },
    "occupied=true,orientation=north,upside_down=true,wood_variant=birch": { "model": "adorablehamsterpets:block/hamster_bed_birch" },
    "occupied=true,orientation=south,upside_down=true,wood_variant=birch": { "model": "adorablehamsterpets:block/hamster_bed_birch" },
    "occupied=true,orientation=west,upside_down=true,wood_variant=birch": { "model": "adorablehamsterpets:block/hamster_bed_birch" },
    "occupied=true,orientation=east,upside_down=true,wood_variant=birch": { "model": "adorablehamsterpets:block/hamster_bed_birch" },

    "occupied=false,orientation=north,upside_down=false,wood_variant=jungle": { "model": "adorablehamsterpets:block/hamster_bed_jungle" },
    "occupied=false,orientation=south,upside_down=false,wood_variant=jungle": { "model": "adorablehamsterpets:block/hamster_bed_jungle" },
    "occupied=false,orientation=west,upside_down=false,wood_variant=jungle": { "model": "adorablehamsterpets:block/hamster_bed_jungle" },
    "occupied=false,orientation=east,upside_down=false,wood_variant=jungle": { "model": "adorablehamsterpets:block/hamster_bed_jungle" },
    "occupied=true,orientation=north,upside_down=false,wood_variant=jungle": { "model": "adorablehamsterpets:block/hamster_bed_jungle" },
    "occupied=true,orientation=south,upside_down=false,wood_variant=jungle": { "model": "adorablehamsterpets:block/hamster_bed_jungle" },
    "occupied=true,orientation=west,upside_down=false,wood_variant=jungle": { "model": "adorablehamsterpets:block/hamster_bed_jungle" },
    "occupied=true,orientation=east,upside_down=false,wood_variant=jungle": { "model": "adorablehamsterpets:block/hamster_bed_jungle" },
    "occupied=false,orientation=north,upside_down=true,wood_variant=jungle": { "model": "adorablehamsterpets:block/hamster_bed_jungle" },
    "occupied=false,orientation=south,upside_down=true,wood_variant=jungle": { "model": "adorablehamsterpets:block/hamster_bed_jungle" },
    "occupied=false,orientation=west,upside_down=true,wood_variant=jungle": { "model": "adorablehamsterpets:block/hamster_bed_jungle" },
    "occupied=false,orientation=east,upside_down=true,wood_variant=jungle": { "model": "adorablehamsterpets:block/hamster_bed_jungle" },
    "occupied=true,orientation=north,upside_down=true,wood_variant=jungle": { "model": "adorablehamsterpets:block/hamster_bed_jungle" },
    "occupied=true,orientation=south,upside_down=true,wood_variant=jungle": { "model": "adorablehamsterpets:block/hamster_bed_jungle" },
    "occupied=true,orientation=west,upside_down=true,wood_variant=jungle": { "model": "adorablehamsterpets:block/hamster_bed_jungle" },
    "occupied=true,orientation=east,upside_down=true,wood_variant=jungle": { "model": "adorablehamsterpets:block/hamster_bed_jungle" },

    "occupied=false,orientation=north,upside_down=false,wood_variant=acacia": { "model": "adorablehamsterpets:block/hamster_bed_acacia" },
    "occupied=false,orientation=south,upside_down=false,wood_variant=acacia": { "model": "adorablehamsterpets:block/hamster_bed_acacia" },
    "occupied=false,orientation=west,upside_down=false,wood_variant=acacia": { "model": "adorablehamsterpets:block/hamster_bed_acacia" },
    "occupied=false,orientation=east,upside_down=false,wood_variant=acacia": { "model": "adorablehamsterpets:block/hamster_bed_acacia" },
    "occupied=true,orientation=north,upside_down=false,wood_variant=acacia": { "model": "adorablehamsterpets:block/hamster_bed_acacia" },
    "occupied=true,orientation=south,upside_down=false,wood_variant=acacia": { "model": "adorablehamsterpets:block/hamster_bed_acacia" },
    "occupied=true,orientation=west,upside_down=false,wood_variant=acacia": { "model": "adorablehamsterpets:block/hamster_bed_acacia" },
    "occupied=true,orientation=east,upside_down=false,wood_variant=acacia": { "model": "adorablehamsterpets:block/hamster_bed_acacia" },
    "occupied=false,orientation=north,upside_down=true,wood_variant=acacia": { "model": "adorablehamsterpets:block/hamster_bed_acacia" },
    "occupied=false,orientation=south,upside_down=true,wood_variant=acacia": { "model": "adorablehamsterpets:block/hamster_bed_acacia" },
    "occupied=false,orientation=west,upside_down=true,wood_variant=acacia": { "model": "adorablehamsterpets:block/hamster_bed_acacia" },
    "occupied=false,orientation=east,upside_down=true,wood_variant=acacia": { "model": "adorablehamsterpets:block/hamster_bed_acacia" },
    "occupied=true,orientation=north,upside_down=true,wood_variant=acacia": { "model": "adorablehamsterpets:block/hamster_bed_acacia" },
    "occupied=true,orientation=south,upside_down=true,wood_variant=acacia": { "model": "adorablehamsterpets:block/hamster_bed_acacia" },
    "occupied=true,orientation=west,upside_down=true,wood_variant=acacia": { "model": "adorablehamsterpets:block/hamster_bed_acacia" },
    "occupied=true,orientation=east,upside_down=true,wood_variant=acacia": { "model": "adorablehamsterpets:block/hamster_bed_acacia" },

    "occupied=false,orientation=north,upside_down=false,wood_variant=dark_oak": { "model": "adorablehamsterpets:block/hamster_bed_dark_oak" },
    "occupied=false,orientation=south,upside_down=false,wood_variant=dark_oak": { "model": "adorablehamsterpets:block/hamster_bed_dark_oak" },
    "occupied=false,orientation=west,upside_down=false,wood_variant=dark_oak": { "model": "adorablehamsterpets:block/hamster_bed_dark_oak" },
    "occupied=false,orientation=east,upside_down=false,wood_variant=dark_oak": { "model": "adorablehamsterpets:block/hamster_bed_dark_oak" },
    "occupied=true,orientation=north,upside_down=false,wood_variant=dark_oak": { "model": "adorablehamsterpets:block/hamster_bed_dark_oak" },
    "occupied=true,orientation=south,upside_down=false,wood_variant=dark_oak": { "model": "adorablehamsterpets:block/hamster_bed_dark_oak" },
    "occupied=true,orientation=west,upside_down=false,wood_variant=dark_oak": { "model": "adorablehamsterpets:block/hamster_bed_dark_oak" },
    "occupied=true,orientation=east,upside_down=false,wood_variant=dark_oak": { "model": "adorablehamsterpets:block/hamster_bed_dark_oak" },
    "occupied=false,orientation=north,upside_down=true,wood_variant=dark_oak": { "model": "adorablehamsterpets:block/hamster_bed_dark_oak" },
    "occupied=false,orientation=south,upside_down=true,wood_variant=dark_oak": { "model": "adorablehamsterpets:block/hamster_bed_dark_oak" },
    "occupied=false,orientation=west,upside_down=true,wood_variant=dark_oak": { "model": "adorablehamsterpets:block/hamster_bed_dark_oak" },
    "occupied=false,orientation=east,upside_down=true,wood_variant=dark_oak": { "model": "adorablehamsterpets:block/hamster_bed_dark_oak" },
    "occupied=true,orientation=north,upside_down=true,wood_variant=dark_oak": { "model": "adorablehamsterpets:block/hamster_bed_dark_oak" },
    "occupied=true,orientation=south,upside_down=true,wood_variant=dark_oak": { "model": "adorablehamsterpets:block/hamster_bed_dark_oak" },
    "occupied=true,orientation=west,upside_down=true,wood_variant=dark_oak": { "model": "adorablehamsterpets:block/hamster_bed_dark_oak" },
    "occupied=true,orientation=east,upside_down=true,wood_variant=dark_oak": { "model": "adorablehamsterpets:block/hamster_bed_dark_oak" },

    "occupied=false,orientation=north,upside_down=false,wood_variant=mangrove": { "model": "adorablehamsterpets:block/hamster_bed_mangrove" },
    "occupied=false,orientation=south,upside_down=false,wood_variant=mangrove": { "model": "adorablehamsterpets:block/hamster_bed_mangrove" },
    "occupied=false,orientation=west,upside_down=false,wood_variant=mangrove": { "model": "adorablehamsterpets:block/hamster_bed_mangrove" },
    "occupied=false,orientation=east,upside_down=false,wood_variant=mangrove": { "model": "adorablehamsterpets:block/hamster_bed_mangrove" },
    "occupied=true,orientation=north,upside_down=false,wood_variant=mangrove": { "model": "adorablehamsterpets:block/hamster_bed_mangrove" },
    "occupied=true,orientation=south,upside_down=false,wood_variant=mangrove": { "model": "adorablehamsterpets:block/hamster_bed_mangrove" },
    "occupied=true,orientation=west,upside_down=false,wood_variant=mangrove": { "model": "adorablehamsterpets:block/hamster_bed_mangrove" },
    "occupied=true,orientation=east,upside_down=false,wood_variant=mangrove": { "model": "adorablehamsterpets:block/hamster_bed_mangrove" },
    "occupied=false,orientation=north,upside_down=true,wood_variant=mangrove": { "model": "adorablehamsterpets:block/hamster_bed_mangrove" },
    "occupied=false,orientation=south,upside_down=true,wood_variant=mangrove": { "model": "adorablehamsterpets:block/hamster_bed_mangrove" },
    "occupied=false,orientation=west,upside_down=true,wood_variant=mangrove": { "model": "adorablehamsterpets:block/hamster_bed_mangrove" },
    "occupied=false,orientation=east,upside_down=true,wood_variant=mangrove": { "model": "adorablehamsterpets:block/hamster_bed_mangrove" },
    "occupied=true,orientation=north,upside_down=true,wood_variant=mangrove": { "model": "adorablehamsterpets:block/hamster_bed_mangrove" },
    "occupied=true,orientation=south,upside_down=true,wood_variant=mangrove": { "model": "adorablehamsterpets:block/hamster_bed_mangrove" },
    "occupied=true,orientation=west,upside_down=true,wood_variant=mangrove": { "model": "adorablehamsterpets:block/hamster_bed_mangrove" },
    "occupied=true,orientation=east,upside_down=true,wood_variant=mangrove": { "model": "adorablehamsterpets:block/hamster_bed_mangrove" },

    "occupied=false,orientation=north,upside_down=false,wood_variant=cherry": { "model": "adorablehamsterpets:block/hamster_bed_cherry" },
    "occupied=false,orientation=south,upside_down=false,wood_variant=cherry": { "model": "adorablehamsterpets:block/hamster_bed_cherry" },
    "occupied=false,orientation=west,upside_down=false,wood_variant=cherry": { "model": "adorablehamsterpets:block/hamster_bed_cherry" },
    "occupied=false,orientation=east,upside_down=false,wood_variant=cherry": { "model": "adorablehamsterpets:block/hamster_bed_cherry" },
    "occupied=true,orientation=north,upside_down=false,wood_variant=cherry": { "model": "adorablehamsterpets:block/hamster_bed_cherry" },
    "occupied=true,orientation=south,upside_down=false,wood_variant=cherry": { "model": "adorablehamsterpets:block/hamster_bed_cherry" },
    "occupied=true,orientation=west,upside_down=false,wood_variant=cherry": { "model": "adorablehamsterpets:block/hamster_bed_cherry" },
    "occupied=true,orientation=east,upside_down=false,wood_variant=cherry": { "model": "adorablehamsterpets:block/hamster_bed_cherry" },
    "occupied=false,orientation=north,upside_down=true,wood_variant=cherry": { "model": "adorablehamsterpets:block/hamster_bed_cherry" },
    "occupied=false,orientation=south,upside_down=true,wood_variant=cherry": { "model": "adorablehamsterpets:block/hamster_bed_cherry" },
    "occupied=false,orientation=west,upside_down=true,wood_variant=cherry": { "model": "adorablehamsterpets:block/hamster_bed_cherry" },
    "occupied=false,orientation=east,upside_down=true,wood_variant=cherry": { "model": "adorablehamsterpets:block/hamster_bed_cherry" },
    "occupied=true,orientation=north,upside_down=true,wood_variant=cherry": { "model": "adorablehamsterpets:block/hamster_bed_cherry" },
    "occupied=true,orientation=south,upside_down=true,wood_variant=cherry": { "model": "adorablehamsterpets:block/hamster_bed_cherry" },
    "occupied=true,orientation=west,upside_down=true,wood_variant=cherry": { "model": "adorablehamsterpets:block/hamster_bed_cherry" },
    "occupied=true,orientation=east,upside_down=true,wood_variant=cherry": { "model": "adorablehamsterpets:block/hamster_bed_cherry" },

    "occupied=false,orientation=north,upside_down=false,wood_variant=bamboo": { "model": "adorablehamsterpets:block/hamster_bed_bamboo" },
    "occupied=false,orientation=south,upside_down=false,wood_variant=bamboo": { "model": "adorablehamsterpets:block/hamster_bed_bamboo" },
    "occupied=false,orientation=west,upside_down=false,wood_variant=bamboo": { "model": "adorablehamsterpets:block/hamster_bed_bamboo" },
    "occupied=false,orientation=east,upside_down=false,wood_variant=bamboo": { "model": "adorablehamsterpets:block/hamster_bed_bamboo" },
    "occupied=true,orientation=north,upside_down=false,wood_variant=bamboo": { "model": "adorablehamsterpets:block/hamster_bed_bamboo" },
    "occupied=true,orientation=south,upside_down=false,wood_variant=bamboo": { "model": "adorablehamsterpets:block/hamster_bed_bamboo" },
    "occupied=true,orientation=west,upside_down=false,wood_variant=bamboo": { "model": "adorablehamsterpets:block/hamster_bed_bamboo" },
    "occupied=true,orientation=east,upside_down=false,wood_variant=bamboo": { "model": "adorablehamsterpets:block/hamster_bed_bamboo" },
    "occupied=false,orientation=north,upside_down=true,wood_variant=bamboo": { "model": "adorablehamsterpets:block/hamster_bed_bamboo" },
    "occupied=false,orientation=south,upside_down=true,wood_variant=bamboo": { "model": "adorablehamsterpets:block/hamster_bed_bamboo" },
    "occupied=false,orientation=west,upside_down=true,wood_variant=bamboo": { "model": "adorablehamsterpets:block/hamster_bed_bamboo" },
    "occupied=false,orientation=east,upside_down=true,wood_variant=bamboo": { "model": "adorablehamsterpets:block/hamster_bed_bamboo" },
    "occupied=true,orientation=north,upside_down=true,wood_variant=bamboo": { "model": "adorablehamsterpets:block/hamster_bed_bamboo" },
    "occupied=true,orientation=south,upside_down=true,wood_variant=bamboo": { "model": "adorablehamsterpets:block/hamster_bed_bamboo" },
    "occupied=true,orientation=west,upside_down=true,wood_variant=bamboo": { "model": "adorablehamsterpets:block/hamster_bed_bamboo" },
    "occupied=true,orientation=east,upside_down=true,wood_variant=bamboo": { "model": "adorablehamsterpets:block/hamster_bed_bamboo" },

    "occupied=false,orientation=north,upside_down=false,wood_variant=pale_oak": { "model": "adorablehamsterpets:block/hamster_bed_pale_oak" },
    "occupied=false,orientation=south,upside_down=false,wood_variant=pale_oak": { "model": "adorablehamsterpets:block/hamster_bed_pale_oak" },
    "occupied=false,orientation=west,upside_down=false,wood_variant=pale_oak": { "model": "adorablehamsterpets:block/hamster_bed_pale_oak" },
    "occupied=false,orientation=east,upside_down=false,wood_variant=pale_oak": { "model": "adorablehamsterpets:block/hamster_bed_pale_oak" },
    "occupied=true,orientation=north,upside_down=false,wood_variant=pale_oak": { "model": "adorablehamsterpets:block/hamster_bed_pale_oak" },
    "occupied=true,orientation=south,upside_down=false,wood_variant=pale_oak": { "model": "adorablehamsterpets:block/hamster_bed_pale_oak" },
    "occupied=true,orientation=west,upside_down=false,wood_variant=pale_oak": { "model": "adorablehamsterpets:block/hamster_bed_pale_oak" },
    "occupied=true,orientation=east,upside_down=false,wood_variant=pale_oak": { "model": "adorablehamsterpets:block/hamster_bed_pale_oak" },
    "occupied=false,orientation=north,upside_down=true,wood_variant=pale_oak": { "model": "adorablehamsterpets:block/hamster_bed_pale_oak" },
    "occupied=false,orientation=south,upside_down=true,wood_variant=pale_oak": { "model": "adorablehamsterpets:block/hamster_bed_pale_oak" },
    "occupied=false,orientation=west,upside_down=true,wood_variant=pale_oak": { "model": "adorablehamsterpets:block/hamster_bed_pale_oak" },
    "occupied=false,orientation=east,upside_down=true,wood_variant=pale_oak": { "model": "adorablehamsterpets:block/hamster_bed_pale_oak" },
    "occupied=true,orientation=north,upside_down=true,wood_variant=pale_oak": { "model": "adorablehamsterpets:block/hamster_bed_pale_oak" },
    "occupied=true,orientation=south,upside_down=true,wood_variant=pale_oak": { "model": "adorablehamsterpets:block/hamster_bed_pale_oak" },
    "occupied=true,orientation=west,upside_down=true,wood_variant=pale_oak": { "model": "adorablehamsterpets:block/hamster_bed_pale_oak" },
    "occupied=true,orientation=east,upside_down=true,wood_variant=pale_oak": { "model": "adorablehamsterpets:block/hamster_bed_pale_oak" }
  }
}
```

`sunflower_block.json`
```json
{
  "variants": {
    "half=lower": {
      "model": "adorablehamsterpets:block/sunflower_block_bottom"
    },
    "half=upper,has_seeds=false": {
      "model": "adorablehamsterpets:block/sunflower_block_top_no_seeds"
    },
    "half=upper,has_seeds=true": {
      "model": "adorablehamsterpets:block/sunflower_block_top_with_seeds"
    }
  }
}
```

### 📂 `common/src/main/resources/assets/adorablehamsterpets/geo/`
`hamster.geo.json` (Content omitted)
`hamster_bed.geo.json` (Content omitted)

### 📂 `common/src/main/resources/assets/adorablehamsterpets/animations/`
`anim_hamster.animation.json` (Content omitted)
`anim_hamster_bed.animation.json` (Content omitted)

### 📂 `common/src/main/resources/assets/adorablehamsterpets/models/block/`
`hamster_bed.json`
```json
{
  "parent": "minecraft:block/block",
  "textures": {
    "particle": "adorablehamsterpets:block/hamster_bed_oak"
  }
}
```

`sunflower_block_bottom.json`
```json
{
  "parent": "minecraft:block/cross",
  "textures": {
    "cross": "adorablehamsterpets:block/sunflower_bottom"
  },
  "render_type": "cutout"
}
```

`sunflower_block_top_no_seeds.json`
```json
{
  "parent": "minecraft:block/sunflower_top",
  "textures": {
    "front": "adorablehamsterpets:block/sunflower_front_no_seeds",
    "back": "adorablehamsterpets:block/sunflower_back",
    "top": "adorablehamsterpets:block/sunflower_top"
  }
}
```

`sunflower_block_top_with_seeds.json`
```json
{
  "parent": "minecraft:block/sunflower_top",
  "textures": {
    "front": "adorablehamsterpets:block/sunflower_front_with_seeds",
    "back": "adorablehamsterpets:block/sunflower_back",
    "top": "adorablehamsterpets:block/sunflower_top"
  }
}
```

### 📂 `common/src/main/resources/assets/adorablehamsterpets/models/item/`
`hamster_bed.json`
```json
{
  "parent": "builtin/entity",
  "display": {
    "thirdperson_righthand": {
      "rotation": [75, 45, 0],
      "translation": [0, 1, 0],
      "scale": [0.5, 0.5, 0.5]
    },
    "thirdperson_lefthand": {
      "rotation": [75, 45, 0],
      "translation": [0, 1, 0],
      "scale": [0.5, 0.5, 0.5]
    },
    "firstperson_righthand": {
      "rotation": [0, 45, 0],
      "translation": [0, 0, 0],
      "scale": [0.5, 0.5, 0.5]
    },
    "firstperson_lefthand": {
      "rotation": [0, 225, 0],
      "translation": [0, 0, 0],
      "scale": [0.5, 0.5, 0.5]
    },
    "ground": {
      "translation": [0, 0, 0],
      "scale": [0.33, 0.33, 0.33]
    },
    "gui": {
      "rotation": [ 30, 45, 0 ],
      "translation": [ 0, -2, 0 ],
      "scale": [ 0.7, 0.7, 0.7 ]
    },
    "fixed": {
      "scale": [0.5, 0.5, 0.5]
    }
  }
}
```

`hamster_guide_book.json`
```json
{
  "parent": "item/generated",
  "textures": {
    "layer0": "adorablehamsterpets:item/hamster_guide_book_texture"
  }
}
```

`sunflower_block.json`
```json
{
  "parent": "minecraft:item/generated",
  "textures": {
    "layer0": "adorablehamsterpets:block/sunflower_front_with_seeds"
  }
}
```

`upside_down_hamster_bed_icon.json`
```json
{
  "parent": "builtin/entity",
  "display": {
    "thirdperson_righthand": {
      "rotation": [75, 45, 0],
      "translation": [0, 1, 0],
      "scale": [0.5, 0.5, 0.5]
    },
    "thirdperson_lefthand": {
      "rotation": [75, 45, 0],
      "translation": [0, 1, 0],
      "scale": [0.5, 0.5, 0.5]
    },
    "firstperson_righthand": {
      "rotation": [0, 45, 0],
      "translation": [0, 0, 0],
      "scale": [0.5, 0.5, 0.5]
    },
    "firstperson_lefthand": {
      "rotation": [0, 225, 0],
      "translation": [0, 0, 0],
      "scale": [0.5, 0.5, 0.5]
    },
    "ground": {
      "translation": [0, 0, 0],
      "scale": [0.33, 0.33, 0.33]
    },
    "gui": {
      "rotation": [-40, 45, 180 ],
      "translation": [ 0, 2, 0 ],
      "scale": [ 0.7, 0.7, 0.7 ]
    },
    "fixed": {
      "scale": [ 0.5, 0.5, 0.5 ]
    }
  }
}
```

### 📂 `common/src/main/resources/assets/adorablehamsterpets/particles/`
`hamster_bedding_acacia.json`
```json
{
  "textures": [
    "adorablehamsterpets:hamster_bedding_1_acacia",
    "adorablehamsterpets:hamster_bedding_2_acacia",
    "adorablehamsterpets:hamster_bedding_3_acacia",
    "adorablehamsterpets:hamster_bedding_4_acacia",
    "adorablehamsterpets:hamster_bedding_5_acacia",
    "adorablehamsterpets:hamster_bedding_6_acacia",
    "adorablehamsterpets:hamster_bedding_7_acacia",
    "adorablehamsterpets:hamster_bedding_8_acacia",
    "adorablehamsterpets:hamster_bedding_9_acacia",
    "adorablehamsterpets:hamster_bedding_10_acacia",
    "adorablehamsterpets:hamster_bedding_11_acacia",
    "adorablehamsterpets:hamster_bedding_12_acacia",
    "adorablehamsterpets:hamster_bedding_13_acacia",
    "adorablehamsterpets:hamster_bedding_14_acacia",
    "adorablehamsterpets:hamster_bedding_15_acacia",
    "adorablehamsterpets:hamster_bedding_16_acacia"
  ]
}
```

`hamster_bedding_bamboo.json`
```json
{
  "textures": [
    "adorablehamsterpets:hamster_bedding_1_bamboo",
    "adorablehamsterpets:hamster_bedding_2_bamboo",
    "adorablehamsterpets:hamster_bedding_3_bamboo",
    "adorablehamsterpets:hamster_bedding_4_bamboo",
    "adorablehamsterpets:hamster_bedding_5_bamboo",
    "adorablehamsterpets:hamster_bedding_6_bamboo",
    "adorablehamsterpets:hamster_bedding_7_bamboo",
    "adorablehamsterpets:hamster_bedding_8_bamboo",
    "adorablehamsterpets:hamster_bedding_9_bamboo",
    "adorablehamsterpets:hamster_bedding_10_bamboo",
    "adorablehamsterpets:hamster_bedding_11_bamboo",
    "adorablehamsterpets:hamster_bedding_12_bamboo",
    "adorablehamsterpets:hamster_bedding_13_bamboo",
    "adorablehamsterpets:hamster_bedding_14_bamboo",
    "adorablehamsterpets:hamster_bedding_15_bamboo",
    "adorablehamsterpets:hamster_bedding_16_bamboo"
  ]
}
```

`hamster_bedding_birch.json`
```json
{
  "textures": [
    "adorablehamsterpets:hamster_bedding_1_oak_birch",
    "adorablehamsterpets:hamster_bedding_2_oak_birch",
    "adorablehamsterpets:hamster_bedding_3_oak_birch",
    "adorablehamsterpets:hamster_bedding_4_oak_birch",
    "adorablehamsterpets:hamster_bedding_5_oak_birch",
    "adorablehamsterpets:hamster_bedding_6_oak_birch",
    "adorablehamsterpets:hamster_bedding_7_oak_birch",
    "adorablehamsterpets:hamster_bedding_8_oak_birch",
    "adorablehamsterpets:hamster_bedding_9_oak_birch",
    "adorablehamsterpets:hamster_bedding_10_oak_birch",
    "adorablehamsterpets:hamster_bedding_11_oak_birch",
    "adorablehamsterpets:hamster_bedding_12_oak_birch",
    "adorablehamsterpets:hamster_bedding_13_oak_birch",
    "adorablehamsterpets:hamster_bedding_14_oak_birch",
    "adorablehamsterpets:hamster_bedding_15_oak_birch",
    "adorablehamsterpets:hamster_bedding_16_oak_birch"
  ]
}
```

`hamster_bedding_cherry.json`
```json
{
  "textures": [
    "adorablehamsterpets:hamster_bedding_1_cherry",
    "adorablehamsterpets:hamster_bedding_2_cherry",
    "adorablehamsterpets:hamster_bedding_3_cherry",
    "adorablehamsterpets:hamster_bedding_4_cherry",
    "adorablehamsterpets:hamster_bedding_5_cherry",
    "adorablehamsterpets:hamster_bedding_6_cherry",
    "adorablehamsterpets:hamster_bedding_7_cherry",
    "adorablehamsterpets:hamster_bedding_8_cherry",
    "adorablehamsterpets:hamster_bedding_9_cherry",
    "adorablehamsterpets:hamster_bedding_10_cherry",
    "adorablehamsterpets:hamster_bedding_11_cherry",
    "adorablehamsterpets:hamster_bedding_12_cherry",
    "adorablehamsterpets:hamster_bedding_13_cherry",
    "adorablehamsterpets:hamster_bedding_14_cherry",
    "adorablehamsterpets:hamster_bedding_15_cherry",
    "adorablehamsterpets:hamster_bedding_16_cherry"
  ]
}
```

`hamster_bedding_dark_oak.json`
```json
{
  "textures": [
    "adorablehamsterpets:hamster_bedding_1_dark_oak",
    "adorablehamsterpets:hamster_bedding_2_dark_oak",
    "adorablehamsterpets:hamster_bedding_3_dark_oak",
    "adorablehamsterpets:hamster_bedding_4_dark_oak",
    "adorablehamsterpets:hamster_bedding_5_dark_oak",
    "adorablehamsterpets:hamster_bedding_6_dark_oak",
    "adorablehamsterpets:hamster_bedding_7_dark_oak",
    "adorablehamsterpets:hamster_bedding_8_dark_oak",
    "adorablehamsterpets:hamster_bedding_9_dark_oak",
    "adorablehamsterpets:hamster_bedding_10_dark_oak",
    "adorablehamsterpets:hamster_bedding_11_dark_oak",
    "adorablehamsterpets:hamster_bedding_12_dark_oak",
    "adorablehamsterpets:hamster_bedding_13_dark_oak",
    "adorablehamsterpets:hamster_bedding_14_dark_oak",
    "adorablehamsterpets:hamster_bedding_15_dark_oak",
    "adorablehamsterpets:hamster_bedding_16_dark_oak"
  ]
}
```

`hamster_bedding_jungle.json`
```json
{
  "textures": [
    "adorablehamsterpets:hamster_bedding_1_jungle",
    "adorablehamsterpets:hamster_bedding_2_jungle",
    "adorablehamsterpets:hamster_bedding_3_jungle",
    "adorablehamsterpets:hamster_bedding_4_jungle",
    "adorablehamsterpets:hamster_bedding_5_jungle",
    "adorablehamsterpets:hamster_bedding_6_jungle",
    "adorablehamsterpets:hamster_bedding_7_jungle",
    "adorablehamsterpets:hamster_bedding_8_jungle",
    "adorablehamsterpets:hamster_bedding_9_jungle",
    "adorablehamsterpets:hamster_bedding_10_jungle",
    "adorablehamsterpets:hamster_bedding_11_jungle",
    "adorablehamsterpets:hamster_bedding_12_jungle",
    "adorablehamsterpets:hamster_bedding_13_jungle",
    "adorablehamsterpets:hamster_bedding_14_jungle",
    "adorablehamsterpets:hamster_bedding_15_jungle",
    "adorablehamsterpets:hamster_bedding_16_jungle"
  ]
}
```

`hamster_bedding_mangrove.json`
```json
{
  "textures": [
    "adorablehamsterpets:hamster_bedding_1_mangrove",
    "adorablehamsterpets:hamster_bedding_2_mangrove",
    "adorablehamsterpets:hamster_bedding_3_mangrove",
    "adorablehamsterpets:hamster_bedding_4_mangrove",
    "adorablehamsterpets:hamster_bedding_5_mangrove",
    "adorablehamsterpets:hamster_bedding_6_mangrove",
    "adorablehamsterpets:hamster_bedding_7_mangrove",
    "adorablehamsterpets:hamster_bedding_8_mangrove",
    "adorablehamsterpets:hamster_bedding_9_mangrove",
    "adorablehamsterpets:hamster_bedding_10_mangrove",
    "adorablehamsterpets:hamster_bedding_11_mangrove",
    "adorablehamsterpets:hamster_bedding_12_mangrove",
    "adorablehamsterpets:hamster_bedding_13_mangrove",
    "adorablehamsterpets:hamster_bedding_14_mangrove",
    "adorablehamsterpets:hamster_bedding_15_mangrove",
    "adorablehamsterpets:hamster_bedding_16_mangrove"
  ]
}
```

`hamster_bedding_oak.json`
```json
{
  "textures": [
    "adorablehamsterpets:hamster_bedding_1_oak_birch",
    "adorablehamsterpets:hamster_bedding_2_oak_birch",
    "adorablehamsterpets:hamster_bedding_3_oak_birch",
    "adorablehamsterpets:hamster_bedding_4_oak_birch",
    "adorablehamsterpets:hamster_bedding_5_oak_birch",
    "adorablehamsterpets:hamster_bedding_6_oak_birch",
    "adorablehamsterpets:hamster_bedding_7_oak_birch",
    "adorablehamsterpets:hamster_bedding_8_oak_birch",
    "adorablehamsterpets:hamster_bedding_9_oak_birch",
    "adorablehamsterpets:hamster_bedding_10_oak_birch",
    "adorablehamsterpets:hamster_bedding_11_oak_birch",
    "adorablehamsterpets:hamster_bedding_12_oak_birch",
    "adorablehamsterpets:hamster_bedding_13_oak_birch",
    "adorablehamsterpets:hamster_bedding_14_oak_birch",
    "adorablehamsterpets:hamster_bedding_15_oak_birch",
    "adorablehamsterpets:hamster_bedding_16_oak_birch"
  ]
}
```

`hamster_bedding_pale_oak.json`
```json
{
  "textures": [
    "adorablehamsterpets:hamster_bedding_1_oak_birch",
    "adorablehamsterpets:hamster_bedding_2_oak_birch",
    "adorablehamsterpets:hamster_bedding_3_oak_birch",
    "adorablehamsterpets:hamster_bedding_4_oak_birch",
    "adorablehamsterpets:hamster_bedding_5_oak_birch",
    "adorablehamsterpets:hamster_bedding_6_oak_birch",
    "adorablehamsterpets:hamster_bedding_7_oak_birch",
    "adorablehamsterpets:hamster_bedding_8_oak_birch",
    "adorablehamsterpets:hamster_bedding_9_oak_birch",
    "adorablehamsterpets:hamster_bedding_10_oak_birch",
    "adorablehamsterpets:hamster_bedding_11_oak_birch",
    "adorablehamsterpets:hamster_bedding_12_oak_birch",
    "adorablehamsterpets:hamster_bedding_13_oak_birch",
    "adorablehamsterpets:hamster_bedding_14_oak_birch",
    "adorablehamsterpets:hamster_bedding_15_oak_birch",
    "adorablehamsterpets:hamster_bedding_16_oak_birch"
  ]
}
```

`hamster_bedding_spruce.json`
```json
{
  "textures": [
    "adorablehamsterpets:hamster_bedding_1_spruce",
    "adorablehamsterpets:hamster_bedding_2_spruce",
    "adorablehamsterpets:hamster_bedding_3_spruce",
    "adorablehamsterpets:hamster_bedding_4_spruce",
    "adorablehamsterpets:hamster_bedding_5_spruce",
    "adorablehamsterpets:hamster_bedding_6_spruce",
    "adorablehamsterpets:hamster_bedding_7_spruce",
    "adorablehamsterpets:hamster_bedding_8_spruce",
    "adorablehamsterpets:hamster_bedding_9_spruce",
    "adorablehamsterpets:hamster_bedding_10_spruce",
    "adorablehamsterpets:hamster_bedding_11_spruce",
    "adorablehamsterpets:hamster_bedding_12_spruce",
    "adorablehamsterpets:hamster_bedding_13_spruce",
    "adorablehamsterpets:hamster_bedding_14_spruce",
    "adorablehamsterpets:hamster_bedding_15_spruce",
    "adorablehamsterpets:hamster_bedding_16_spruce"
  ]
}
```

### 📂 `common/src/main/resources/assets/adorablehamsterpets/sounds/`
`alarm_orchestra_hit.ogg`
`cartoon_punches.ogg`
`cheese_eat1.ogg`
`cheese_eat2.ogg`
`cheese_eat3.ogg`
`cheese_use.ogg`
`diamond_sparkle1.ogg`
`diamond_sparkle2.ogg`
`diamond_sparkle3.ogg`
`gentle_breeze.ogg`
`hamster_affection1.ogg`
`hamster_affection2.ogg`
`hamster_affection3.ogg`
`hamster_airborne_celebration.ogg`
`hamster_attack1.ogg`
`hamster_attack2.ogg`
`hamster_attack3.ogg`
`hamster_attack4.ogg`
`hamster_bed_leaves_rustle1.ogg`
`hamster_bed_leaves_rustle2.ogg`
`hamster_bed_leaves_rustle3.ogg`
`hamster_beg1.ogg`
`hamster_beg2.ogg`
`hamster_beg3.ogg`
`hamster_beg4.ogg`
`hamster_beg5.ogg`
`hamster_bounce.ogg`
`hamster_celebrate1.ogg`
`hamster_celebrate2.ogg`
`hamster_celebrate3.ogg`
`hamster_celebrate4.ogg`
`hamster_creeper_detect1.ogg`
`hamster_creeper_detect2.ogg`
`hamster_creeper_detect3.ogg`
`hamster_creeper_detect4.ogg`
`hamster_death1.ogg`
`hamster_death2.ogg`
`hamster_death3.ogg`
`hamster_death4.ogg`
`hamster_diamond_pounce.ogg`
`hamster_dismount.ogg`
`hamster_hurt1.ogg`
`hamster_hurt10.ogg`
`hamster_hurt2.ogg`
`hamster_hurt3.ogg`
`hamster_hurt4.ogg`
`hamster_hurt5.ogg`
`hamster_hurt6.ogg`
`hamster_hurt7.ogg`
`hamster_hurt8.ogg`
`hamster_hurt9.ogg`
`hamster_idle1.ogg`
`hamster_idle10.ogg`
`hamster_idle11.ogg`
`hamster_idle2.ogg`
`hamster_idle3.ogg`
`hamster_idle4.ogg`
`hamster_idle5.ogg`
`hamster_idle6.ogg`
`hamster_idle7.ogg`
`hamster_idle8.ogg`
`hamster_idle9.ogg`
`hamster_mount1.ogg`
`hamster_mount2.ogg`
`hamster_mount3.ogg`
`hamster_scratch.ogg`
`hamster_shocked.ogg`
`hamster_shoulder_impact1.ogg`
`hamster_shoulder_impact2.ogg`
`hamster_shoulder_impact3.ogg`
`hamster_sleep1.ogg`
`hamster_sleep2.ogg`
`hamster_sleep3.ogg`
`hamster_sleep4.ogg`
`hamster_sleep5.ogg`
`hamster_sleep6.ogg`
`hamster_sleep7.ogg`
`hamster_sleep8.ogg`
`hamster_sleep9.ogg`
`hamster_sniff1.ogg`
`hamster_sniff2.ogg`
`hamster_sniff3.ogg`
`hamster_sniff4.ogg`
`hamster_swish.ogg`
`hamster_throw.ogg`
`hamster_throw_reversed.ogg`
`hamster_thump.ogg`
`hamster_wake_up1.ogg`
`hamster_wake_up2.ogg`
`hamster_wake_up3.ogg`
`hamster_wow.ogg`

### 📂 `common/src/main/resources/assets/adorablehamsterpets/textures/block/`
`cucumber_crop_stage0.png`
`cucumber_crop_stage1.png`
`cucumber_crop_stage2.png`
`cucumber_crop_stage3.png`
`green_beans_crop_stage0.png`
`green_beans_crop_stage1.png`
`green_beans_crop_stage2.png`
`green_beans_crop_stage3.png`
`hamster_bed_acacia.png`
`hamster_bed_bamboo.png`
`hamster_bed_birch.png`
`hamster_bed_cherry.png`
`hamster_bed_dark_oak.png`
`hamster_bed_jungle.png`
`hamster_bed_mangrove.png`
`hamster_bed_oak.png`
`hamster_bed_pale_oak.png`
`hamster_bed_spruce.png`
`sunflower_back.png`
`sunflower_bottom.png`
`sunflower_front_no_seeds.png`
`sunflower_front_with_seeds.png`
`sunflower_top.png`
`wild_cucumber_bush_seeded.png`
`wild_cucumber_bush_seedless.png`
`wild_green_bean_bush_seeded.png`
`wild_green_bean_bush_seedless.png`

### 📂 `common/src/main/resources/assets/adorablehamsterpets/textures/entity/hamster/`
`black.png`
`blue.png`
`chocolate.png`
`cream.png`
`dark_gray.png`
`lavender.png`
`light_gray.png`
`orange.png`
`overlay1.png`
`overlay2.png`
`overlay3.png`
`overlay4.png`
`overlay5.png`
`overlay6.png`
`overlay7.png`
`overlay8.png`
`overlay_pink_petal1.png`
`overlay_pink_petal2.png`
`overlay_pink_petal3.png`
`white.png`

### 📂 `common/src/main/resources/assets/adorablehamsterpets/textures/gui/`
`announcement_ui.png`
`announcement_ui_scroll_bar.png`
`blank_page_filler.png`
`hamster_guide_book_ui.png`
`hamster_inventory_gui.png`

### 📂 `common/src/main/resources/assets/adorablehamsterpets/textures/gui/advancements/`
`background.png`

### 📂 `common/src/main/resources/assets/adorablehamsterpets/textures/item/`
`announcement_bell_icon.png`
`cheese.png`
`cucumber.png`
`cucumber_seeds.png`
`green_bean_seeds.png`
`green_beans.png`
`hamster_bedding.png`
`hamster_food_mix.png`
`hamster_guide_book_texture.png`
`hamster_spawn_egg.png`
`sliced_cucumber.png`
`steamed_green_beans.png`
`sunflower_block.png`
`sunflower_seeds.png`
`wild_cucumber_bush.png`
`wild_green_bean_bush.png`

### 📂 `common/src/main/resources/assets/adorablehamsterpets/textures/particle/`
`hamster_bedding_10_acacia.png`
`hamster_bedding_10_bamboo.png`
`hamster_bedding_10_cherry.png`
`hamster_bedding_10_dark_oak.png`
`hamster_bedding_10_jungle.png`
`hamster_bedding_10_mangrove.png`
`hamster_bedding_10_oak_birch.png`
`hamster_bedding_10_spruce.png`
`hamster_bedding_11_acacia.png`
`hamster_bedding_11_bamboo.png`
`hamster_bedding_11_cherry.png`
`hamster_bedding_11_dark_oak.png`
`hamster_bedding_11_jungle.png`
`hamster_bedding_11_mangrove.png`
`hamster_bedding_11_oak_birch.png`
`hamster_bedding_11_spruce.png`
`hamster_bedding_12_acacia.png`
`hamster_bedding_12_bamboo.png`
`hamster_bedding_12_cherry.png`
`hamster_bedding_12_dark_oak.png`
`hamster_bedding_12_jungle.png`
`hamster_bedding_12_mangrove.png`
`hamster_bedding_12_oak_birch.png`
`hamster_bedding_12_spruce.png`
`hamster_bedding_13_acacia.png`
`hamster_bedding_13_bamboo.png`
`hamster_bedding_13_cherry.png`
`hamster_bedding_13_dark_oak.png`
`hamster_bedding_13_jungle.png`
`hamster_bedding_13_mangrove.png`
`hamster_bedding_13_oak_birch.png`
`hamster_bedding_13_spruce.png`
`hamster_bedding_14_acacia.png`
`hamster_bedding_14_bamboo.png`
`hamster_bedding_14_cherry.png`
`hamster_bedding_14_dark_oak.png`
`hamster_bedding_14_jungle.png`
`hamster_bedding_14_mangrove.png`
`hamster_bedding_14_oak_birch.png`
`hamster_bedding_14_spruce.png`
`hamster_bedding_15_acacia.png`
`hamster_bedding_15_bamboo.png`
`hamster_bedding_15_cherry.png`
`hamster_bedding_15_dark_oak.png`
`hamster_bedding_15_jungle.png`
`hamster_bedding_15_mangrove.png`
`hamster_bedding_15_oak_birch.png`
`hamster_bedding_15_spruce.png`
`hamster_bedding_16_acacia.png`
`hamster_bedding_16_bamboo.png`
`hamster_bedding_16_cherry.png`
`hamster_bedding_16_dark_oak.png`
`hamster_bedding_16_jungle.png`
`hamster_bedding_16_mangrove.png`
`hamster_bedding_16_oak_birch.png`
`hamster_bedding_16_spruce.png`
`hamster_bedding_1_acacia.png`
`hamster_bedding_1_bamboo.png`
`hamster_bedding_1_cherry.png`
`hamster_bedding_1_dark_oak.png`
`hamster_bedding_1_jungle.png`
`hamster_bedding_1_mangrove.png`
`hamster_bedding_1_oak_birch.png`
`hamster_bedding_1_spruce.png`
`hamster_bedding_2_acacia.png`
`hamster_bedding_2_bamboo.png`
`hamster_bedding_2_cherry.png`
`hamster_bedding_2_dark_oak.png`
`hamster_bedding_2_jungle.png`
`hamster_bedding_2_mangrove.png`
`hamster_bedding_2_oak_birch.png`
`hamster_bedding_2_spruce.png`
`hamster_bedding_3_acacia.png`
`hamster_bedding_3_bamboo.png`
`hamster_bedding_3_cherry.png`
`hamster_bedding_3_dark_oak.png`
`hamster_bedding_3_jungle.png`
`hamster_bedding_3_mangrove.png`
`hamster_bedding_3_oak_birch.png`
`hamster_bedding_3_spruce.png`
`hamster_bedding_4_acacia.png`
`hamster_bedding_4_bamboo.png`
`hamster_bedding_4_cherry.png`
`hamster_bedding_4_dark_oak.png`
`hamster_bedding_4_jungle.png`
`hamster_bedding_4_mangrove.png`
`hamster_bedding_4_oak_birch.png`
`hamster_bedding_4_spruce.png`
`hamster_bedding_5_acacia.png`
`hamster_bedding_5_bamboo.png`
`hamster_bedding_5_cherry.png`
`hamster_bedding_5_dark_oak.png`
`hamster_bedding_5_jungle.png`
`hamster_bedding_5_mangrove.png`
`hamster_bedding_5_oak_birch.png`
`hamster_bedding_5_spruce.png`
`hamster_bedding_6_acacia.png`
`hamster_bedding_6_bamboo.png`
`hamster_bedding_6_cherry.png`
`hamster_bedding_6_dark_oak.png`
`hamster_bedding_6_jungle.png`
`hamster_bedding_6_mangrove.png`
`hamster_bedding_6_oak_birch.png`
`hamster_bedding_6_spruce.png`
`hamster_bedding_7_acacia.png`
`hamster_bedding_7_bamboo.png`
`hamster_bedding_7_cherry.png`
`hamster_bedding_7_dark_oak.png`
`hamster_bedding_7_jungle.png`
`hamster_bedding_7_mangrove.png`
`hamster_bedding_7_oak_birch.png`
`hamster_bedding_7_spruce.png`
`hamster_bedding_8_acacia.png`
`hamster_bedding_8_bamboo.png`
`hamster_bedding_8_cherry.png`
`hamster_bedding_8_dark_oak.png`
`hamster_bedding_8_jungle.png`
`hamster_bedding_8_mangrove.png`
`hamster_bedding_8_oak_birch.png`
`hamster_bedding_8_spruce.png`
`hamster_bedding_9_acacia.png`
`hamster_bedding_9_bamboo.png`
`hamster_bedding_9_cherry.png`
`hamster_bedding_9_dark_oak.png`
`hamster_bedding_9_jungle.png`
`hamster_bedding_9_mangrove.png`
`hamster_bedding_9_oak_birch.png`
`hamster_bedding_9_spruce.png`

### 📂 `common/src/main/resources/data/adorablehamsterpets/advancements/husbandry/`
`canine_aspirations.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/nose_for_treasure",
  "display": {
    "icon": {
      "item": "minecraft:bone"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.canine_aspirations.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.canine_aspirations.description"
    },
    "frame": "task",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "hamster_found_diamond": {
      "trigger": "adorablehamsterpets:hamster_led_to_diamond"
    }
  }
}
```

`cheeky_storage.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/craft_food_mix",
  "display": {
    "icon": {
      "item": "minecraft:bundle"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.cheeky_storage.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.cheeky_storage.description"
    },
    "frame": "goal",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "pouch_unlocked": {
      "trigger": "adorablehamsterpets:cheek_pouch_unlocked"
    }
  }
}
```

`chipmunk_aspirations.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/cheeky_storage",
  "display": {
    "icon": {
      "item": "minecraft:bundle"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.chipmunk_aspirations.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.chipmunk_aspirations.description"
    },
    "frame": "task",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "pouch_filled": {
      "trigger": "adorablehamsterpets:hamster_pouch_filled"
    }
  }
}
```

`craft_all_hamster_beds.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/craft_hamster_bed",
  "display": {
    "icon": {"item": "adorablehamsterpets:hamster_bed_cherry"},
    "title": { "translate": "advancements.adorablehamsterpets.husbandry.craft_all_hamster_beds.title" },
    "description": { "translate": "advancements.adorablehamsterpets.husbandry.craft_all_hamster_beds.description" },
    "frame": "challenge",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "crafted_oak": {
      "trigger": "minecraft:recipe_crafted",
      "conditions": { "recipe_id": "adorablehamsterpets:hamster_bed_oak" }
    },
    "crafted_spruce": {
      "trigger": "minecraft:recipe_crafted",
      "conditions": { "recipe_id": "adorablehamsterpets:hamster_bed_spruce" }
    },
    "crafted_birch": {
      "trigger": "minecraft:recipe_crafted",
      "conditions": { "recipe_id": "adorablehamsterpets:hamster_bed_birch" }
    },
    "crafted_jungle": {
      "trigger": "minecraft:recipe_crafted",
      "conditions": { "recipe_id": "adorablehamsterpets:hamster_bed_jungle" }
    },
    "crafted_acacia": {
      "trigger": "minecraft:recipe_crafted",
      "conditions": { "recipe_id": "adorablehamsterpets:hamster_bed_acacia" }
    },
    "crafted_dark_oak": {
      "trigger": "minecraft:recipe_crafted",
      "conditions": { "recipe_id": "adorablehamsterpets:hamster_bed_dark_oak" }
    },
    "crafted_mangrove": {
      "trigger": "minecraft:recipe_crafted",
      "conditions": { "recipe_id": "adorablehamsterpets:hamster_bed_mangrove" }
    },
    "crafted_cherry": {
      "trigger": "minecraft:recipe_crafted",
      "conditions": { "recipe_id": "adorablehamsterpets:hamster_bed_cherry" }
    },
    "crafted_bamboo": {
      "trigger": "minecraft:recipe_crafted",
      "conditions": { "recipe_id": "adorablehamsterpets:hamster_bed_bamboo" }
    }
  },
  "requirements": [
    ["crafted_oak"],
    ["crafted_spruce"],
    ["crafted_birch"],
    ["crafted_jungle"],
    ["crafted_acacia"],
    ["crafted_dark_oak"],
    ["crafted_mangrove"],
    ["crafted_cherry"],
    ["crafted_bamboo"]
  ]
}
```

`craft_bait.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/seed_money",
  "display": {
    "icon": {
     "item": "adorablehamsterpets:sliced_cucumber"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.craft_bait.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.craft_bait.description"
    },
    "frame": "task",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "crafted_sliced_cucumber": {
      "trigger": "minecraft:recipe_crafted",
      "conditions": {
        "recipe_id": "adorablehamsterpets:sliced_cucumber"
      }
    }
  }
}
```

`craft_food_mix.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/sunflower_hoarder",
  "display": {
    "icon": {
     "item": "adorablehamsterpets:hamster_food_mix"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.craft_food_mix.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.craft_food_mix.description"
    },
    "frame": "task",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "crafted_hamster_food_mix": {
      "trigger": "minecraft:recipe_crafted",
      "conditions": {
        "recipe_id": "adorablehamsterpets:hamster_food_mix_from_sunflower_seeds"
      }
    }
  }
}
```

`craft_hamster_bed.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/craft_hamster_bedding",
  "display": {
    "icon": {"item": "adorablehamsterpets:hamster_bed_oak"},
    "title": { "translate": "advancements.adorablehamsterpets.husbandry.craft_hamster_bed.title" },
    "description": { "translate": "advancements.adorablehamsterpets.husbandry.craft_hamster_bed.description" },
    "frame": "task",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "crafted_oak": {
      "trigger": "minecraft:recipe_crafted",
      "conditions": { "recipe_id": "adorablehamsterpets:hamster_bed_oak" }
    },
    "crafted_spruce": {
      "trigger": "minecraft:recipe_crafted",
      "conditions": { "recipe_id": "adorablehamsterpets:hamster_bed_spruce" }
    },
    "crafted_birch": {
      "trigger": "minecraft:recipe_crafted",
      "conditions": { "recipe_id": "adorablehamsterpets:hamster_bed_birch" }
    },
    "crafted_jungle": {
      "trigger": "minecraft:recipe_crafted",
      "conditions": { "recipe_id": "adorablehamsterpets:hamster_bed_jungle" }
    },
    "crafted_acacia": {
      "trigger": "minecraft:recipe_crafted",
      "conditions": { "recipe_id": "adorablehamsterpets:hamster_bed_acacia" }
    },
    "crafted_dark_oak": {
      "trigger": "minecraft:recipe_crafted",
      "conditions": { "recipe_id": "adorablehamsterpets:hamster_bed_dark_oak" }
    },
    "crafted_mangrove": {
      "trigger": "minecraft:recipe_crafted",
      "conditions": { "recipe_id": "adorablehamsterpets:hamster_bed_mangrove" }
    },
    "crafted_cherry": {
      "trigger": "minecraft:recipe_crafted",
      "conditions": { "recipe_id": "adorablehamsterpets:hamster_bed_cherry" }
    },
    "crafted_bamboo": {
      "trigger": "minecraft:recipe_crafted",
      "conditions": { "recipe_id": "adorablehamsterpets:hamster_bed_bamboo" }
    }
  },
  "requirements": [
    [
      "crafted_oak",
      "crafted_spruce",
      "crafted_birch",
      "crafted_jungle",
      "crafted_acacia",
      "crafted_dark_oak",
      "crafted_mangrove",
      "crafted_cherry",
      "crafted_bamboo"
    ]
  ]
}
```

`craft_hamster_bedding.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/root",
  "display": {
    "icon": {
      "item": "adorablehamsterpets:hamster_bedding"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.craft_hamster_bedding.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.craft_hamster_bedding.description"
    },
    "frame": "task",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "crafted_hamster_bedding": {
      "trigger": "minecraft:recipe_crafted",
      "conditions": {
        "recipe_id": "adorablehamsterpets:hamster_bedding"
      }
    }
  }
}
```

`dispensed_hamster_bedding.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/craft_hamster_bedding",
  "display": {
    "icon": {
      "item": "minecraft:dispenser"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.dispensed_hamster_bedding.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.dispensed_hamster_bedding.description"
    },
    "frame": "task",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "dispensed_bedding": {
      "trigger": "adorablehamsterpets:dispensed_hamster_bedding"
    }
  }
}
```

`green_bean_gardener.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/root",
  "display": {
    "icon": {
     "item": "adorablehamsterpets:green_bean_seeds"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.green_bean_gardener.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.green_bean_gardener.description"
    },
    "frame": "task",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "has_green_bean_seeds": {
      "trigger": "minecraft:inventory_changed",
      "conditions": {
        "items": [
          {
            "items": ["adorablehamsterpets:green_bean_seeds"]
          }
        ]
      }
    }
  }
}
```

`hamster_bed_linked.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/craft_hamster_bed",
  "display": {
    "icon": {
      "item": "minecraft:lead"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.hamster_bed_linked.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.hamster_bed_linked.description"
    },
    "frame": "task",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "linked_bed": {
      "trigger": "adorablehamsterpets:hamster_bed_linked"
    }
  }
}
```

`hamster_slept_in_bed.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/hamster_bed_linked",
  "display": {
    "icon": {
      "item": "minecraft:red_bed"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.hamster_slept_in_bed.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.hamster_slept_in_bed.description"
    },
    "frame": "goal",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "slept_in_bed": {
      "trigger": "adorablehamsterpets:hamster_slept_in_bed"
    }
  }
}
```

`impending_doom_squeak.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/shoulder_hamster",
  "display": {
    "icon": {
      "item": "minecraft:gunpowder"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.impending_doom_squeak.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.impending_doom_squeak.description"
    },
    "frame": "task",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "creeper_alert": {
      "trigger": "adorablehamsterpets:hamster_creeper_alert_triggered"
    }
  }
}
```

`nose_for_treasure.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/shoulder_hamster",
  "display": {
    "icon": {
      "item": "minecraft:diamond"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.nose_for_treasure.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.nose_for_treasure.description"
    },
    "frame": "task",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "diamond_alert": {
      "trigger": "adorablehamsterpets:hamster_diamond_alert_triggered"
    }
  }
}
```

`petal_pusher.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/tame_hamster",
  "display": {
    "icon": {
      "item": "minecraft:pink_petals"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.petal_pusher.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.petal_pusher.description"
    },
    "frame": "task",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "applied_petal": {
      "trigger": "adorablehamsterpets:applied_pink_petal",
      "conditions": {
        "hamster": [
          {
            "condition": "minecraft:entity_properties",
            "entity": "this",
            "predicate": {
              "type": "adorablehamsterpets:hamster"
            }
          }
        ]
      }
    }
  }
}
```

`placed_bed_upside_down.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/craft_hamster_bed",
  "display": {
    "icon": {
      "item": "adorablehamsterpets:upside_down_hamster_bed_icon"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.placed_bed_upside_down.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.placed_bed_upside_down.description"
    },
    "frame": "goal",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "placed_upside_down": {
      "trigger": "adorablehamsterpets:hamster_bed_placed_upside_down"
    }
  }
}
```

`pocket_paramedic.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/cheeky_storage",
  "display": {
    "icon": {
     "item": "adorablehamsterpets:hamster_food_mix"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.pocket_paramedic.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.pocket_paramedic.description"
    },
    "frame": "task",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "hamster_auto_fed": {
      "trigger": "adorablehamsterpets:hamster_auto_fed"
    }
  }
}
```

`root.json`
```json
{
  "display": {
    "icon": {
     "item": "adorablehamsterpets:hamster_spawn_egg"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.root.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.root.description"
    },
    "background": "adorablehamsterpets:textures/gui/advancements/background.png",
    "frame": "task",
    "show_toast": false,
    "announce_to_chat": false,
    "hidden": false
  },
  "criteria": {
    "always_unlock": {
      "trigger": "minecraft:location"
    }
  }
}
```

`seed_money.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/root",
  "display": {
    "icon": {
     "item": "adorablehamsterpets:cucumber_seeds"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.seed_money.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.seed_money.description"
    },
    "frame": "task",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "has_cucumber_seeds": {
      "trigger": "minecraft:inventory_changed",
      "conditions": {
        "items": [
          {
            "items": ["adorablehamsterpets:cucumber_seeds"]
          }
        ]
      }
    }
  }
}
```

`shoulder_hamster.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/tame_hamster",
  "display": {
    "icon": {
     "item": "adorablehamsterpets:cheese"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.shoulder_hamster.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.shoulder_hamster.description"
    },
    "frame": "goal",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "hamster_on_shoulder": {
      "trigger": "adorablehamsterpets:hamster_on_shoulder"
    }
  }
}
```

`steamy_greens.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/green_bean_gardener",
  "display": {
    "icon": {
     "item": "adorablehamsterpets:steamed_green_beans"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.steamy_greens.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.steamy_greens.description"
    },
    "frame": "task",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "has_steamed_green_beans": {
      "trigger": "minecraft:inventory_changed",
      "conditions": {
        "items": [
          {
            "items": ["adorablehamsterpets:steamed_green_beans"]
          }
        ]
      }
    }
  }
}
```

`sunflower_hoarder.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/root",
  "display": {
    "icon": {
     "item": "adorablehamsterpets:sunflower_seeds"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.sunflower_hoarder.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.sunflower_hoarder.description"
    },
    "frame": "task",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "has_sunflower_seeds": {
      "trigger": "minecraft:inventory_changed",
      "conditions": {
        "items": [
          {
            "items": ["adorablehamsterpets:sunflower_seeds"]
          }
        ]
      }
    }
  }
}
```

`supercharged_squeaker.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/steamy_greens",
  "display": {
    "icon": {
      "item": "minecraft:potion",
      "nbt": "{Potion:\"minecraft:swiftness\",display:{Name:'{\"text\":\"Hamster Super Serum\",\"italic\":false,\"color\":\"light_purple\"}'},CustomModelData:1}"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.supercharged_squeaker.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.supercharged_squeaker.description"
    },
    "frame": "goal",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "fed_steamed_beans": {
      "trigger": "adorablehamsterpets:fed_hamster_steamed_beans"
    }
  }
}
```

`tame_hamster.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/craft_bait",
  "display": {
    "icon": {
     "item": "adorablehamsterpets:hamster_spawn_egg"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.tame_hamster.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.tame_hamster.description"
    },
    "frame": "goal",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "tamed_hamster": {
      "trigger": "minecraft:tame_animal",
      "conditions": {
        "entity": [
          {
            "condition": "minecraft:entity_properties",
            "entity": "this",
            "predicate": {
              "type": "adorablehamsterpets:hamster"
            }
          }
        ]
      }
    }
  }
}
```

`throw_hamster.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/shoulder_hamster",
  "display": {
    "icon": {
      "item": "minecraft:creeper_head"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.throw_hamster.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.throw_hamster.description"
    },
    "frame": "challenge",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "hamster_thrown": {
      "trigger": "adorablehamsterpets:hamster_thrown"
    }
  }
}
```

`used_hamster_bedding.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/craft_hamster_bedding",
  "display": {
    "icon": {
      "item": "minecraft:feather"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.husbandry.used_hamster_bedding.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.husbandry.used_hamster_bedding.description"
    },
    "frame": "task",
    "show_toast": true,
    "announce_to_chat": true,
    "hidden": false
  },
  "criteria": {
    "used_bedding": {
      "trigger": "adorablehamsterpets:used_hamster_bedding"
    }
  }
}
```

### 📂 `common/src/main/resources/data/adorablehamsterpets/advancements/technical/`
`crafted_guide_book.json`
```json
{
  "parent": "adorablehamsterpets:husbandry/root",
  "display": {
    "icon": {
     "item": "adorablehamsterpets:hamster_guide_book"
    },
    "title": {
      "translate": "advancements.adorablehamsterpets.technical.crafted_guide_book.title"
    },
    "description": {
      "translate": "advancements.adorablehamsterpets.technical.crafted_guide_book.description"
    },
    "frame": "task",
    "show_toast": true,
    "announce_to_chat": false,
    "hidden": true
  },
  "criteria": {
    "crafted_the_book": {
      "trigger": "minecraft:recipe_crafted",
      "conditions": {
        "recipe_id": "adorablehamsterpets:hamster_guide_book_from_crafting"
      }
    }
  },
  "rewards": {
    "function": "adorablehamsterpets:technical/crafted_guide_book_fx"
  }
}
```

`hamster_found_gold_first_time.json`
```json
{
  "criteria": {
    "found_gold": {
      "trigger": "adorablehamsterpets:hamster_found_gold"
    }
  },
  "rewards": {}
}
```

`has_received_initial_guidebook.json`
```json
{
  "criteria": {
    "received": {
      "trigger": "minecraft:impossible"
    }
  }
}
```

`sweet_potato_easter_egg_triggered_flag.json`
```json
{
  "criteria": {
    "impossible": {
      "trigger": "minecraft:impossible"
    }
  }
}
```

`sweet_potato_named.json`
```json
{
  "criteria": {
    "named_a_hamster": {
      "trigger": "minecraft:player_interacted_with_entity",
      "conditions": {
        "item": {
          "items": ["minecraft:name_tag"]
        },
        "entity": [
          {
            "condition": "minecraft:entity_properties",
            "entity": "this",
            "predicate": {
              "type": "adorablehamsterpets:hamster"
            }
          }
        ]
      }
    }
  },
  "rewards": {
    "function": "adorablehamsterpets:technical/check_sweet_potato_name"
  }
}
```

### 📂 `common/src/main/resources/data/adorablehamsterpets/functions/debug/`
`spawn_all_variants.mcfunction`
```mcfunction
# Adorable Hamster Pets - Spawn All Variants (No AI, Alphabetical Order, Per-Color Rows)
# Spawns one of each hamster variant, with each base color group in its own row
# along the positive X axis. AI disabled.

# --- Row 1: BLACK Variants (Z = 0) ---
summon adorablehamsterpets:hamster ~0 ~ ~0 {HamsterVariant:1,NoAI:1b}
summon adorablehamsterpets:hamster ~1 ~ ~0 {HamsterVariant:15,NoAI:1b}
summon adorablehamsterpets:hamster ~2 ~ ~0 {HamsterVariant:16,NoAI:1b}
summon adorablehamsterpets:hamster ~3 ~ ~0 {HamsterVariant:17,NoAI:1b}
summon adorablehamsterpets:hamster ~4 ~ ~0 {HamsterVariant:18,NoAI:1b}
summon adorablehamsterpets:hamster ~5 ~ ~0 {HamsterVariant:19,NoAI:1b}
summon adorablehamsterpets:hamster ~6 ~ ~0 {HamsterVariant:20,NoAI:1b}
summon adorablehamsterpets:hamster ~7 ~ ~0 {HamsterVariant:21,NoAI:1b}
summon adorablehamsterpets:hamster ~8 ~ ~0 {HamsterVariant:22,NoAI:1b}

# --- Row 2: BLUE Variants (Z = 2) ---
summon adorablehamsterpets:hamster ~0 ~ ~2 {HamsterVariant:55,NoAI:1b}
summon adorablehamsterpets:hamster ~1 ~ ~2 {HamsterVariant:57,NoAI:1b}
summon adorablehamsterpets:hamster ~2 ~ ~2 {HamsterVariant:58,NoAI:1b}
summon adorablehamsterpets:hamster ~3 ~ ~2 {HamsterVariant:59,NoAI:1b}
summon adorablehamsterpets:hamster ~4 ~ ~2 {HamsterVariant:60,NoAI:1b}
summon adorablehamsterpets:hamster ~5 ~ ~2 {HamsterVariant:61,NoAI:1b}
summon adorablehamsterpets:hamster ~6 ~ ~2 {HamsterVariant:62,NoAI:1b}
summon adorablehamsterpets:hamster ~7 ~ ~2 {HamsterVariant:63,NoAI:1b}
summon adorablehamsterpets:hamster ~8 ~ ~2 {HamsterVariant:64,NoAI:1b}

# --- Row 3: CHOCOLATE Variants (Z = 4) ---
summon adorablehamsterpets:hamster ~0 ~ ~4 {HamsterVariant:2,NoAI:1b}
summon adorablehamsterpets:hamster ~1 ~ ~4 {HamsterVariant:23,NoAI:1b}
summon adorablehamsterpets:hamster ~2 ~ ~4 {HamsterVariant:24,NoAI:1b}
summon adorablehamsterpets:hamster ~3 ~ ~4 {HamsterVariant:25,NoAI:1b}
summon adorablehamsterpets:hamster ~4 ~ ~4 {HamsterVariant:26,NoAI:1b}
summon adorablehamsterpets:hamster ~5 ~ ~4 {HamsterVariant:27,NoAI:1b}
summon adorablehamsterpets:hamster ~6 ~ ~4 {HamsterVariant:28,NoAI:1b}
summon adorablehamsterpets:hamster ~7 ~ ~4 {HamsterVariant:29,NoAI:1b}
summon adorablehamsterpets:hamster ~8 ~ ~4 {HamsterVariant:30,NoAI:1b}

# --- Row 4: CREAM Variants (Z = 6) ---
summon adorablehamsterpets:hamster ~0 ~ ~6 {HamsterVariant:3,NoAI:1b}
summon adorablehamsterpets:hamster ~1 ~ ~6 {HamsterVariant:31,NoAI:1b}
summon adorablehamsterpets:hamster ~2 ~ ~6 {HamsterVariant:32,NoAI:1b}
summon adorablehamsterpets:hamster ~3 ~ ~6 {HamsterVariant:33,NoAI:1b}
summon adorablehamsterpets:hamster ~4 ~ ~6 {HamsterVariant:34,NoAI:1b}
summon adorablehamsterpets:hamster ~5 ~ ~6 {HamsterVariant:35,NoAI:1b}
summon adorablehamsterpets:hamster ~6 ~ ~6 {HamsterVariant:36,NoAI:1b}
summon adorablehamsterpets:hamster ~7 ~ ~6 {HamsterVariant:37,NoAI:1b}
summon adorablehamsterpets:hamster ~8 ~ ~6 {HamsterVariant:38,NoAI:1b}

# --- Row 5: DARK_GRAY Variants (Z = 8) ---
summon adorablehamsterpets:hamster ~0 ~ ~8 {HamsterVariant:4,NoAI:1b}
summon adorablehamsterpets:hamster ~1 ~ ~8 {HamsterVariant:39,NoAI:1b}
summon adorablehamsterpets:hamster ~2 ~ ~8 {HamsterVariant:40,NoAI:1b}
summon adorablehamsterpets:hamster ~3 ~ ~8 {HamsterVariant:41,NoAI:1b}
summon adorablehamsterpets:hamster ~4 ~ ~8 {HamsterVariant:42,NoAI:1b}
summon adorablehamsterpets:hamster ~5 ~ ~8 {HamsterVariant:43,NoAI:1b}
summon adorablehamsterpets:hamster ~6 ~ ~8 {HamsterVariant:44,NoAI:1b}
summon adorablehamsterpets:hamster ~7 ~ ~8 {HamsterVariant:45,NoAI:1b}
summon adorablehamsterpets:hamster ~8 ~ ~8 {HamsterVariant:46,NoAI:1b}

# --- Row 6: LAVENDER Variants (Z = 10) ---
summon adorablehamsterpets:hamster ~0 ~ ~10 {HamsterVariant:56,NoAI:1b}
summon adorablehamsterpets:hamster ~1 ~ ~10 {HamsterVariant:65,NoAI:1b}
summon adorablehamsterpets:hamster ~2 ~ ~10 {HamsterVariant:66,NoAI:1b}
summon adorablehamsterpets:hamster ~3 ~ ~10 {HamsterVariant:67,NoAI:1b}
summon adorablehamsterpets:hamster ~4 ~ ~10 {HamsterVariant:68,NoAI:1b}
summon adorablehamsterpets:hamster ~5 ~ ~10 {HamsterVariant:69,NoAI:1b}
summon adorablehamsterpets:hamster ~6 ~ ~10 {HamsterVariant:70,NoAI:1b}
summon adorablehamsterpets:hamster ~7 ~ ~10 {HamsterVariant:71,NoAI:1b}
summon adorablehamsterpets:hamster ~8 ~ ~10 {HamsterVariant:72,NoAI:1b}

# --- Row 7: LIGHT_GRAY Variants (Z = 12) ---
summon adorablehamsterpets:hamster ~0 ~ ~12 {HamsterVariant:5,NoAI:1b}
summon adorablehamsterpets:hamster ~1 ~ ~12 {HamsterVariant:47,NoAI:1b}
summon adorablehamsterpets:hamster ~2 ~ ~12 {HamsterVariant:48,NoAI:1b}
summon adorablehamsterpets:hamster ~3 ~ ~12 {HamsterVariant:49,NoAI:1b}
summon adorablehamsterpets:hamster ~4 ~ ~12 {HamsterVariant:50,NoAI:1b}
summon adorablehamsterpets:hamster ~5 ~ ~12 {HamsterVariant:51,NoAI:1b}
summon adorablehamsterpets:hamster ~6 ~ ~12 {HamsterVariant:52,NoAI:1b}
summon adorablehamsterpets:hamster ~7 ~ ~12 {HamsterVariant:53,NoAI:1b}
summon adorablehamsterpets:hamster ~8 ~ ~12 {HamsterVariant:54,NoAI:1b}

# --- Row 8: ORANGE Variants (Z = 14) ---
summon adorablehamsterpets:hamster ~0 ~ ~14 {HamsterVariant:0,NoAI:1b}
summon adorablehamsterpets:hamster ~1 ~ ~14 {HamsterVariant:7,NoAI:1b}
summon adorablehamsterpets:hamster ~2 ~ ~14 {HamsterVariant:8,NoAI:1b}
summon adorablehamsterpets:hamster ~3 ~ ~14 {HamsterVariant:9,NoAI:1b}
summon adorablehamsterpets:hamster ~4 ~ ~14 {HamsterVariant:10,NoAI:1b}
summon adorablehamsterpets:hamster ~5 ~ ~14 {HamsterVariant:11,NoAI:1b}
summon adorablehamsterpets:hamster ~6 ~ ~14 {HamsterVariant:12,NoAI:1b}
summon adorablehamsterpets:hamster ~7 ~ ~14 {HamsterVariant:13,NoAI:1b}
summon adorablehamsterpets:hamster ~8 ~ ~14 {HamsterVariant:14,NoAI:1b}

# --- Row 9: WHITE Variant (Z = 16) ---
summon adorablehamsterpets:hamster ~0 ~ ~16 {HamsterVariant:6,NoAI:1b}

# Optional: Announce completion
say Summoned all 73 hamster variants in per-color rows!
```

`spawn_variants_circle_ai.mcfunction`
```mcfunction
# Adorable Hamster Pets - Spawn All Variants in Tighter Scattered Circle (AI Enabled)
# Spawns one of each hamster variant in a tighter scattered circular pattern. AI enabled.

# Ring 1: 15 hamsters, Radius ~1.6
# Ring 2: 25 hamsters, Radius ~2.6
# Ring 3: 33 hamsters, Radius ~3.5

# --- Ring 1 (Radius ~1.6, 15 Hamsters) ---
# BLACK (9) + BLUE (6)
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~1.6 ~ ~0 {HamsterVariant:1}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~1.52 ~ ~0.5 {HamsterVariant:15}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~1.29 ~ ~0.94 {HamsterVariant:16}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0.94 ~ ~1.29 {HamsterVariant:17}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0.5 ~ ~1.52 {HamsterVariant:18}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0 ~ ~1.6 {HamsterVariant:19}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-0.5 ~ ~1.52 {HamsterVariant:20}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-0.94 ~ ~1.29 {HamsterVariant:21}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-1.29 ~ ~0.94 {HamsterVariant:22}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-1.52 ~ ~0.5 {HamsterVariant:55}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-1.6 ~ ~0 {HamsterVariant:57}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-1.52 ~ ~-0.5 {HamsterVariant:58}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-1.29 ~ ~-0.94 {HamsterVariant:59}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-0.94 ~ ~-1.29 {HamsterVariant:60}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-0.5 ~ ~-1.52 {HamsterVariant:61}

# --- Ring 2 (Radius ~2.6, 25 Hamsters) ---
# BLUE (continued, 3) + CHOCOLATE (9) + CREAM (9) + DARK_GRAY (4)
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0 ~ ~-1.6 {HamsterVariant:62}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0.5 ~ ~-1.52 {HamsterVariant:63}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0.94 ~ ~-1.29 {HamsterVariant:64}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~1.29 ~ ~-0.94 {HamsterVariant:2}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~1.52 ~ ~-0.5 {HamsterVariant:23}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~2.6 ~ ~0 {HamsterVariant:24}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~2.53 ~ ~0.65 {HamsterVariant:25}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~2.34 ~ ~1.24 {HamsterVariant:26}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~2.03 ~ ~1.75 {HamsterVariant:27}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~1.62 ~ ~2.15 {HamsterVariant:28}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~1.13 ~ ~2.42 {HamsterVariant:29}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0.59 ~ ~2.54 {HamsterVariant:30}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0 ~ ~2.6 {HamsterVariant:3}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-0.59 ~ ~2.54 {HamsterVariant:31}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-1.13 ~ ~2.42 {HamsterVariant:32}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-1.62 ~ ~2.15 {HamsterVariant:33}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.03 ~ ~1.75 {HamsterVariant:34}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.34 ~ ~1.24 {HamsterVariant:35}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.53 ~ ~0.65 {HamsterVariant:36}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.6 ~ ~0 {HamsterVariant:37}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.53 ~ ~-0.65 {HamsterVariant:38}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.34 ~ ~-1.24 {HamsterVariant:4}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.03 ~ ~-1.75 {HamsterVariant:39}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-1.62 ~ ~-2.15 {HamsterVariant:40}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-1.13 ~ ~-2.42 {HamsterVariant:41}

# --- Ring 3 (Radius ~3.5, 33 Hamsters) ---
# DARK_GRAY (continued, 5) + LAVENDER (9) + LIGHT_GRAY (9) + ORANGE (9) + WHITE (1)
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-0.59 ~ ~-2.54 {HamsterVariant:42}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0 ~ ~-2.6 {HamsterVariant:43}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0.59 ~ ~-2.54 {HamsterVariant:44}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~1.13 ~ ~-2.42 {HamsterVariant:45}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~1.62 ~ ~-2.15 {HamsterVariant:46}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~3.5 ~ ~0 {HamsterVariant:56}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~3.45 ~ ~0.53 {HamsterVariant:65}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~3.31 ~ ~1.05 {HamsterVariant:66}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~3.08 ~ ~1.55 {HamsterVariant:67}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~2.78 ~ ~2.01 {HamsterVariant:68}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~2.41 ~ ~2.41 {HamsterVariant:69}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~2.01 ~ ~2.78 {HamsterVariant:70}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~1.55 ~ ~3.08 {HamsterVariant:71}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~1.05 ~ ~3.31 {HamsterVariant:72}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0.53 ~ ~3.45 {HamsterVariant:5}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0 ~ ~3.5 {HamsterVariant:47}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-0.53 ~ ~3.45 {HamsterVariant:48}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-1.05 ~ ~3.31 {HamsterVariant:49}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-1.55 ~ ~3.08 {HamsterVariant:50}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.01 ~ ~2.78 {HamsterVariant:51}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.41 ~ ~2.41 {HamsterVariant:52}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.78 ~ ~2.01 {HamsterVariant:53}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-3.08 ~ ~1.55 {HamsterVariant:54}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-3.31 ~ ~1.05 {HamsterVariant:0}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-3.45 ~ ~0.53 {HamsterVariant:7}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-3.5 ~ ~0 {HamsterVariant:8}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-3.45 ~ ~-0.53 {HamsterVariant:9}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-3.31 ~ ~-1.05 {HamsterVariant:10}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-3.08 ~ ~-1.55 {HamsterVariant:11}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.78 ~ ~-2.01 {HamsterVariant:12}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.41 ~ ~-2.41 {HamsterVariant:13}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.01 ~ ~-2.78 {HamsterVariant:14}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0 ~ ~0 {HamsterVariant:6}

say Summoned all 73 variants in a tighter scattered circle (AI Enabled).
```

`spawn_variants_circle_no_ai.mcfunction`
```mcfunction
# Adorable Hamster Pets - Spawn All Variants in Tighter Scattered Circle (No AI)
# Spawns one of each hamster variant in a tighter scattered circular pattern. AI disabled.

# Ring 1: 15 hamsters, Radius ~1.6
# Ring 2: 25 hamsters, Radius ~2.6
# Ring 3: 33 hamsters, Radius ~3.5

# --- Ring 1 (Radius ~1.6, 15 Hamsters) ---
# BLACK (9) + BLUE (6)
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~1.6 ~ ~0 {HamsterVariant:1,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~1.52 ~ ~0.5 {HamsterVariant:15,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~1.29 ~ ~0.94 {HamsterVariant:16,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0.94 ~ ~1.29 {HamsterVariant:17,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0.5 ~ ~1.52 {HamsterVariant:18,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0 ~ ~1.6 {HamsterVariant:19,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-0.5 ~ ~1.52 {HamsterVariant:20,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-0.94 ~ ~1.29 {HamsterVariant:21,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-1.29 ~ ~0.94 {HamsterVariant:22,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-1.52 ~ ~0.5 {HamsterVariant:55,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-1.6 ~ ~0 {HamsterVariant:57,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-1.52 ~ ~-0.5 {HamsterVariant:58,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-1.29 ~ ~-0.94 {HamsterVariant:59,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-0.94 ~ ~-1.29 {HamsterVariant:60,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-0.5 ~ ~-1.52 {HamsterVariant:61,NoAI:1b}

# --- Ring 2 (Radius ~2.6, 25 Hamsters) ---
# BLUE (continued, 3) + CHOCOLATE (9) + CREAM (9) + DARK_GRAY (4)
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0 ~ ~-1.6 {HamsterVariant:62,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0.5 ~ ~-1.52 {HamsterVariant:63,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0.94 ~ ~-1.29 {HamsterVariant:64,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~1.29 ~ ~-0.94 {HamsterVariant:2,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~1.52 ~ ~-0.5 {HamsterVariant:23,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~2.6 ~ ~0 {HamsterVariant:24,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~2.53 ~ ~0.65 {HamsterVariant:25,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~2.34 ~ ~1.24 {HamsterVariant:26,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~2.03 ~ ~1.75 {HamsterVariant:27,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~1.62 ~ ~2.15 {HamsterVariant:28,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~1.13 ~ ~2.42 {HamsterVariant:29,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0.59 ~ ~2.54 {HamsterVariant:30,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0 ~ ~2.6 {HamsterVariant:3,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-0.59 ~ ~2.54 {HamsterVariant:31,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-1.13 ~ ~2.42 {HamsterVariant:32,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-1.62 ~ ~2.15 {HamsterVariant:33,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.03 ~ ~1.75 {HamsterVariant:34,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.34 ~ ~1.24 {HamsterVariant:35,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.53 ~ ~0.65 {HamsterVariant:36,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.6 ~ ~0 {HamsterVariant:37,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.53 ~ ~-0.65 {HamsterVariant:38,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.34 ~ ~-1.24 {HamsterVariant:4,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.03 ~ ~-1.75 {HamsterVariant:39,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-1.62 ~ ~-2.15 {HamsterVariant:40,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-1.13 ~ ~-2.42 {HamsterVariant:41,NoAI:1b}

# --- Ring 3 (Radius ~3.5, 33 Hamsters) ---
# DARK_GRAY (continued, 5) + LAVENDER (9) + LIGHT_GRAY (9) + ORANGE (9) + WHITE (1)
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-0.59 ~ ~-2.54 {HamsterVariant:42,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0 ~ ~-2.6 {HamsterVariant:43,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0.59 ~ ~-2.54 {HamsterVariant:44,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~1.13 ~ ~-2.42 {HamsterVariant:45,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~1.62 ~ ~-2.15 {HamsterVariant:46,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~3.5 ~ ~0 {HamsterVariant:56,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~3.45 ~ ~0.53 {HamsterVariant:65,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~3.31 ~ ~1.05 {HamsterVariant:66,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~3.08 ~ ~1.55 {HamsterVariant:67,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~2.78 ~ ~2.01 {HamsterVariant:68,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~2.41 ~ ~2.41 {HamsterVariant:69,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~2.01 ~ ~2.78 {HamsterVariant:70,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~1.55 ~ ~3.08 {HamsterVariant:71,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~1.05 ~ ~3.31 {HamsterVariant:72,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0.53 ~ ~3.45 {HamsterVariant:5,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0 ~ ~3.5 {HamsterVariant:47,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-0.53 ~ ~3.45 {HamsterVariant:48,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-1.05 ~ ~3.31 {HamsterVariant:49,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-1.55 ~ ~3.08 {HamsterVariant:50,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.01 ~ ~2.78 {HamsterVariant:51,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.41 ~ ~2.41 {HamsterVariant:52,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.78 ~ ~2.01 {HamsterVariant:53,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-3.08 ~ ~1.55 {HamsterVariant:54,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-3.31 ~ ~1.05 {HamsterVariant:0,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-3.45 ~ ~0.53 {HamsterVariant:7,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-3.5 ~ ~0 {HamsterVariant:8,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-3.45 ~ ~-0.53 {HamsterVariant:9,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-3.31 ~ ~-1.05 {HamsterVariant:10,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-3.08 ~ ~-1.55 {HamsterVariant:11,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.78 ~ ~-2.01 {HamsterVariant:12,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.41 ~ ~-2.41 {HamsterVariant:13,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~-2.01 ~ ~-2.78 {HamsterVariant:14,NoAI:1b}
execute positioned ~ ~ ~ run summon adorablehamsterpets:hamster ~0 ~ ~0 {HamsterVariant:6,NoAI:1b}

say Summoned all 73 variants in a tighter scattered circle (No AI).
```

### 📂 `common/src/main/resources/data/adorablehamsterpets/functions/player/`
`give_book_to_self.mcfunction`
```mcfunction
# This function is executed by the server AS the player who ran the command link.
# It gives the player one instance of the custom guide book.
give @s adorablehamsterpets:hamster_guide_book{"patchouli:book":"adorablehamsterpets:hamster_tips_guide_book"} 1

# --- Play Sound and Particle Effects ---
playsound minecraft:block.enchantment_table.use player @s ~ ~ ~ 0.5 1.2
playsound minecraft:item.book.page_turn player @s ~ ~ ~ 0.7 1.5
particle minecraft:enchant ~ ~1 ~ 0.3 0.5 0.3 0.05 50 force @s
particle minecraft:happy_villager ~ ~1 ~ 0.5 0.5 0.5 0.02 20 force @s

# --- Send Action Bar Message ---
title @s actionbar {"text":"A wealth of hamster knowledge, rediscovered.","color":"gold"}
```

### 📂 `common/src/main/resources/data/adorablehamsterpets/functions/technical/`
`check_sweet_potato_name.mcfunction`
```mcfunction
# Function to check if a nearby hamster was just named "Sweet Potato"
# This function is called as a reward from the sweet_potato_named advancement.
# It runs as the player who performed the interaction.

# Check if the nearest hamster (likely the one just interacted with) is named "Sweet Potato" (case-insensitive)
# We'll check common capitalizations.
# This approach checks the most likely inputs.
execute if entity @e[type=adorablehamsterpets:hamster,name="Sweet Potato",distance=..3,limit=1,sort=nearest] run function adorablehamsterpets:technical/sweet_potato_effects
execute if entity @e[type=adorablehamsterpets:hamster,name="sweet potato",distance=..3,limit=1,sort=nearest] run function adorablehamsterpets:technical/sweet_potato_effects
execute if entity @e[type=adorablehamsterpets:hamster,name="Sweet potato",distance=..3,limit=1,sort=nearest] run function adorablehamsterpets:technical/sweet_potato_effects
execute if entity @e[type=adorablehamsterpets:hamster,name="sweetpotato",distance=..3,limit=1,sort=nearest] run function adorablehamsterpets:technical/sweet_potato_effects
execute if entity @e[type=adorablehamsterpets:hamster,name="Sweet-Potato",distance=..3,limit=1,sort=nearest] run function adorablehamsterpets:technical/sweet_potato_effects
execute if entity @e[type=adorablehamsterpets:hamster,name="sweetpotato",distance=..3,limit=1,sort=nearest] run function adorablehamsterpets:technical/sweet_potato_effects

# Revoke the calling advancement so this check can run again if another hamster is named.
# This makes the *check* repeatable, but the effects function will only grant its own "flag" once.
advancement revoke @s only adorablehamsterpets:technical/sweet_potato_named
```

`crafted_guide_book_fx.mcfunction`
```mcfunction
# Adorable Hamster Pets - Crafted Guide Book Effects
# Plays when the player crafts the Hamster Tips Guide Book.

# --- 1. Play Sound and Particle Effects ---
playsound minecraft:block.enchantment_table.use player @s ~ ~ ~ 0.5 1.2
playsound minecraft:item.book.page_turn player @s ~ ~ ~ 0.7 1.5
particle minecraft:enchant ~ ~1 ~ 0.3 0.5 0.3 0.05 50 force @s
particle minecraft:happy_villager ~ ~1 ~ 0.5 0.5 0.5 0.02 20 force @s

# --- 2. Send Action Bar Message ---
title @s actionbar {"text":"A wealth of hamster knowledge, rediscovered.","color":"gold"}

# --- 3. Revoke Advancement to Make it Re-triggerable ---
advancement revoke @s only adorablehamsterpets:technical/crafted_guide_book
```

`sweet_potato_effects.mcfunction`
```mcfunction
# -------------------------------------------------------------------
# sweet_potato_effects.mcfunction  –  Java 1.21.1
# Fires once per player who has JUST named a hamster “Sweet Potato”.
# (All lines are gated by: player must *not* already have the flag.)
# -------------------------------------------------------------------

execute as @s at @s unless entity @s[advancements={adorablehamsterpets:technical/sweet_potato_easter_egg_triggered_flag=true}] run title @s actionbar {"text":"Sweet Potato? An inspired name. Very well.","color":"gold","bold":true}

execute as @s at @s unless entity @s[advancements={adorablehamsterpets:technical/sweet_potato_easter_egg_triggered_flag=true}] run playsound minecraft:entity.firework_rocket.launch player @s ~ ~ ~ 1.0 1.0

execute as @s at @s unless entity @s[advancements={adorablehamsterpets:technical/sweet_potato_easter_egg_triggered_flag=true}] run particle minecraft:happy_villager ~ ~1 ~ 0.5 0.5 0.5 0.1 25 force

execute as @s at @s unless entity @s[advancements={adorablehamsterpets:technical/sweet_potato_easter_egg_triggered_flag=true}] run particle minecraft:flash ~ ~1 ~ 0.1 0.1 0.1 0.0 10 force

execute as @s at @s unless entity @s[advancements={adorablehamsterpets:technical/sweet_potato_easter_egg_triggered_flag=true}] run advancement grant @s only adorablehamsterpets:technical/sweet_potato_easter_egg_triggered_flag
```

### 📂 `common/src/main/resources/data/adorablehamsterpets/recipes/`
`hamster_guide_book_from_crafting.json`
```json
{
  "type": "minecraft:crafting_shapeless",
  "category": "misc",
  "ingredients": [
    {
      "item": "minecraft:book"
    },
    {
      "item": "adorablehamsterpets:sliced_cucumber"
    }
  ],
  "result": {
    "item": "adorablehamsterpets:hamster_guide_book",
    "count": 1
  }
}
```

`sliced_cucumber_from_cutting_board.json`
```json
{
  "fabric:load_conditions": [
    { "condition": "fabric:any_mod_loaded", "values": ["farmersdelight"] }
  ],
  "conditions": [
    { "type": "forge:mod_loaded", "modid": "farmersdelight" }
  ],
  "type": "farmersdelight:cutting",
  "ingredients": [
    {
      "item": "adorablehamsterpets:cucumber"
    }
  ],
  "result": [
    {
      "count": 5,
      "item": "adorablehamsterpets:sliced_cucumber"
    }
  ],
  "tool": {
    "tag": "adorablehamsterpets:tools/knives"
  }
}

```

### 📂 `common/src/main/resources/data/adorablehamsterpets/recipes/immersiveengineering_cloche_compat/`
`cloche_cucumber.json`
```json
{
  "fabric:load_conditions": [
    {
      "condition": "fabric:all_mods_loaded", "values": ["immersiveengineering"]
    }
  ],
  "conditions": [
    {
      "type": "forge:mod_loaded", "modid": "immersiveengineering"
    }
  ],
  "type": "immersiveengineering:cloche",
  "input": {
    "item": "adorablehamsterpets:cucumber_seeds"
  },
  "soil": {
    "item": "minecraft:dirt"
  },
  "results": [
    {
      "id": "adorablehamsterpets:cucumber",
      "Count": 2
    },
    {
      "id": "adorablehamsterpets:cucumber_seeds"
    }
  ],
  "time": 640,
  "render": {
    "type": "immersiveengineering:crop",
    "block": "adorablehamsterpets:cucumber_crop"
  }
}

```

`cloche_green_beans.json`
```json
{
  "fabric:load_conditions": [
    {
      "condition": "fabric:all_mods_loaded", "values": ["immersiveengineering"]
    }
  ],
  "conditions": [
    {
      "type": "forge:mod_loaded", "modid": "immersiveengineering"
    }
  ],
  "type": "immersiveengineering:cloche",
  "input": {
    "item": "adorablehamsterpets:green_bean_seeds"
  },
  "soil": {
    "item": "minecraft:dirt"
  },
  "results": [
    {
      "id": "adorablehamsterpets:green_beans",
      "Count": 2
    },
    {
      "id": "adorablehamsterpets:green_bean_seeds"
    }
  ],
  "time": 640,
  "render": {
    "type": "immersiveengineering:crop",
    "block": "adorablehamsterpets:green_beans_crop"
  }
}

```

### 📂 `common/src/main/resources/data/adorablehamsterpets/recipes/thermal_insolator_compat/`
`insolator_cucumber.json`
```json
{
  "fabric:load_conditions": [
    {
      "condition": "fabric:all_mods_loaded", "values": ["thermal"]
    }
  ],
  "conditions": [
    {
      "type": "forge:mod_loaded", "modid": "thermal"
    }
  ],
  "type": "thermal:insolator",
  "ingredient": {
    "item": "adorablehamsterpets:cucumber_seeds"
  },
  "result": [
    {
      "item": "adorablehamsterpets:cucumber",
      "chance": 2.0
    },
    {
      "item": "adorablehamsterpets:cucumber_seeds",
      "chance": 1.1
    }
  ],
  "water_mod": 0.5,
"experience": 0.15
}

```

`insolator_green_beans.json`
```json
{
  "fabric:load_conditions": [
    {
      "condition": "fabric:all_mods_loaded", "values": ["thermal"]
    }
  ],
  "conditions": [
    {
      "type": "forge:mod_loaded", "modid": "thermal"
    }
  ],
  "type": "thermal:insolator",
  "ingredient": {
    "item": "adorablehamsterpets:green_bean_seeds"
  },
  "result": [
    {
      "item": "adorablehamsterpets:green_beans",
      "chance": 2.0
    },
    {
      "item": "adorablehamsterpets:green_bean_seeds",
      "chance": 1.1
    }
  ],
  "water_mod": 0.5,
  "experience": 0.15
}

```

### 📂 `common/src/main/resources/data/adorablehamsterpets/tags/worldgen/biome/`
`is_cave.json`
```json
{
  "replace": false,
  "values": [
    { "id": "#c:is_cave", "required": false },
    { "id": "#forge:is_cave", "required": false }
  ]
}
```

`is_cold.json`
```json
{
  "replace": false,
  "values": [
    { "id": "#c:is_cold", "required": false },
    { "id": "#forge:is_cold", "required": false }
  ]
}
```

`is_dense_vegetation.json`
```json
{
  "replace": false,
  "values": [
    { "id": "#c:is_dense_vegetation", "required": false },
    { "id": "#forge:is_dense_vegetation", "required": false }
  ]
}
```

`is_forest.json`
```json
{
  "replace": false,
  "values": [
    "#minecraft:is_forest",
    { "id": "#c:is_forest", "required": false },
    { "id": "#forge:is_forest", "required": false }
  ]
}
```

`is_icy.json`
```json
{
  "replace": false,
  "values": [
    { "id": "#c:is_icy", "required": false },
    { "id": "#forge:is_icy", "required": false }
  ]
}
```

`is_magical.json`
```json
{
  "replace": false,
  "values": [
    { "id": "#c:is_magical", "required": false },
    { "id": "#forge:is_magical", "required": false }
  ]
}
```

`is_mountain.json`
```json
{
  "replace": false,
  "values": [
    "#minecraft:is_mountain",
    { "id": "#c:is_mountain", "required": false },
    { "id": "#forge:is_mountain", "required": false }
  ]
}
```

`is_mushroom.json`
```json
{
  "replace": false,
  "values": [
    { "id": "#c:is_mushroom", "required": false },
    { "id": "#forge:is_mushroom", "required": false }
  ]
}
```

`is_sandy.json`
```json
{
  "replace": false,
  "values": [
    { "id": "#c:is_sandy", "required": false },
    { "id": "#forge:is_sandy", "required": false }
  ]
}
```

`is_snowy.json`
```json
{
  "replace": false,
  "values": [
    { "id": "#c:is_snowy", "required": false },
    { "id": "#forge:is_snowy", "required": false }
  ]
}
```

`is_sparse_vegetation.json`
```json
{
  "replace": false,
  "values": [
    { "id": "#c:is_sparse_vegetation", "required": false },
    { "id": "#forge:is_sparse_vegetation", "required": false }
  ]
}
```

`is_wet.json`
```json
{
  "replace": false,
  "values": [
    { "id": "#c:is_wet", "required": false },
    { "id": "#forge:is_wet", "required": false }
  ]
}
```

### 📂 `common/src/main/resources/data/c/tags/items/`
`cheese.json`
```json
{
  "replace": false,
  "values": [
    "adorablehamsterpets:cheese"
  ]
}

```

`cucumber_seeds.json`
```json
{
  "replace": false,
  "values": [
    "adorablehamsterpets:cucumber_seeds",
    "#c:seeds/cucumber"
  ]
}

```

`cucumbers.json`
```json
{
  "replace": false,
  "values": [
    "adorablehamsterpets:cucumber",
    "#c:vegetables/cucumber",
    "#c:crops/cucumber"
  ]
}

```

`greenbean_seeds.json`
```json
{
  "replace": false,
  "values": [
    "adorablehamsterpets:green_bean_seeds",
    "#c:seeds/greenbean"
  ]
}

```

`greenbeans.json`
```json
{
  "replace": false,
  "values": [
    "adorablehamsterpets:green_beans",
    "#c:vegetables/greenbean",
    "#c:crops/greenbean"
  ]
}

```

`seeds.json`
```json
{
  "replace": false,
  "values": [
    "#c:seeds/cucumber",
    "#c:seeds/greenbean",
    "#c:seeds/sunflower"
  ]
}

```

`sunflower_seeds.json`
```json
{
  "replace": false,
  "values": [
    "adorablehamsterpets:sunflower_seeds",
    "#c:seeds/sunflower"
  ]
}

```

`sunflowers.json`
```json
{
  "replace": false,
  "values": [
    "adorablehamsterpets:sunflower_block",
    "minecraft:sunflower"
  ]
}

```

### 📂 `common/src/main/resources/data/c/tags/items/crops/`
`cucumber.json`
```json
{
  "replace": false,
  "values": [
    "adorablehamsterpets:cucumber"
  ]
}

```

`greenbean.json`
```json
{
  "replace": false,
  "values": [
    "adorablehamsterpets:green_beans"
  ]
}

```

### 📂 `common/src/main/resources/data/c/tags/items/seeds/`
`cucumber.json`
```json
{
  "replace": false,
  "values": [
    "adorablehamsterpets:cucumber_seeds"
  ]
}

```

`greenbean.json`
```json
{
  "replace": false,
  "values": [
    "adorablehamsterpets:green_bean_seeds"
  ]
}

```

`sunflower.json`
```json
{
  "replace": false,
  "values": [
    "adorablehamsterpets:sunflower_seeds"
  ]
}

```

### 📂 `common/src/main/resources/data/c/tags/items/vegetables/`
`cucumber.json`
```json
{
  "replace": false,
  "values": [
    "adorablehamsterpets:cucumber"
  ]
}

```

`greenbean.json`
```json
{
  "replace": false,
  "values": [
    "adorablehamsterpets:green_beans"
  ]
}

```

### 📂 `common/src/main/resources/data/c/tags/worldgen/biome/`
`hidden_from_locator_selection.json`
```json
{
  "values": []
}
```

`is_aquatic.json`
```json
{
  "values": [
    {
      "id": "#c:is_ocean",
      "required": false
    },
    {
      "id": "#c:is_river",
      "required": false
    }
  ]
}
```

`is_aquatic_icy.json`
```json
{
  "values": [
    "minecraft:frozen_river",
    "minecraft:deep_frozen_ocean",
    "minecraft:frozen_ocean"
  ]
}
```

`is_badlands.json`
```json
{
  "values": [
    {
      "id": "#minecraft:is_badlands",
      "required": false
    }
  ]
}
```

`is_beach.json`
```json
{
  "values": [
    {
      "id": "#minecraft:is_beach",
      "required": false
    }
  ]
}
```

`is_birch_forest.json`
```json
{
  "values": [
    "minecraft:birch_forest",
    "minecraft:old_growth_birch_forest"
  ]
}
```

`is_cave.json`
```json
{
  "values": [
    "minecraft:deep_dark",
    "minecraft:dripstone_caves",
    "minecraft:lush_caves",
    {
      "id": "#c:caves",
      "required": false
    }
  ]
}
```

`is_cold.json`
```json
{
  "values": [
    "#c:is_cold/overworld",
    "#c:is_cold/nether",
    "#c:is_cold/end"
  ]
}
```

`is_dead.json`
```json
{
  "values": []
}
```

`is_deep_ocean.json`
```json
{
  "values": [
    {
      "id": "#minecraft:is_deep_ocean",
      "required": false
    }
  ]
}
```

`is_dense_vegetation.json`
```json
{
  "values": [
    {
      "id": "#c:is_dense_vegetation/overworld",
      "required": false
    },
    {
      "id": "#c:is_dense_vegetation/nether",
      "required": false
    },
    {
      "id": "#c:is_dense_vegetation/end",
      "required": false
    }
  ]
}
```

`is_desert.json`
```json
{
  "values": [
    "minecraft:desert"
  ]
}
```

`is_dry.json`
```json
{
  "values": [
    "#c:is_dry/overworld",
    "#c:is_dry/nether",
    "#c:is_dry/end"
  ]
}
```

`is_end.json`
```json
{
  "values": [
    {
      "id": "#minecraft:is_end",
      "required": false
    },
    {
      "id": "#c:in_the_end",
      "required": false
    }
  ]
}
```

`is_floral.json`
```json
{
  "values": [
    "minecraft:sunflower_plains",
    "minecraft:meadow",
    "minecraft:cherry_grove",
    {
      "id": "#c:is_flower_forest",
      "required": false
    }
  ]
}
```

`is_flower_forest.json`
```json
{
  "values": [
    "minecraft:flower_forest",
    {
      "id": "#c:flower_forests",
      "required": false
    },
    {
      "id": "#c:flower_forests",
      "required": false
    }
  ]
}
```

`is_forest.json`
```json
{
  "values": [
    {
      "id": "#minecraft:is_forest",
      "required": false
    }
  ]
}
```

`is_hill.json`
```json
{
  "values": [
    {
      "id": "#minecraft:is_hill",
      "required": false
    }
  ]
}
```

`is_hot.json`
```json
{
  "values": [
    "#c:is_hot/overworld",
    "#c:is_hot/nether",
    "#c:is_hot/end"
  ]
}
```

`is_icy.json`
```json
{
  "values": [
    "minecraft:frozen_peaks",
    "minecraft:ice_spikes"
  ]
}
```

`is_jungle.json`
```json
{
  "values": [
    {
      "id": "#minecraft:is_jungle",
      "required": false
    }
  ]
}
```

`is_lush.json`
```json
{
  "values": [
    "minecraft:lush_caves"
  ]
}
```

`is_magical.json`
```json
{
  "values": []
}
```

`is_mountain.json`
```json
{
  "values": [
    {
      "id": "#minecraft:is_mountain",
      "required": false
    },
    {
      "id": "#c:is_mountain/peak",
      "required": false
    },
    {
      "id": "#c:is_mountain/slope",
      "required": false
    }
  ]
}
```

`is_mushroom.json`
```json
{
  "values": [
    "minecraft:mushroom_fields"
  ]
}
```

`is_nether.json`
```json
{
  "values": [
    {
      "id": "#minecraft:is_nether",
      "required": false
    },
    {
      "id": "#c:in_nether",
      "required": false
    }
  ]
}
```

`is_nether_forest.json`
```json
{
  "values": [
    "minecraft:warped_forest",
    "minecraft:crimson_forest",
    {
      "id": "#c:nether_forests",
      "required": false
    }
  ]
}
```

`is_ocean.json`
```json
{
  "values": [
    {
      "id": "#minecraft:is_ocean",
      "required": false
    },
    {
      "id": "#c:is_deep_ocean",
      "required": false
    },
    {
      "id": "#c:is_shallow_ocean",
      "required": false
    }
  ]
}
```

`is_old_growth.json`
```json
{
  "values": [
    "minecraft:old_growth_birch_forest",
    "minecraft:old_growth_pine_taiga",
    "minecraft:old_growth_spruce_taiga"
  ]
}
```

`is_outer_end_island.json`
```json
{
  "values": [
    "minecraft:end_highlands",
    "minecraft:end_midlands",
    "minecraft:end_barrens",
    {
      "id": "#c:end_islands",
      "required": false
    }
  ]
}
```

`is_overworld.json`
```json
{
  "values": [
    {
      "id": "#minecraft:is_overworld",
      "required": false
    },
    {
      "id": "#c:in_the_overworld",
      "required": false
    }
  ]
}
```

`is_plains.json`
```json
{
  "values": [
    "minecraft:plains",
    "minecraft:sunflower_plains"
  ]
}
```

`is_plateau.json`
```json
{
  "values": [
    "minecraft:wooded_badlands",
    "minecraft:savanna_plateau",
    "minecraft:cherry_grove",
    "minecraft:meadow"
  ]
}
```

`is_rare.json`
```json
{
  "values": [
    "minecraft:sunflower_plains",
    "minecraft:flower_forest",
    "minecraft:old_growth_birch_forest",
    "minecraft:old_growth_spruce_taiga",
    "minecraft:bamboo_jungle",
    "minecraft:sparse_jungle",
    "minecraft:eroded_badlands",
    "minecraft:savanna_plateau",
    "minecraft:windswept_savanna",
    "minecraft:ice_spikes",
    "minecraft:windswept_gravelly_hills",
    "minecraft:mushroom_fields",
    "minecraft:deep_dark"
  ]
}
```

`is_river.json`
```json
{
  "values": [
    {
      "id": "#minecraft:is_river",
      "required": false
    }
  ]
}
```

`is_sandy.json`
```json
{
  "values": [
    "minecraft:desert",
    "minecraft:badlands",
    "minecraft:wooded_badlands",
    "minecraft:eroded_badlands",
    "minecraft:beach"
  ]
}
```

`is_savanna.json`
```json
{
  "values": [
    {
      "id": "#minecraft:is_savanna",
      "required": false
    }
  ]
}
```

`is_shallow_ocean.json`
```json
{
  "values": [
    "minecraft:ocean",
    "minecraft:lukewarm_ocean",
    "minecraft:warm_ocean",
    "minecraft:cold_ocean",
    "minecraft:frozen_ocean"
  ]
}
```

`is_snowy.json`
```json
{
  "values": [
    "minecraft:snowy_beach",
    "minecraft:snowy_plains",
    "minecraft:ice_spikes",
    "minecraft:snowy_taiga",
    "minecraft:grove",
    "minecraft:snowy_slopes",
    "minecraft:jagged_peaks",
    "minecraft:frozen_peaks"
  ]
}
```

`is_snowy_plains.json`
```json
{
  "values": [
    "minecraft:snowy_plains"
  ]
}
```

`is_sparse_vegetation.json`
```json
{
  "values": [
    {
      "id": "#c:is_sparse_vegetation/overworld",
      "required": false
    },
    {
      "id": "#c:is_sparse_vegetation/nether",
      "required": false
    },
    {
      "id": "#c:is_sparse_vegetation/end",
      "required": false
    }
  ]
}
```

`is_spooky.json`
```json
{
  "values": [
    "minecraft:dark_forest",
    "minecraft:deep_dark"
  ]
}
```

`is_stony_shores.json`
```json
{
  "values": [
    "minecraft:stony_shore"
  ]
}
```

`is_swamp.json`
```json
{
  "values": [
    "minecraft:mangrove_swamp",
    "minecraft:swamp"
  ]
}
```

`is_taiga.json`
```json
{
  "values": [
    {
      "id": "#minecraft:is_taiga",
      "required": false
    }
  ]
}
```

`is_temperate.json`
```json
{
  "values": [
    "#c:is_temperate/overworld",
    "#c:is_temperate/nether",
    "#c:is_temperate/end"
  ]
}
```

`is_underground.json`
```json
{
  "values": [
    {
      "id": "#c:is_cave",
      "required": false
    }
  ]
}
```

`is_void.json`
```json
{
  "values": [
    "minecraft:the_void"
  ]
}
```

`is_wasteland.json`
```json
{
  "values": []
}
```

`is_wet.json`
```json
{
  "values": [
    "#c:is_wet/overworld",
    "#c:is_wet/nether",
    "#c:is_wet/end"
  ]
}
```

`is_windswept.json`
```json
{
  "values": [
    "minecraft:windswept_hills",
    "minecraft:windswept_gravelly_hills",
    "minecraft:windswept_forest",
    "minecraft:windswept_savanna"
  ]
}
```

`no_default_monsters.json`
```json
{
  "values": [
    "minecraft:mushroom_fields",
    "minecraft:deep_dark"
  ]
}
```

### 📂 `common/src/main/resources/data/c/tags/worldgen/biome/is_cold/`
`end.json`
```json
{
  "values": [
    "minecraft:the_end",
    "minecraft:small_end_islands",
    "minecraft:end_midlands",
    "minecraft:end_highlands",
    "minecraft:end_barrens"
  ]
}
```

`nether.json`
```json
{
  "values": []
}
```

`overworld.json`
```json
{
  "values": [
    "minecraft:taiga",
    "minecraft:old_growth_pine_taiga",
    "minecraft:old_growth_spruce_taiga",
    "minecraft:windswept_hills",
    "minecraft:windswept_gravelly_hills",
    "minecraft:windswept_forest",
    "minecraft:snowy_plains",
    "minecraft:ice_spikes",
    "minecraft:grove",
    "minecraft:snowy_slopes",
    "minecraft:jagged_peaks",
    "minecraft:frozen_peaks",
    "minecraft:stony_shore",
    "minecraft:snowy_beach",
    "minecraft:snowy_taiga",
    "minecraft:frozen_river",
    "minecraft:cold_ocean",
    "minecraft:frozen_ocean",
    "minecraft:deep_cold_ocean",
    "minecraft:deep_frozen_ocean",
    {
      "id": "#c:climate_cold",
      "required": false
    }
  ]
}
```

### 📂 `common/src/main/resources/data/c/tags/worldgen/biome/is_dense_vegetation/`
`end.json`
```json
{
  "values": []
}
```

`nether.json`
```json
{
  "values": []
}
```

`overworld.json`
```json
{
  "values": [
    "minecraft:dark_forest",
    "minecraft:old_growth_birch_forest",
    "minecraft:old_growth_spruce_taiga",
    "minecraft:jungle",
    "minecraft:bamboo_jungle",
    "minecraft:mangrove_swamp",
    {
      "id": "#c:vegetation_dense",
      "required": false
    }
  ]
}
```

### 📂 `common/src/main/resources/data/c/tags/worldgen/biome/is_dry/`
`end.json`
```json
{
  "values": [
    "minecraft:the_end",
    "minecraft:small_end_islands",
    "minecraft:end_midlands",
    "minecraft:end_highlands",
    "minecraft:end_barrens"
  ]
}
```

`nether.json`
```json
{
  "values": [
    "minecraft:nether_wastes",
    "minecraft:crimson_forest",
    "minecraft:warped_forest",
    "minecraft:soul_sand_valley",
    "minecraft:basalt_deltas"
  ]
}
```

`overworld.json`
```json
{
  "values": [
    "minecraft:desert",
    "minecraft:badlands",
    "minecraft:wooded_badlands",
    "minecraft:eroded_badlands",
    "minecraft:savanna",
    "minecraft:savanna_plateau",
    "minecraft:windswept_savanna",
    {
      "id": "#c:climate_dry",
      "required": false
    }
  ]
}
```

### 📂 `common/src/main/resources/data/c/tags/worldgen/biome/is_hot/`
`end.json`
```json
{
  "values": []
}
```

`nether.json`
```json
{
  "values": [
    "minecraft:nether_wastes",
    "minecraft:crimson_forest",
    "minecraft:warped_forest",
    "minecraft:soul_sand_valley",
    "minecraft:basalt_deltas"
  ]
}
```

`overworld.json`
```json
{
  "values": [
    "minecraft:jungle",
    "minecraft:bamboo_jungle",
    "minecraft:sparse_jungle",
    "minecraft:desert",
    "minecraft:badlands",
    "minecraft:wooded_badlands",
    "minecraft:eroded_badlands",
    "minecraft:savanna",
    "minecraft:savanna_plateau",
    "minecraft:windswept_savanna",
    "minecraft:stony_peaks",
    "minecraft:mushroom_fields",
    "minecraft:warm_ocean",
    {
      "id": "#c:climate_hot",
      "required": false
    }
  ]
}
```

### 📂 `common/src/main/resources/data/c/tags/worldgen/biome/is_mountain/`
`peak.json`
```json
{
  "values": [
    "minecraft:frozen_peaks",
    "minecraft:jagged_peaks",
    "minecraft:stony_peaks",
    {
      "id": "#c:mountain_peak",
      "required": false
    }
  ]
}
```

`slope.json`
```json
{
  "values": [
    "minecraft:snowy_slopes",
    "minecraft:meadow",
    "minecraft:grove",
    "minecraft:cherry_grove",
    {
      "id": "#c:mountain_slope",
      "required": false
    }
  ]
}
```

### 📂 `common/src/main/resources/data/c/tags/worldgen/biome/is_sparse_vegetation/`
`end.json`
```json
{
  "values": []
}
```

`nether.json`
```json
{
  "values": []
}
```

`overworld.json`
```json
{
  "values": [
    "minecraft:wooded_badlands",
    "minecraft:savanna",
    "minecraft:savanna_plateau",
    "minecraft:sparse_jungle",
    "minecraft:windswept_savanna",
    "minecraft:windswept_forest",
    "minecraft:windswept_hills",
    "minecraft:windswept_gravelly_hills",
    "minecraft:snowy_slopes",
    "minecraft:jagged_peaks",
    "minecraft:frozen_peaks",
    {
      "id": "#c:vegetation_sparse",
      "required": false
    }
  ]
}
```

### 📂 `common/src/main/resources/data/c/tags/worldgen/biome/is_temperate/`
`end.json`
```json
{
  "values": []
}
```

`nether.json`
```json
{
  "values": []
}
```

`overworld.json`
```json
{
  "values": [
    "minecraft:plains",
    "minecraft:sunflower_plains",
    "minecraft:forest",
    "minecraft:flower_forest",
    "minecraft:birch_forest",
    "minecraft:old_growth_birch_forest",
    "minecraft:dark_forest",
    "minecraft:cherry_grove",
    "minecraft:meadow",
    "minecraft:swamp",
    "minecraft:mangrove_swamp",
    "minecraft:beach",
    "minecraft:ocean",
    "minecraft:deep_ocean",
    {
      "id": "#c:climate_temperate",
      "required": false
    }
  ]
}
```

### 📂 `common/src/main/resources/data/c/tags/worldgen/biome/is_tree/`
`coniferous.json`
```json
{
  "values": [
    {
      "id": "#c:is_taiga",
      "required": false
    },
    "minecraft:grove",
    {
      "id": "#c:tree_coniferous",
      "required": false
    }
  ]
}
```

`deciduous.json`
```json
{
  "values": [
    "minecraft:forest",
    "minecraft:windswept_forest",
    "minecraft:flower_forest",
    "minecraft:birch_forest",
    "minecraft:dark_forest",
    "minecraft:old_growth_birch_forest",
    {
      "id": "#c:tree_deciduous",
      "required": false
    }
  ]
}
```

`jungle.json`
```json
{
  "values": [
    {
      "id": "#c:is_jungle",
      "required": false
    },
    {
      "id": "#c:tree_jungle",
      "required": false
    }
  ]
}
```

`savanna.json`
```json
{
  "values": [
    {
      "id": "#c:is_savanna",
      "required": false
    },
    {
      "id": "#c:tree_savanna",
      "required": false
    }
  ]
}
```

### 📂 `common/src/main/resources/data/c/tags/worldgen/biome/is_wet/`
`end.json`
```json
{
  "values": []
}
```

`nether.json`
```json
{
  "values": []
}
```

`overworld.json`
```json
{
  "values": [
    "minecraft:swamp",
    "minecraft:mangrove_swamp",
    "minecraft:jungle",
    "minecraft:bamboo_jungle",
    "minecraft:sparse_jungle",
    "minecraft:beach",
    "minecraft:lush_caves",
    "minecraft:dripstone_caves",
    {
      "id": "#c:climate_wet",
      "required": false
    }
  ]
}
```

### 📂 `common/src/main/resources/assets/adorablehamsterpets/lang/`
`en_us_base.json`
The entire contents of this file are copied into `en_us.json` during the data generation process by `EnUsGenerator.java`. Therefore, the generated `en_us.json` file is `.gitignore`d and is not included in this tech spec to avoid redundancy.
```json
{
  "item.adorablehamsterpets.cucumber": "Cucumber",
  "item.adorablehamsterpets.cucumber_seeds": "Cucumber Seeds",
  "item.adorablehamsterpets.cucumber_crop": "Cucumber Crop",
  "item.adorablehamsterpets.sliced_cucumber": "Sliced Cucumber",
  "item.adorablehamsterpets.green_beans": "Green Beans",
  "item.adorablehamsterpets.green_bean_crop": "Green Bean Crop",
  "item.adorablehamsterpets.green_bean_seeds": "Green Bean Seeds",
  "item.adorablehamsterpets.steamed_green_beans": "Steamed Green Beans",
  "item.adorablehamsterpets.sunflower_seeds": "Sunflower Seeds",
  "item.adorablehamsterpets.cheese": "§6Cheese§",
  "item.adorablehamsterpets.hamster_food_mix": "Hamster Food Mix",
  "item.adorablehamsterpets.hamster_spawn_egg": "Hamster Spawn Egg",
  "item.adorablehamsterpets.announcement_bell_icon": "Announcement Bell",
  "item.adorablehamsterpets.hamster_guide_book": "§f§lHamster Tips:§r§6§o Guidebook to the Tiny, Furry Heart§r",
  "item.adorablehamsterpets.hamster_bedding": "Hamster Bedding",
  "item.adorablehamsterpets.upside_down_hamster_bed_icon": "Upside-Down Hamster Bed Icon",
  "item.adorablehamsterpets.hamster_bed_oak": "Oak Hamster Bed",
  "item.adorablehamsterpets.hamster_bed_spruce": "Spruce Hamster Bed",
  "item.adorablehamsterpets.hamster_bed_birch": "Birch Hamster Bed",
  "item.adorablehamsterpets.hamster_bed_jungle": "Jungle Hamster Bed",
  "item.adorablehamsterpets.hamster_bed_acacia": "Acacia Hamster Bed",
  "item.adorablehamsterpets.hamster_bed_dark_oak": "Dark Oak Hamster Bed",
  "item.adorablehamsterpets.hamster_bed_mangrove": "Mangrove Hamster Bed",
  "item.adorablehamsterpets.hamster_bed_cherry": "Cherry Hamster Bed",
  "item.adorablehamsterpets.hamster_bed_bamboo": "Bamboo Hamster Bed",
  "item.adorablehamsterpets.hamster_bed_pale_oak": "Pale Oak Hamster Bed",

  "itemgroup.adorablehamsterpets.main": "Adorable Hamster Pets",

  "entity.adorablehamsterpets.hamster": "Hamster",
  "entity.adorablehamsterpets.hampter": "Hampter",
  "entity.adorablehamsterpets.hamster.inventory_title": "Hamster Inventory",
  "entity.adorablehamsterpets.hamster.inventory_left_cheek_title": "Left Cheek",
  "entity.adorablehamsterpets.hamster.inventory_right_cheek_title": "Right Cheek",

  "block.adorablehamsterpets.wild_green_bean_bush": "Wild Green Bean Bush",
  "block.adorablehamsterpets.wild_cucumber_bush": "Wild Cucumber Bush",
  "block.adorablehamsterpets.sunflower_block": "Sunflower",
  "block.adorablehamsterpets.wild_green_bean_bush.hint1": "Yields seeds. Seeds for... enhancement of certain small mammals.",
  "block.adorablehamsterpets.wild_green_bean_bush.hint2": "Right-click. Maybe. If it's ready.",
  "block.adorablehamsterpets.wild_cucumber_bush.hint1": "Drops seeds. Seeds that might help you make small friends.",
  "block.adorablehamsterpets.wild_cucumber_bush.hint2": "Interact with it. Gently. It's sensitive.",
  "block.adorablehamsterpets.sunflower_block.hint1": "Sometimes yields seeds... key recipe ingredients?",
  "block.adorablehamsterpets.sunflower_block.hint2": "Requires time to replenish its seedy bounty.",
  "block.adorablehamsterpets.hamster_bed": "Hamster Bed",

  "gui.adorablehamsterpets.announcement.button.mark_as_read": "Mark As Read",
  "gui.adorablehamsterpets.announcement.button.mark_as_read.tooltip": "Clicking here banishes this specific message to the digital ether and marks it 'read' in your §f§lHamster Tips§r guide book. (Can be undone from the config when you get FOMO).",
  "gui.adorablehamsterpets.announcement.button.mark_as_read.shift_tooltip": "Hold Shift to mark ALL pending announcements as read. For when you just can't be bothered.",
  "gui.adorablehamsterpets.announcement.button.disable_icons": "Disable All",
  "gui.adorablehamsterpets.announcement.button.disable_icons.tooltip": "Click here to enter a blissful state of ignorance. The announcement bell icon, disabled forever. To re-enable, go to: Config > Announcements > Enable Notifications. Announcements can still be viewed in the §f§lHamster Tips§r guide book.",
  "gui.adorablehamsterpets.announcement.button.snooze_days": "Snooze (Days)",
  "gui.adorablehamsterpets.announcement.button.snooze_days.tooltip": "Ah, procrastination. My old friend. Click here to nudge yourself again about this update in %s days. Maybe you'll care by then. You can also change the number of days in the config.",
  "gui.adorablehamsterpets.announcement.button.snooze_session": "Snooze (Session)",
  "gui.adorablehamsterpets.announcement.button.snooze_session.tooltip": "Hides all announcement notifications until you restart the game.",
  "gui.adorablehamsterpets.announcement.button.changelog": "See Changelog",
  "gui.adorablehamsterpets.announcement.button.changelog.tooltip": "Opens the full changelog on Modrinth in your browser. It's really quite exciting. I love changelogs. (No sarcasm)",
  "gui.adorablehamsterpets.announcement.button.discord": "Join Discord",
  "gui.adorablehamsterpets.announcement.button.close.tooltip": "Just peeking? This closes the window without doing anything.",

  "tooltip.adorablehamsterpets.hamster_guide_book.hint": "Can be crafted with Sliced Cucumber and a Book.",
  "tooltip.adorablehamsterpets.green_bean_seeds.hint1": "Plant these to grow beans. Beans that empower...",
  "tooltip.adorablehamsterpets.green_bean_seeds.hint2": "Requires commitment. And maybe some dirt.",
  "tooltip.adorablehamsterpets.cucumber_seeds.hint1": "Grow cucumbers. Cucumbers that might... persuade?",
  "tooltip.adorablehamsterpets.cucumber_seeds.hint2": "Just add water, soil, and existential dread.",
  "tooltip.adorablehamsterpets.sunflower_seeds.hint1": "Apparently important for certain food mixes.",
  "tooltip.adorablehamsterpets.sunflower_seeds.hint2": "Can also be used as a basic snack.",
  "tooltip.adorablehamsterpets.cucumber.hint1": "Crunchy. Refreshing. Potentially influential.",
  "tooltip.adorablehamsterpets.cucumber.hint2": "Try preparing it at a crafting table...",
  "tooltip.adorablehamsterpets.sliced_cucumber.hint1": "The key to a tiny, furry heart. Or at least, their attention.",
  "tooltip.adorablehamsterpets.sliced_cucumber.hint2": "A gentle, sneaky approach might be required.",
  "tooltip.adorablehamsterpets.green_beans.hint1": "A simple veggie. Can be cooked for... interesting results.",
  "tooltip.adorablehamsterpets.green_beans.hint2": "Eat them raw if you enjoy disappointment.",
  "tooltip.adorablehamsterpets.steamed_green_beans.hint1": "Gives hamsters a sudden burst of... enthusiasm?",
  "tooltip.adorablehamsterpets.steamed_green_beans.hint2": "The effect isn't permanent. Nothing ever is, except taxes.",
  "tooltip.adorablehamsterpets.hamster_food_mix.hint1": "So good, even the pickiest hamster can't refuse.",
  "tooltip.adorablehamsterpets.hamster_food_mix.hint2": "Use it when they're being difficult. Or just hungry.",
  "tooltip.adorablehamsterpets.cheese.hint1": "A culinary masterpiece. Irresistible to small, furry opportunists.",
  "tooltip.adorablehamsterpets.cheese.hint2": "Wave it around in front of a hamster and see what happens.",
  "tooltip.adorablehamsterpets.cheese.hint3": "Restores %s hunger and %s saturation (configurable).",
  "tooltip.adorablehamsterpets.cheese.appleskin_warning": "This old version's AppleSkin HUD can't handle my dynamic stats, so if you changed the config, the HUD is just... aspirational.",
  "tooltip.adorablehamsterpets.hud.update_available_announcement": "New update available: v%s",
  "tooltip.adorablehamsterpets.hud.regular_announcement": "New announcement available!",
  "tooltip.adorablehamsterpets.hud.whats_new": "What's new in v%s",
  "tooltip.adorablehamsterpets.hud.snooze_remaining": "Snoozed for: %s",
  "tooltip.adorablehamsterpets.hamster_bedding.hint1": "It's a pile of leaves, but let's call it... 'Bespoke Nesting Material.'",
  "tooltip.adorablehamsterpets.hamster_bedding.hint2": "Combine with wood planks to create a slightly more organized pile of leaves. Rodents love the stuff.",
  "tooltip.adorablehamsterpets.hamster_bedding.hint3": "Or if you're feeling cute, try waving it around or putting it in a dispenser to create a 'fall' atmosphere.",
  "tooltip.adorablehamsterpets.hamster_bed.description1": "A premium pile of leaves in a cozy wooden box. Right-click a tamed hamster to claim it.",
  "tooltip.adorablehamsterpets.hamster_bed.description2": "Place in the world after linking to set a wandering anchor point.",
  "tooltip.adorablehamsterpets.hamster_bed.linked_to": "Linked to: %s",
  "tooltip.adorablehamsterpets.hamster_bed.wander_distance": "Wander Distance: %s (%s blocks)",
  "tooltip.adorablehamsterpets.jade.wander_mode": "Wander Mode: %s",
  "tooltip.adorablehamsterpets.jade.unlinked": "Unlinked. Right-click a hamster with this bed in hand to link.",
  "tooltip.adorablehamsterpets.jade.wander_status": "Wander: %s (%s, %s blocks)",
  "tooltip.adorablehamsterpets.jade.sleep_status": "Can sleep in Bed: %s",
  "tooltip.adorablehamsterpets.jade.wander_controls": "§aRight-click§r to toggle, §aSneak + right-click§r to cycle.",
  "tooltip.adorablehamsterpets.jade.lure_hint": "§aRight-click§r with §6§lCheese§r to lure to bed.",
  "tooltip.adorablehamsterpets.jade.repellent_hint": "§aRight-click§r with §c§lRotten Flesh§r to prevent sleeping.",
  "tooltip.adorablehamsterpets.jade.unlink_hint": "§aSneak + Right-click§r with §c§lRotten Flesh§r to unlink.",
  "tooltip.adorablehamsterpets.shift_for_info": "Hold §lShift§r for more info.",
  "tooltip.adorablehamsterpets.sneak_for_info": "§lSneak§r for more info.",

  "key.categories.adorablehamsterpets.main": "Adorable Hamster Pets",
  "key.adorablehamsterpets.throw_hamster": "Throw Hamster",
  "key.adorablehamsterpets.dismount_hamster": "Dismount Hamster",
  "key.adorablehamsterpets.dismount_hamster.disabled": "(Currently Inactive - See Config)",
  "key.adorablehamsterpets.force_mount_hamster": "Force Shoulder Mount",
  "key.adorablehamsterpets.force_mount_hamster.disabled": "(Currently Inactive - See Config)",

  "message.adorablehamsterpets.throw_cooldown": "Your hamster needs a break— try again in %d minute and %d seconds.",
  "message.adorablehamsterpets.baby_throw_refusal": "Your baby hamster clings tightly, refusing to become a furry cannonball. Perhaps wait until it's older?",
  "message.adorablehamsterpets.beans_cooldown": "Your hamster hasn't calmed down enough from last time yet. (%d min %d sec left).",
  "message.adorablehamsterpets.creeper_detected": "Your hamster senses a creeper approaching!",
  "message.adorablehamsterpets.diamond_nearby": "Your hamster smells diamond ore nearby.",
  "message.adorablehamsterpets.sweet_potato_secret": "Sweet Potato? An inspired name. Very well.",
  "message.adorablehamsterpets.dismount.1": "Hamster dismounted. Back to business.",
  "message.adorablehamsterpets.dismount.2": "Your furry co-pilot has touched down.",
  "message.adorablehamsterpets.dismount.3": "Shoulder vacant. The hamster has other plans.",
  "message.adorablehamsterpets.dismount.4": "Hamster deployed. Or it just fancied a walk.",
  "message.adorablehamsterpets.dismount.5": "One less passenger. Your hamster is now free-range.",
  "message.adorablehamsterpets.dismount.6": "The hamster returns to terrestrial navigation.",
  "message.adorablehamsterpets.cheek_pouch_locked": "This hamster's cheek pouches are currently shy. A gourmet meal might change its mind...",
  "message.adorablehamsterpets.debug_overlay_enabled": "Debug Hamster Overlay: ENABLED",
  "message.adorablehamsterpets.debug_overlay_disabled": "Debug Hamster Overlay: DISABLED",
  "message.adorablehamsterpets.found_gold_mistake.1": "Your hamster has located what is technically a valuable mineral. Just not the one it was hoping for. Awkward.",
  "message.adorablehamsterpets.found_gold_mistake.2": "Your hamster proudly presents... gold. It gets a participation trophy for effort.",
  "message.adorablehamsterpets.found_gold_mistake.3": "With unwavering confidence, your hamster has located something shiny. It's just... the wrong shiny.",
  "message.adorablehamsterpets.found_gold_mistake.4": "There's a moment of dawning horror as your hamster realizes this is not, in fact, diamond.",
  "message.adorablehamsterpets.found_gold_mistake.5": "Well... it §ois§r treasure... technically. Your hamster, however, seems to disagree with this assessment.",
  "message.adorablehamsterpets.found_gold_mistake.6": "The epic quest for riches concludes with... gold. Your hamster has begun to contemplate its life choices.",
  "message.adorablehamsterpets.found_gold_mistake.7": "So close, and yet so... gold. The disappointment is palpable.",
  "message.adorablehamsterpets.throwing_disabled": "Hamster throwing is disabled in config.",
  "message.adorablehamsterpets.shoulder_mount_success": "Your hamster scurries onto your shoulder!",
  "message.adorablehamsterpets.shoulder_occupied": "Your shoulder is already occupied!",
  "message.adorablehamsterpets.food_refusal": "Hamster wants to try something different.",
  "message.adorablehamsterpets.announcements_reset": "Announcement 'read' history has been reset.",
  "message.adorablehamsterpets.announcements_marked_read": "All announcements have been marked as read.",
  "message.adorablehamsterpets.bed_linked": "Hamster Bed linked to %s!",
  "message.adorablehamsterpets.wander_distance_set": "Wander distance for %s set to: %s",
  "message.adorablehamsterpets.wander_mode_set": "Wander Mode for %s: %s",
  "message.adorablehamsterpets.bed_broken": "Your hamster's bed was broken. It is now, once again, entirely your problem.",
  "message.adorablehamsterpets.lure_to_bed_success": "%s smells something splendid in their bed and decided it's time for a nap.",
  "message.adorablehamsterpets.lure_to_bed_fail": "Your hamster is already sitting or sleeping and cannot be lured to bed.",
  "message.adorablehamsterpets.bed_repellent_applied": "This bed now smells vaguely of despair. Your hamster will avoid sleeping in it.",
  "message.adorablehamsterpets.bed_repellent_removed": "The foul smell has been overcome by a moldy dairy product. Your hamster will now consider sleeping here again.",
  "message.adorablehamsterpets.bed_unlinked": "Hamster Bed unlinked from %s.",
  "message.adorablehamsterpets.bed_upside_down_lure_fail": "Your hamster can't sleep on the ceiling. Time to take a break from whatever you've been smoking.",
  "message.adorablehamsterpets.guidebook_rediscovered": "A wealth of hamster knowledge, rediscovered.",

  "subtitles.adorablehamsterpets.hamster_attack": "Hamster attacks",
  "subtitles.adorablehamsterpets.hamster_beg": "Hamster begs",
  "subtitles.adorablehamsterpets.hamster_death": "Hamster dies",
  "subtitles.adorablehamsterpets.hamster_hurt": "Hamster hurts",
  "subtitles.adorablehamsterpets.hamster_idle": "Hamster squeaks",
  "subtitles.adorablehamsterpets.hamster_sleep": "Hamster sleeps",
  "subtitles.adorablehamsterpets.hamster_sniff": "Hamster sniffs",
  "subtitles.adorablehamsterpets.hamster_creeper_detect": "Hamster alerts",
  "subtitles.adorablehamsterpets.hamster_celebrate": "Hamster celebrates",
  "subtitles.adorablehamsterpets.hamster_throw": "Hamster Thrown",
  "subtitles.adorablehamsterpets.hamster_impact": "Hamster Impacts",
  "subtitles.adorablehamsterpets.hamster_flying": "Hamster Squeaks (Airborne)",
  "subtitles.adorablehamsterpets.hamster_wake_up": "Hamster wakes up",
  "subtitles.adorablehamsterpets.cheese_use": "Cheese rustles",
  "subtitles.adorablehamsterpets.cheese_eat": "Player eats cheese",
  "subtitles.adorablehamsterpets.hamster_mount": "Hamster mounts shoulder",
  "subtitles.adorablehamsterpets.hamster_dismount": "Hamster dismounts",
  "subtitles.adorablehamsterpets.hamster_bounce": "Hamster bounces",
  "subtitles.adorablehamsterpets.hamster_scratch": "Hamster scratches",
  "subtitles.adorablehamsterpets.alarm_orchestra_hit": "Dramatic sound",
  "subtitles.adorablehamsterpets.hamster_affection": "Hamster coos",
  "subtitles.adorablehamsterpets.diamond_sparkle": "Diamond sparkles",
  "subtitles.adorablehamsterpets.diamond_pounce": "Hamster pounces on item",
  "subtitles.adorablehamsterpets.food_pounce": "Hamster pounces on food",
  "subtitles.adorablehamsterpets.generic_pounce": "Hamster pounces on item",
  "subtitles.adorablehamsterpets.hamster_bed_rustle": "Hamster rustles in leaves",
  "subtitles.adorablehamsterpets.hamster_thump": "Hamster thumps",
  "subtitles.adorablehamsterpets.hamster_swish": "Hamster swishes through the air",
  "subtitles.adorablehamsterpets.gentle_breeze": "Gentle breeze blows",

  "config.jade.plugin_adorablehamsterpets.wild_bush_tooltips": "Wild Bush Tooltip Hints",
  "config.jade.plugin_adorablehamsterpets.hamster_debug_info": "More Hamster Info (For Debugging)",
  "config.jade.plugin_adorablehamsterpets.hamster_bed_info": "Hamster Bed Info",

  "advancements.adorablehamsterpets.husbandry.root.title": "The Hamster Life",
  "advancements.adorablehamsterpets.husbandry.root.description": "Welcome to your new life as a rodent enthusiast. We won't judge.",
  "advancements.adorablehamsterpets.husbandry.craft_bait.title": "The Bait",
  "advancements.adorablehamsterpets.husbandry.craft_bait.description": "Transform a humble cucumber into Sliced Cucumber. Rodents go nuts for it.",
  "advancements.adorablehamsterpets.husbandry.craft_food_mix.title": "Pocket Snacks",
  "advancements.adorablehamsterpets.husbandry.craft_food_mix.description": "Whip up some Hamster Food Mix. This is a great opportunity to say 'peckish.' What a fun word.",
  "advancements.adorablehamsterpets.husbandry.seed_money.title": "Seed Money",
  "advancements.adorablehamsterpets.husbandry.seed_money.description": "Acquire Cucumber Seeds. The first step to gaining a tiny, squeaky companion.",
  "advancements.adorablehamsterpets.husbandry.tame_hamster.title": "A Furry Shadow",
  "advancements.adorablehamsterpets.husbandry.tame_hamster.description": "Successfully domesticate a wild hamster. May your ankles be ever safe.",
  "advancements.adorablehamsterpets.husbandry.sunflower_hoarder.title": "Sunflower Hoarder",
  "advancements.adorablehamsterpets.husbandry.sunflower_hoarder.description": "Gather Sunflower Seeds. They look innocent, but they're part of a larger, fluffier scheme.",
  "advancements.adorablehamsterpets.husbandry.cheeky_storage.title": "A Trustworthy Face",
  "advancements.adorablehamsterpets.husbandry.cheeky_storage.description": "That special Food Mix did the trick! Your hamster now deems you worthy of its cheek-based cargo services.",
  "advancements.adorablehamsterpets.husbandry.shoulder_hamster.title": "Shoulder Surfer",
  "advancements.adorablehamsterpets.husbandry.shoulder_hamster.description": "Convince a hamster that your shoulder is prime real estate. Hint: Cheese helps.",
  "advancements.adorablehamsterpets.husbandry.throw_hamster.title": "The Hamster Yeet™",
  "advancements.adorablehamsterpets.husbandry.throw_hamster.description": "Unleash your shoulder trebuchet. Bonus points for direct Creeper hits. (No hamsters were *terminally harmed in the making of this feature.)",
  "advancements.adorablehamsterpets.husbandry.green_bean_gardener.title": "Green Bean Gardener",
  "advancements.adorablehamsterpets.husbandry.green_bean_gardener.description": "Procure Green Bean Seeds. These aren't your average beans.",
  "advancements.adorablehamsterpets.husbandry.steamy_greens.title": "Steamy Greens",
  "advancements.adorablehamsterpets.husbandry.steamy_greens.description": "Cook up some Green Beans. They smell... suspiciously energizing.",
  "advancements.adorablehamsterpets.husbandry.supercharged_squeaker.title": "Supercharged Squeaker",
  "advancements.adorablehamsterpets.husbandry.supercharged_squeaker.description": "Feed your hamster Steamed Green Beans and witness a temporary burst of... ambition.",
  "advancements.adorablehamsterpets.technical.crafted_guide_book.title": "The Sacred Texts",
  "advancements.adorablehamsterpets.technical.crafted_guide_book.description": "You've crafted the sacred texts of hamster lore. Well done.",
  "advancements.adorablehamsterpets.husbandry.petal_pusher.title": "Petal Pusher",
  "advancements.adorablehamsterpets.husbandry.petal_pusher.description": "You've subjected your hamster to floral... decor. Um, good job? Should you regret this aesthetic choice, a pair of shears might be key.",
  "advancements.adorablehamsterpets.husbandry.pocket_paramedic.title": "Pocket Paramedic",
  "advancements.adorablehamsterpets.husbandry.pocket_paramedic.description": "Your hamster, displaying remarkable self-preservation, raided its own cheek stash. Clever, or just really hungry?",
  "advancements.adorablehamsterpets.husbandry.nose_for_treasure.title": "Nose for Treasure",
  "advancements.adorablehamsterpets.husbandry.nose_for_treasure.description": "Your shoulder-mounted alarm system just detected... something shiny. Or possibly just lint. Good luck.",
  "advancements.adorablehamsterpets.husbandry.impending_doom_squeak.title": "Impending Doom Squeak",
  "advancements.adorablehamsterpets.husbandry.impending_doom_squeak.description": "That high-pitched noise wasn't your tinnitus. Your hamster thinks a Creeper fancies you. Run. Or don't. Your funeral.",
  "advancements.adorablehamsterpets.husbandry.chipmunk_aspirations.title": "Chipmunk Aspirations",
  "advancements.adorablehamsterpets.husbandry.chipmunk_aspirations.description": "Those cheeks are at maximum capacity. Your hamster is either preparing for the apocalypse or just really, really likes snacks.",
  "advancements.adorablehamsterpets.recipes.hamster_guide_book.title": "Guidebook Knowledge",
  "advancements.adorablehamsterpets.recipes.hamster_guide_book.description": "Learned how to craft the Hamster Guide Book.",
  "advancements.adorablehamsterpets.husbandry.canine_aspirations.title": "Canine Aspirations?",
  "advancements.adorablehamsterpets.husbandry.canine_aspirations.description": "Your hamster successfully sniffed out diamonds! Wow! This mod is amazing!",
  "advancements.adorablehamsterpets.husbandry.craft_hamster_bed.title": "Luxury Leaf Pile",
  "advancements.adorablehamsterpets.husbandry.craft_hamster_bed.description": "You've successfully assembled a slightly more organized pile of leaves. It's basically a five-star rodent resort.",
  "advancements.adorablehamsterpets.husbandry.craft_all_hamster_beds.title": "Leaf Bender Supreme",
  "advancements.adorablehamsterpets.husbandry.craft_all_hamster_beds.description": "A complete portfolio of hamster beds. Your hamster now has better housing options than most villagers. You've peaked.",
  "advancements.adorablehamsterpets.husbandry.hamster_bed_linked.title": "Home is Where the Leaves Are",
  "advancements.adorablehamsterpets.husbandry.hamster_bed_linked.description": "You've officially claimed a pile of leaves for your hamster. It's like a tiny, leafy mortgage.",
  "advancements.adorablehamsterpets.husbandry.hamster_slept_in_bed.title": "Sweet Dreams 'r Made of Leaves",
  "advancements.adorablehamsterpets.husbandry.hamster_slept_in_bed.description": "Your hamster has successfully navigated to its bed and passed out. A truly monumental achievement.",
  "advancements.adorablehamsterpets.husbandry.craft_hamster_bedding.title": "Artisanal Floor Mulch",
  "advancements.adorablehamsterpets.husbandry.craft_hamster_bedding.description": "You've successfully combined leaves, mulch, and some twigs. Your hamster will be thrilled. Or they might eat it. 50/50, really.",
  "advancements.adorablehamsterpets.husbandry.used_hamster_bedding.title": "Interior Desecrator",
  "advancements.adorablehamsterpets.husbandry.used_hamster_bedding.description": "You've discovered that hamster bedding doubles as a portable, eco-friendly confetti cannon. Your janitor will not be amused.",
  "advancements.adorablehamsterpets.husbandry.dispensed_hamster_bedding.title": "High-Tech Allergy Attack",
  "advancements.adorablehamsterpets.husbandry.dispensed_hamster_bedding.description": "You've automated the process of making a mess. Your commitment to laziness is noted and, frankly, respected.",
  "advancements.adorablehamsterpets.husbandry.placed_bed_upside_down.title": "Australian Feng Shui",
  "advancements.adorablehamsterpets.husbandry.placed_bed_upside_down.description": "You looked at a perfectly functional hamster bed and thought, 'Needs more... inversion.' A bold choice. Questionable, but bold.",

  "config.adorablehamsterpets.main.helpAndResources": "Help & Other Distractions",
  "config.adorablehamsterpets.main.helpAndResources.desc": "Buttons to press when you're lost, bored, or have found a bug that isn't just a hamster exhibiting existential angst.",
  "config.adorablehamsterpets.main.helpAndResources.giveGuideBook": "I Lost My Book!",
  "config.adorablehamsterpets.main.helpAndResources.giveGuideBook.desc": "Misplaced your invaluable tome of rodent wisdom? Click here. I won't tell anyone.",
  "config.adorablehamsterpets.main.helpAndResources.reportBug": "Report a Bug",
  "config.adorablehamsterpets.main.helpAndResources.reportBug.desc": "Found a game-breaking issue? Or a hamster phasing through the floor? Let me know on Github. The more details, the better. And believe it or not, I do check this frequently.",
  "config.adorablehamsterpets.main.helpAndResources.visitWebsite": "Visit My Website",
  "config.adorablehamsterpets.main.helpAndResources.visitWebsite.desc": "Shameless plug for my other, less-rodent-focused work. Click if you dare.",
  "config.adorablehamsterpets.main.helpAndResources.joinDiscord": "Join Discord",
  "config.adorablehamsterpets.main.helpAndResources.joinDiscord.desc": "Join 'The Cheek Pouch' Discord server to share your hamster experiences, get support, hear the latest development squeaks from yours truly, or just chat your heart out. Everyone is welcome!",
  "config.adorablehamsterpets.main.announcements.resetAllAnnouncementDismissals": "Reset All",
  "config.adorablehamsterpets.main.announcements.resetAllAnnouncementDismissals.desc": "FORGET EVERYTHING. This marks all announcements and update notes as unread, making them reappear. Useful for testing or if you just really, really miss that little notification bell.",
  "config.adorablehamsterpets.main.announcements.reEnableAnnouncements": "Re-Enable",
  "config.adorablehamsterpets.main.announcements.reEnableAnnouncements.desc": "If you previously told me to stop sending announcements but now you miss the drama, click this to hear the tea again.",
  "config.adorablehamsterpets.main.announcements.markAllAsRead": "Mark All as Read",
  "config.adorablehamsterpets.main.announcements.markAllAsRead.desc": "Instantly marks all current and past announcements as 'read,' clearing them from your notification icon. This is a one-way trip unless you reset your history.",
  "config.adorablehamsterpets.enum.icon_position.top_left": "Top Left",
  "config.adorablehamsterpets.enum.icon_position.top_right": "Top Right",
  "config.adorablehamsterpets.enum.icon_position.bottom_left": "Bottom Left",
  "config.adorablehamsterpets.enum.icon_position.bottom_right": "Bottom Right",
  "config.adorablehamsterpets.enum.wander_distance.near": "Near",
  "config.adorablehamsterpets.enum.wander_distance.medium": "Medium",
  "config.adorablehamsterpets.enum.wander_distance.far": "Far",
  "config.adorablehamsterpets.enum.dismount_order.lifo": "Last-In, First-Out (LIFO)",
  "config.adorablehamsterpets.enum.dismount_order.fifo": "First-In, First-Out (FIFO)",
  "config.adorablehamsterpets.enum.dismount_trigger_type.sneak_key": "Sneak Key",
  "config.adorablehamsterpets.enum.dismount_trigger_type.custom_keybind": "Custom Keybind",
  "config.adorablehamsterpets.enum.dismount_press_type.single_press": "Single Press",
  "config.adorablehamsterpets.enum.dismount_press_type.double_tap": "Double Tap",
  "config.adorablehamsterpets.enum.forced_shoulder_state.always_stand": "Always Stand",
  "config.adorablehamsterpets.enum.forced_shoulder_state.always_sit": "Always Sit",
  "config.adorablehamsterpets.enum.forced_shoulder_state.always_lay_down": "Always Lay Down",
  "config.adorablehamsterpets.condition.hud_icon_enabled": "Only available when 'Enable HUD Icon' is TRUE.",
  "config.adorablehamsterpets.condition.widget_icon_enabled": "Only available when 'Enable GUI Widget Icon' is TRUE.",
  "config.adorablehamsterpets.condition.dynamic_drift_off": "Only available when 'Dynamic Leaf Drift' is FALSE.",
  "config.adorablehamsterpets.condition.sleep_in_bed_allowed": "Only available when 'Allow Sleeping in Bed' is TRUE.",
  "config.adorablehamsterpets.condition.circadian_chaos_on": "Only available when 'Enable Circadian Chaos' is TRUE.",
  "config.adorablehamsterpets.condition.circadian_chaos_overrides": "Overridden by 'Enable Circadian Chaos' or disabled by 'Allow Sleeping in Bed'.",
  "config.adorablehamsterpets.condition.double_tap": "Only available when Button-Press Behavior is set to 'Double Tap'.",
  "config.adorablehamsterpets.condition.dynamic_shoulder_off": "Only available when 'Enable Dynamic Shoulder Animations' is FALSE.",

  "book.adorablehamsterpets.hamster_guide_book.title": "§f§lHamster Tips§r",
  "book.adorablehamsterpets.hamster_guide_book.subtitle": "§6§o Guidebook to the Tiny, Furry Heart§r",
  "book.adorablehamsterpets.category.landing_page.desc": "$(br)So, you want hamsters?$(br2)An admirable, if slightly predictable, goal.$(br2)This guide contains dubious wisdom gleaned from watching small rodents. Use at your own risk.",
  "book.adorablehamsterpets.category.the_hamster_life": "§r§6§l§nThe Hamster Life§r",
  "book.adorablehamsterpets.category.the_hamster_life.desc": "So you've decided you need more squeaking in your life. <i>Excellent.</>$(br2)This chapter covers the essentials— finding them in the wild, the art of the vegetable bribe, and the finer points of convincing them to stay put.",
    "book.adorablehamsterpets.entry.regional_rodents": "Regional Rodents",
    "book.adorablehamsterpets.entry.regional_rodents.page1.body": "Word on the block is, hamsters adapt. Expect different fur stylings depending on where they originated.$(br2)Some coats are more... <b><i>exclusive</> than others.$(br2)Breeding can sometimes result in new white markings.",
    "book.adorablehamsterpets.entry.regional_rodents.page2.body": "<i><light_gray>The other 69 variants were uncooperative during the shoot.</>",
    "book.adorablehamsterpets.entry.taming": "Taming",
    "book.adorablehamsterpets.entry.taming.page1.header": "Getting Started",
    "book.adorablehamsterpets.entry.taming.page1.body": "First, you need bait.$(br2)The good stuff comes from $(l:crops_food/cucumber)<dark_green><b>Cucumbers</>.$(br2)Find $(l:crops_food/cucumber#bush)<dark_green><b>Wild Cucumber Bushes</> in warmer places — plains, savannas, maybe jungle edges.$(br2)<b>Right-click</> 'em for seeds.",
    "book.adorablehamsterpets.entry.taming.page2.header": "The Taming Tool",
    "book.adorablehamsterpets.entry.taming.page2.body": "Plant those $(l:crops_food/cucumber#crop)<dark_green><b>Cucumber Seeds</> on farmland. Once grown, harvest the $(l:crops_food/cucumber#crop)<dark_green><b>Cucumbers</>.$(br2)Now, the crucial step: craft the cucumber into $(l:crops_food/cucumber#item)<dark_green><b>Sliced Cucumber</>. This is what the little fuzzballs actually I want.",
    "book.adorablehamsterpets.entry.taming.page3.body": "$(br)Right, the actual taming.$(br2)Remember: <b>Sneak</>(<b>$(k:sneak)</>).$(br2)Hold $(l:crops_food/cucumber#item)<dark_green><b>Sliced Cucumber</>.$(br2)Approach slowly. Hope it doesn't notice your desperation.$(br2)Repeat until furry friend acquired.",
    "book.adorablehamsterpets.entry.basic_care": "Basic Care",
    "book.adorablehamsterpets.entry.basic_care.page1.body": "They follow.$(br2)Constantly.$(br2)Right-click your tamed hamster to make it <b>Sit/Stay</>.$(br2)It might doze off. If it does, that's on you. If you die from cuteness overload, that's also on you.",
    "book.adorablehamsterpets.entry.basic_care.page2.body": "$(br)Tired of the constant stalking?$(br2)Craft a $(l:advanced_rodentry/hamster_bed#hamster_bed)<dark_green><b>Hamster Bed</>.$(br2)It has a faint aroma of stale cheese and forest floor debris— basically hamster crack. They'll hang around the bed instead of nipping at your heels. You're welcome.",
    "book.adorablehamsterpets.entry.feeding": "Feeding",
    "book.adorablehamsterpets.entry.feeding.page1.header": "Healing",
    "book.adorablehamsterpets.entry.feeding.page1.body": "If your hamster has had a disagreement with, well, anything— feed it seeds or basic crops to patch it up.$(br2)For serious healing, craft $(l:crops_food/hamster_food_mix)<dark_green><b>Hamster Food Mix</>. It is quite irresistible.",
    "book.adorablehamsterpets.entry.feeding.page2.header": "Breeding",
    "book.adorablehamsterpets.entry.feeding.page2.body": "If its healthy, the same basic food might trigger... <b>Love Mode</>.$(br2)Find another hamster also in Love Mode.$(br2)Stand back. Nature happens.",
    "book.adorablehamsterpets.entry.feeding.page3.header": "Pickiness",
    "book.adorablehamsterpets.entry.feeding.page3.body": "Do not feed it the same mundane food twice in a row. It has standards. It will refuse.$(br2)Exceptions: $(l:crops_food/hamster_food_mix)<dark_green><b>Hamster Food Mix</> (gourmet stuff) and $(l:crops_food/green_beans#item)<dark_green><b>Steamed Green Beans</>.",
    "book.adorablehamsterpets.entry.feeding.page4.header": "Zoomies",
    "book.adorablehamsterpets.entry.feeding.page4.body": "Those $(l:crops_food/green_beans#item)<dark_green><b>Steamed Green Beans</>? Just smelt some regular Green Beans. They grant Speed, Strength, Absorption & Regen for a bit. Impressive!$(br2)...But there is a cooldown before it works again. Less impressive.",
  "book.adorablehamsterpets.category.accessories": "§r§6§l§nHamster Accessories§r",
  "book.adorablehamsterpets.category.accessories.desc": "To cure your hamster's tragic lack of a crippling sense of vanity.$(br2)This section details the latest in rodent runway fashion, from floral decor to... well, that's it for now. But I have many more future plans for accessories!",
    "book.adorablehamsterpets.entry.haute_couture": "Hamster Haute Couture",
    "book.adorablehamsterpets.entry.haute_couture.page1.body": "Stumbled upon some <pink><b>Pink Petals</>? Try <b>right-clicking</> your hamster with them. It's called fashion— look it up.$(br2)Click again to undo your questionable style choices. No refunds on the petals.",
    "book.adorablehamsterpets.entry.haute_couture.page3.body": "The current accessory collection is... sparse.$(br2)But the hamster haberdashery is just getting started!$(br2)I have tons of accessory ideas, due to people being generally awesome.$(br2)Got your own genius idea for the next hamster accessory",
    "book.adorablehamsterpets.entry.haute_couture.page4.body": "that absolutely <i>needs</> to exist?$(br2)Pop over to the official Discord server: $(l:the_kitchen_drawer/join_the_discord)<gold><b><i>The Cheek Pouch</>. Come share screenshots of your cute hamsters! (I can't get enough of those).",
    "book.adorablehamsterpets.entry.haute_couture.page4.link_text": "Join Discord",
  "book.adorablehamsterpets.category.shoulder_hamsters": "§r§6§l§nShoulder Hamsters§r",
  "book.adorablehamsterpets.category.shoulder_hamsters.desc": "Wield $(l:crops_food/cheese)<gold><b>Cheese</> near your tamed companion to have them hop on your shoulder. They might do cool things like alert you to nearby <dark_green><b>Creepers</> that have noticed you, or shiny <dark_aqua><b>Diamonds</>.$(br2)Listen for the unique squeaks and sniffs amongst your own panicked breathing.",    "book.adorablehamsterpets.entry.the_hamster_yeet": "The Hamster Yeet™",
    "book.adorablehamsterpets.entry.the_hamster_yeet.page1.body": "For when words fail and you need a furry, surprisingly aerodynamic solution. Aim (don't stare right at a block), press <b>$(k:adorablehamsterpets.throw_hamster)</>.$(br2)Conveniently, it does exactly enough damage to kill a creeper in one blow. Hamster passes out upon impact. Go console it.",
    "book.adorablehamsterpets.entry.the_hamster_yeet.page2.body": "$(br)Is <b>$(k:adorablehamsterpets.throw_hamster)</> not throwing your hamster?$(br2)Did you add this mod to an existing world? Woopsy.$(br2)Go to: <b>Options > Controls > Key Binds</>. Find <gold><b>\"Throw Hamster,\"</> and set it to <b>G</> (or your preferred key).",
    "book.adorablehamsterpets.entry.creeper_paranoia": "Creeper Paranoia",
    "book.adorablehamsterpets.entry.creeper_paranoia.page1.body": "That panicked squeak? A <b>Creeper</> has targeted YOU. Not just nearby, <red><b><i>\"targeting\"</>.$(br2)Maybe your hamster is worried its comfy shoulder perch is about to vanish.",
    "book.adorablehamsterpets.entry.tiny_prospector": "Tiny Prospector",
    "book.adorablehamsterpets.entry.tiny_prospector.page1.body": "So, your shoulder-mounted companion just alerted you to nearby $(l:advanced_rodentry/subterranean_shinies)<dark_aqua><b>Diamonds</>? Excellent.$(br2)Now for the fun part. Dismount your tiny prospector. If it was indeed onto something shiny, it might just take matters into its own feet.",
    "book.adorablehamsterpets.entry.tiny_prospector.page2.body": "$(br)Watch as it attempts to lead you to the alleged riches.$(br2)But be warned: diamonds smell very similar to... well, um gold, which can be confusing for hamsters. Prepare for tiny drama.",
  "book.adorablehamsterpets.category.advanced_rodentry": "§r§6§l§nAdvanced Rodentry§r",
  "book.adorablehamsterpets.category.advanced_rodentry.desc": "Your hamster can do more than just look adorable and eat your seeds.$(br2)This section covers the weird stuff. You know, the features that make you question the very fabric of blocky reality. If you thought the $(l:shoulder_hamsters/the_hamster_yeet)<dark_green><b>yeeting</> was strange, you're in for a treat.",
    "book.adorablehamsterpets.entry.hamster_bed": "The Great Escape",
    "book.adorablehamsterpets.entry.hamster_bed.page1.body": "For when 'following you into lava' is no longer a desirable trait.$(br2)Craft some $(l:advanced_rodentry/hamster_bed#hamster_bedding)<dark_green><b>Hamster Bedding</> and combine it with wood planks to create a five-star rodent hangout, which serves as an anchor for $(l:advanced_rodentry/hamster_bed#wander_mode)<dark_green><b>Tamed Wander Mode</>.",
    "book.adorablehamsterpets.entry.hamster_bed.page2.header": "Behold, a rare sight.",
    "book.adorablehamsterpets.entry.hamster_bed.page2.body": "A hamster, <i>not</> actively stalking you.",
    "book.adorablehamsterpets.entry.hamster_bed.page3.body": "Here it is: the primary ingredient for the $(l:advanced_rodentry/hamster_bed#hamster_bed)<dark_green><b>Hamster Bed</>.$(br2)It also doubles as a portable, eco-friendly confetti cannon, but you didn't hear that from me.",
    "book.adorablehamsterpets.entry.hamster_bed.page4.body": "You'll need to combine:$(br)1. The finest debris the forest has to offer.$(br)2. Some twigs.$(br2)The result: incredible artisanal floor mulch.",
    "book.adorablehamsterpets.entry.hamster_bed.page5.body": "Ahh yes. The hamster bed.$(br2)It can be spiritually, emotionally, and digitally bonded to a single hamster.$(br2)The link can also be undone if you fused the bed to the wrong$(br)   hamster.",
    "book.adorablehamsterpets.entry.hamster_bed.page6.body": "<b>Right-click</> your tamed hamster with the bed item in hand to link them.$(br2)Now your hamster will blissfully ignore you and roam freely within range of the bed.",
    "book.adorablehamsterpets.entry.hamster_bed.page7.header": "Coordinate colors!",
    "book.adorablehamsterpets.entry.hamster_bed.page7.body": "Match your base, or clash horribly. Your$(br)   choice.",
    "book.adorablehamsterpets.entry.hamster_bed.page10.body": "I'll let you figure out the other 4 recipes.$(br2)You're smart. You got this.$(br2)P.S. - Don't place the beds upside down. <i>Wink.</>",
    "book.adorablehamsterpets.entry.hamster_bed.page11.header": "Tamed Wander Mode",
    "book.adorablehamsterpets.entry.hamster_bed.page11.body": "Once you've placed the bed, <i>(not upside down)</> you're now the proud operator of a tiny, leafy command center:$(br2)• <b>Right-click</> to toggle Wander Mode on/off.$(br2)• <b>$(k:sneak) + Right-click</> to cycle wander distance.",
    "book.adorablehamsterpets.entry.hamster_bed.page12.body": "$(br)• Use $(l:crops_food/cheese)<gold><b>Cheese</> to lure them to bed for a nap.$(br2)• Use <b>Rotten Flesh</> to make the bed... unappealing, preventing sleep.$(br2)• <b>$(k:sneak) + Rotten Flesh</> to unlink the bed entirely.$(br2)Breaking the bed also disables Wander Mode.$(br2)Duh.",
    "book.adorablehamsterpets.entry.cheek_pouches": "Cheek Pouches",
    "book.adorablehamsterpets.entry.cheek_pouches.page1.body": "Inventory... in their face. Feed it to them to earn cheek access. Then <b>Sneak + Right-click</> a tamed hamster for 6 slots of prime real estate.$(br2)If hurt, they can automatically eat $(l:crops_food/hamster_food_mix)<dark_green><b>Hamster Food Mix</> from their cheeks if available.",
    "book.adorablehamsterpets.entry.cheek_pouches.page2.body": "$(br)And no, you can't stuff a Netherite block in there. Your hamster's cheeks, while surprisingly spacious, are not a pocket dimension. They will refuse to store anything too bulky, pointy, or generally illogical.$(br2)Consult the <b>config</> if you wish to re-define what constitutes 'illogical.'",
    "book.adorablehamsterpets.entry.subterranean_shinies": "Subterranean Shinies",
    "book.adorablehamsterpets.entry.subterranean_shinies.page1.body": "Those excited sniffs? Your pocket prospector smells <dark_aqua><b>Diamonds!</> Checks a 10-block radius by default.$(br2)It pauses between alerts, so listen carefully before you start digging... again.",
    "book.adorablehamsterpets.entry.psychological_warfare": "Psychological Warfare",
    "book.adorablehamsterpets.entry.psychological_warfare.page1.body": "Your hamster exudes an aura of pure, unadulterated menace that is apparently only perceptible to giant <b>Spiders</> and angry horned <b>Ravagers</>.$(br2)Use this knowledge to your advantage— watch as the Ravager desperately flees from something that is",
    "book.adorablehamsterpets.entry.psychological_warfare.page2.body": "$(br)small enough to accidentally be snorted up its nostril.$(br2)Wait... perhaps that's what the Ravager is so afraid of?$(br2)This needs further investigation.",
  "book.adorablehamsterpets.category.crops_food": "§r§6§l§nCrops and Food§r",
  "book.adorablehamsterpets.category.crops_food.desc": "You can't build a hamster empire on an empty stomach.$(br2)This chapter covers the entire food chain, from foraging for wild seeds to cultivating $(l:crops_food/green_beans)<dark_green><b>performance-enhancing legumes</>.$(br2)Also, $(l:crops_food/cheese)<gold><b>Cheese</>.",
    "book.adorablehamsterpets.entry.sunflower": "Sunflower",
    "book.adorablehamsterpets.entry.sunflower.page1.body": "These aren't your average, purely decorative sunflowers. Right-click a seeded one to harvest <dark_green><b>Sunflower Seeds</>— a key ingredient for the $(l:crops_food/hamster_food_mix)<dark_green><b>Hamster Food Mix</>.$(br2)No, you can't plant the seeds yet. That feature is still... incubating. Patience.",
    "book.adorablehamsterpets.entry.sunflower.page1.image_title": "New Sunflowers",
    "book.adorablehamsterpets.entry.cucumber" : "Cucumbers",
    "book.adorablehamsterpets.entry.cucumber.page1.body": "Find these <dark_green><b>Wild Cucumber Bushes</> lurking in warmer biomes.$(br2)Right-click a seeded one.$(br2)This is the first step on your path to hamster-fueled glory.",
    "book.adorablehamsterpets.entry.cucumber.page1.image_title": "Wild Cucumber Bush",
    "book.adorablehamsterpets.entry.cucumber.page2.header": "Cucumber Cultivation",
    "book.adorablehamsterpets.entry.cucumber.page2.body": "Plant the seeds.$(br2)Wait. Wait some more.$(br2)Harvest the <dark_green><b>Cucumber</>. Try not to starve while waiting.$(br2)You'll also get more seeds back, because that's how farming works.",
    "book.adorablehamsterpets.entry.cucumber.page3.header": "The Bait",
    "book.adorablehamsterpets.entry.cucumber.page3.body": "Craft a cucumber to get the coveted <dark_green><b>Sliced Cucumber</>.$(br2)This is the primary currency for $(l:the_hamster_life/taming)<b>taming</> a wild hamster and can also be used for $(l:the_hamster_life/feeding)<b>healing</>.",
    "book.adorablehamsterpets.entry.green_beans" : "Green Beans",
    "book.adorablehamsterpets.entry.green_beans.page1.body": "Find these <dark_green><b>Wild Green Bean Bushes</> in temperate or wet areas. Right-click to procure seeds.$(br2)These aren't your garden-variety legumes.",
    "book.adorablehamsterpets.entry.green_beans.page1.image_title": "Wild Green Bean Bush",
    "book.adorablehamsterpets.entry.green_beans.page2.header": "Bean Farming",
    "book.adorablehamsterpets.entry.green_beans.page2.body": "Plant the seeds, wait for the magic to happen, then harvest your <dark_green><b>Green Beans</>.$(br2)Simple.",
    "book.adorablehamsterpets.entry.green_beans.page3.header": "A Potent Snack",
    "book.adorablehamsterpets.entry.green_beans.page3.body": "Smelt Green Beans in a furnace to create <dark_green><b>Steamed Green Beans</>.$(br2)These can be used for $(l:the_hamster_life/feeding)<dark_green><b>healing</>, and— much more importantly— for commencing the awe-inspiring $(l:the_hamster_life/feeding#buffs)<dark_green><b>Hamster Zoomies</>.",
    "book.adorablehamsterpets.entry.green_beans.page4.body": "Yes, you smelt it. Makes perfect sense.$(br2)A more... intuitive steaming method is planned for a future update, maybe involving a multi-block structure... and water buckets? We shall see.",
    "book.adorablehamsterpets.entry.hamster_food_mix" : "Hamster Food Mix",
    "book.adorablehamsterpets.entry.hamster_food_mix.page1.body": "Craft this. Or don't. Your hamster, your problem.$(br2)But anyway, it heals well and crucially, is one of the few items they'll never refuse, even if fed repeatedly. It's also the key to convincing them that their face is a perfectly viable $(l:advanced_rodentry/cheek_pouches)<b>storage solution</>.",
    "book.adorablehamsterpets.entry.hamster_food_mix.page2.body": "$(br)Failure to follow these instructions precisely may result in the accidental creation of a new form of sentient gravel.",
    "book.adorablehamsterpets.entry.cheese" : "Cheese",
    "book.adorablehamsterpets.entry.cheese.page1.body": "Not only is this delicacy ideal for tempting small rodents onto your person, you also eat it.$(br2)It's suspiciously nourishing and slips right down the old gullet more quickly than other foods, if you can stomach the... <i>moist sounds</>.",
    "book.adorablehamsterpets.entry.cheese.page2.body": "Yes, this is the alchemical process of transmuting a bucket of milk directly into three solid wedges of cheese. It's science. Don't question it.$(br2)(Turn page)",
    "book.adorablehamsterpets.entry.cheese.page3.body": "$(br)A more involved, thematically appropriate cheese-making process is planned for a future update.$(br2)$(l:the_kitchen_drawer/join_the_discord)<b>Join the Discord</> to help shape the future!",
  "book.adorablehamsterpets.category.the_kitchen_drawer": "§r§6§l§nThe Kitchen Drawer§r",
  "book.adorablehamsterpets.category.the_kitchen_drawer.desc": "You stepped into the right dimension, my friend.$(br2)Here you'll find the $(l:the_kitchen_drawer/config_heaven)<b>configuration menu</>, our $(l:the_kitchen_drawer/join_the_discord)<b>bustling online hamster fan club</>, and a <i>conveniently</> placed $(l:the_kitchen_drawer/support_the_mod)<b>donation box</>.$(br2)Rummage around.",
    "book.adorablehamsterpets.entry.join_the_discord": "Join the Discord!",
    "book.adorablehamsterpets.entry.join_the_discord.page1.body": "Got a genius idea for the next hamster accessory? Want to share screenshots of your furry army? Or maybe you just want to see what's coming next?$(br2)Pop over to the official Discord server:$(br)<gold><b><i>The Cheek Pouch.</>",
    "book.adorablehamsterpets.entry.join_the_discord.page2.body": "$(br)I've got channels for suggestions, bug reports, screenshots, and even a showcase for your real-life pets.$(br2)Come help shape the future of the mod!",
    "book.adorablehamsterpets.entry.join_the_discord.page2.link_text": "Join Discord",
    "book.adorablehamsterpets.entry.support_the_mod": "Support the Mod",
    "book.adorablehamsterpets.entry.support_the_mod.page1.body": "Adorable Hamster Pets began as a weekend project for my wife and quickly grew into a passion. My goal is to be able to dedicate more of my week to adding features, fixing bugs, and dreaming up new mods.$(br2)I'm a one-person show, and every coffee you buy helps me trade a",
    "book.adorablehamsterpets.entry.support_the_mod.page2.body": "$(br)bit of my 'day job' for full-time hamster-wrangling and code-slinging.$(br2)If you enjoy the mod and want to chip in, please consider buying me a coffee! Thanks for helping me make more cool stuff.               :)",
    "book.adorablehamsterpets.entry.support_the_mod.page2.link_text": "Buy Me a Coffee",
    "book.adorablehamsterpets.entry.config_heaven": "Config Heaven",
    "book.adorablehamsterpets.entry.config_heaven.page1.body": "Not a fan of earning your hamster's trust for cheek storage? Wish those tooltips would just vanish? Good news for the micromanagers: this mod is highly configurable. Tweak to your heart's content.$(br2)Or break everything. Your call.",
    "book.adorablehamsterpets.entry.config_heaven.page2.body": "$(br)For convenience, I coded a custom button so you can access the full configuration screen directly from this book.$(br2)No idea what a config is? Prepare for awesomeness.",
    "book.adorablehamsterpets.entry.config_heaven.page2.link_text": "Open Config",
    "book.adorablehamsterpets.entry.missing_book": "Lost the book?",
    "book.adorablehamsterpets.entry.missing_book.page1.body": "Misplaced this invaluable tome of rodent wisdom, or need another one?$(br2)Shocking.$(br2)$(c:/function adorablehamsterpets:player/give_book_to_self)<b>Click here</>, or craft another with a vanilla <b>Book</> and some $(l:crops_food/cucumber#item)<dark_green><b>Sliced Cucumber</>.",
    "book.adorablehamsterpets.entry.missing_book.page2.body": "Don't ask why Sliced Cucumber.$(br2)It's a long story involving a very particular hamster and an unfortunate water polo incident.",
    "book.adorablehamsterpets.entry.missing_book.recipe_title": "The Guidebook",
  "book.adorablehamsterpets.category.update_notes": "§r§6§l§nUpdate Notes§r",
    "book.adorablehamsterpets.category.update_notes.desc": "What's new, what's fixed, and what's probably going to break next.",
  "book.adorablehamsterpets.category.announcements": "§r§6§l§nAnnouncements§r",
    "book.adorablehamsterpets.category.announcements.desc": "Occasional news, surveys, and other important squeaks from the developer. MORE FUN THAN IT SOUNDS, I PROMISE."
}
```

### 📂 `fabric/`
`build.gradle`
```groovy
plugins {
    id 'com.gradleup.shadow'
}

architectury {
    platformSetupLoomIde()
    fabric()
}

fabricApi {
    configureDataGeneration {
        client = true
    }
}

evaluationDependsOn ':common'

loom {
    mods {
        main {
            sourceSet sourceSets.main
            sourceSet project(':common').sourceSets.main
        }
    }
}

sourceSets {
    main {
        resources {
            // include BOTH assets and data produced by datagen
            srcDir file('src/main/generated')
            exclude('.cache/**')
        }
    }
}

// ---------- Datagen wiring ----------
// Paths that Fabric datagen writes to
def genRoot = file("$projectDir/src/main/generated")
def genRes  = file("$projectDir/src/main/generated/resources")

// Tell Gradle what runDatagen produces (so other tasks can depend on it)
tasks.named("runDatagen") {
    outputs.dir(genRoot)
    outputs.dir(genRes)
    mustRunAfter("clean")
}

// Artifacts that read those files must wait for datagen
jar {
    dependsOn("runDatagen")
}
sourcesJar {
    dependsOn("runDatagen")
}

// Be tolerant to accidental duplicate paths and never package the cache
tasks.withType(Jar).configureEach {
    exclude(".cache/**")
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

tasks.named("jar") {
    dependsOn("runDatagen")
    inputs.dir(file('src/main/generated'))
}

tasks.named("sourcesJar") {
    dependsOn("runDatagen")
    inputs.dir(file('src/main/generated'))
}
// ---------- End Datagen wiring ----------

configurations {
    common {
        canBeResolved = true
        canBeConsumed = false
    }
    compileClasspath.extendsFrom common
    runtimeClasspath.extendsFrom common
    developmentFabric.extendsFrom common
    shadowBundle {
        canBeResolved = true
        canBeConsumed = false
    }
}

dependencies {
    modImplementation "net.fabricmc:fabric-loader:${rootProject.fabric_loader_version}"
    modImplementation "net.fabricmc.fabric-api:fabric-api:$rootProject.fabric_api_version"
    modImplementation "dev.architectury:architectury-fabric:$rootProject.architectury_api_version"

    // Fabric Dependencies
    modImplementation "software.bernie.geckolib:geckolib-fabric-$rootProject.minecraft_version:$rootProject.geckolib_version"
    modImplementation "com.terraformersmc:modmenu:${rootProject.modmenu_version}"
    modImplementation "curse.maven:jade-324717:${rootProject.jade_version_fabric}"
    modImplementation "me.fzzyhmstrs:fzzy_config:${rootProject.fzzy_config_version}"
    modRuntimeOnly "maven.modrinth:fabric-language-kotlin:${rootProject.flk_version}"
    modImplementation include("maven.modrinth:placeholder-api:2.1.1+1.20")
    modImplementation "vazkii.patchouli:Patchouli:1.20.1-84.1-FABRIC"

    common(project(path: ':common', configuration: 'namedElements')) { transitive false }
    shadowBundle project(path: ':common', configuration: 'transformProductionFabric')
}

processResources {
    from(file('src/main/generated')) {
        exclude('.cache/**')
    }
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    from project(":common").sourceSets.main.resources
    from sourceSets.main.resources

    inputs.property 'version', project.version

    filesMatching('fabric.mod.json') {
        expand version: project.version
    }
}

shadowJar {
    configurations = [project.configurations.shadowBundle]
    archiveClassifier = 'dev-shadow'

    from sourceSets.main.output

    dependsOn('runDatagen')

    // Exclude the generated hamster bed item model
    from('src/main/generated') {
        exclude('assets/adorablehamsterpets/models/item/hamster_bed.json')
    }
}

remapJar {
    inputFile.set shadowJar.archiveFile
    dependsOn shadowJar
}

sourcesJar {
    def commonSources = project(":common").sourcesJar
    dependsOn commonSources
    from commonSources.archiveFile.map { zipTree(it) }
}

components.java {
    withVariantsFromConfiguration(project.configurations.shadowRuntimeElements) {
        skip()
    }
}
```

### 📂 `fabric/src/main/java/net/dawson/adorablehamsterpets/fabric/datagen/`
`ModRegistryDataGenerator.java`
```java
package net.dawson.adorablehamsterpets.fabric.datagen;

// (Imports omitted to save token count)

public class ModRegistryDataGenerator extends FabricDynamicRegistryProvider {
    public ModRegistryDataGenerator(FabricDataOutput output, CompletableFuture<RegistryWrapper.WrapperLookup> registriesFuture) {
        super(output, registriesFuture);
    }

    @Override
    protected void configure(RegistryWrapper.WrapperLookup registries, Entries entries) {
       entries.addAll(registries.getWrapperOrThrow(RegistryKeys.CONFIGURED_FEATURE));
       entries.addAll(registries.getWrapperOrThrow(RegistryKeys.PLACED_FEATURE));

    }

    @Override
    public String getName() {
        return "";
    }
}
```

`AdorableHamsterPetsDataGenerator.java`
```java
package net.dawson.adorablehamsterpets.fabric.datagen;

// (Imports omitted to save token count)

public class AdorableHamsterPetsDataGenerator implements DataGeneratorEntrypoint {
	@Override
	public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
	FabricDataGenerator.Pack pack = fabricDataGenerator.createPack();
		pack.addProvider(EnUsGenerator::new);
		pack.addProvider(ModLootTableProvider::new);
		pack.addProvider(ModModelProvider::new);
		pack.addProvider(ModRecipeProvider::new);
		pack.addProvider(ModWorldGenerator::new);
	}

	private static class ModWorldGenerator extends FabricDynamicRegistryProvider {
		public ModWorldGenerator(FabricDataOutput output, CompletableFuture<RegistryWrapper.WrapperLookup> registriesFuture) {
			super(output, registriesFuture);
		}

		@Override
		protected void configure(RegistryWrapper.WrapperLookup registries, Entries entries) {
			entries.addAll(registries.getWrapperOrThrow(RegistryKeys.CONFIGURED_FEATURE));
			entries.addAll(registries.getWrapperOrThrow(RegistryKeys.PLACED_FEATURE));
		}

		@Override
		public String getName() {
			return "World Gen";
		}
	}

	@Override
	public void buildRegistry(RegistryBuilder registryBuilder) {
		registryBuilder.addRegistry(RegistryKeys.CONFIGURED_FEATURE, ModConfiguredFeatures::bootstrap);
		registryBuilder.addRegistry(RegistryKeys.PLACED_FEATURE, ModPlacedFeatures::bootstrap);
	}
}
```

`EnUsGenerator.java`
```java
package net.dawson.adorablehamsterpets.fabric.datagen;

// (Imports omitted to save token count)

/**
 * Generates the final {@code assets/adorablehamsterpets/lang/en_us.json}.
 * <p>
 * 1.  Copies every entry from {@code en_us_base.json}.<br>
 * 2.  Appends all automatically-generated config-GUI keys from Fzzy Config.
 */
public class EnUsGenerator extends FabricLanguageProvider {

    private static final String BASE_RESOURCE_PATH =
            "assets/adorablehamsterpets/lang/en_us_base.json";

    private static final Gson GSON = new Gson();

    public EnUsGenerator(FabricDataOutput output) {
        super(output);
    }

    @Override
    public void generateTranslations(TranslationBuilder builder) {

        /* ------------------------------------------------------------
         * 1)  Load every manual translation from en_us_base.json
         * ------------------------------------------------------------ */
        Set<String> seen = new java.util.HashSet<>();

        try (var stream = getClass().getClassLoader()
                .getResourceAsStream(BASE_RESOURCE_PATH)) {

            if (stream != null) {
                JsonObject obj = GSON.fromJson(
                        new InputStreamReader(stream, StandardCharsets.UTF_8),
                        JsonObject.class);

                for (Map.Entry<String, JsonElement> e : obj.entrySet()) {
                    builder.add(e.getKey(), e.getValue().getAsString());
                    seen.add(e.getKey());
                }
            } else {
                AdorableHamsterPets.LOGGER.warn("Could not locate {}", BASE_RESOURCE_PATH);
            }
        } catch (Exception ex) {
            throw new RuntimeException("Failed to read " + BASE_RESOURCE_PATH, ex);
        }

        /* ------------------------------------------------------------
         * 2)  Auto-generate config translations.
         *     If a key already exists, skip it.
         * ------------------------------------------------------------ */
        BiConsumer<String, String> safeSingleWriter = (key, value) -> {
            if (seen.add(key)) {
                builder.add(key, value); // Only add the standard key
            }
        };

        // --- Helper to manually scrape class annotations ---
        // TODO: REVERT THIS WORKAROUND IN FZZY CONFIG 0.7.4+
        // In v0.7.3, ConfigApiJava.buildTranslations() ignores class-level descriptions.
        // This is a bug, scheduled to be fixed in v0.7.4. Once updated, DELETE this 'ManualScraper' interface and lambda entirely.
        // Also remove the @Translation annotations from AhpConfig, AhpRootConfig, and AhpWorldGenConfig.
        ManualScraper scraper = (clazz, idStr) -> {
            // Note: The keys here must match the prefix defined in the @Translation annotation on the config class.
            String baseKey = "adorablehamsterpets." + idStr;

            if (clazz.isAnnotationPresent(Translatable.Name.class)) {
                safeSingleWriter.accept(baseKey, clazz.getAnnotation(Translatable.Name.class).value());
            }
            if (clazz.isAnnotationPresent(Translatable.Desc.class)) {
                safeSingleWriter.accept(baseKey + ".desc", clazz.getAnnotation(Translatable.Desc.class).value());
            }
        };

        // 1. Generate for Root Config
        scraper.scrape(AhpRootConfig.class, "root");
        ConfigApiJava.buildTranslations(
                AhpRootConfig.class,
                Identifier.of(AdorableHamsterPets.MOD_ID, "root"),
                "en_us",
                false,
                safeSingleWriter
        );

        // 2. Generate for Main Config
        scraper.scrape(AhpConfig.class, "main");
        ConfigApiJava.buildTranslations(
                AhpConfig.class,
                Identifier.of(AdorableHamsterPets.MOD_ID, "main"),
                "en_us",
                false,
                safeSingleWriter
        );

        // 3. Generate for WorldGen Config
        scraper.scrape(AhpWorldGenConfig.class, "worldgen");
        ConfigApiJava.buildTranslations(
                AhpWorldGenConfig.class,
                Identifier.of(AdorableHamsterPets.MOD_ID, "worldgen"),
                "en_us",
                false,
                safeSingleWriter
        );
    }

    @FunctionalInterface
    private interface ManualScraper {
        void scrape(Class<?> clazz, String idStr);
    }
}
```

`ModLootTableProvider.java`
```java
package net.dawson.adorablehamsterpets.fabric.datagen;

// (Imports omitted to save token count)

public class ModLootTableProvider extends FabricBlockLootTableProvider {
    public ModLootTableProvider(FabricDataOutput dataOutput) {
        super(dataOutput);
    }

    @Override
    public void generate() {

        // Keep existing crop loot tables
        BlockStatePropertyLootCondition.Builder builder3 = BlockStatePropertyLootCondition.builder(ModBlocks.GREEN_BEANS_CROP.get())
                .properties(StatePredicate.Builder.create().exactMatch(GreenBeansCropBlock.AGE, GreenBeansCropBlock.MAX_AGE));
        this.addDrop(ModBlocks.GREEN_BEANS_CROP.get(), this.cropDrops(ModBlocks.GREEN_BEANS_CROP.get(), ModItems.GREEN_BEANS.get(), ModItems.GREEN_BEAN_SEEDS.get(), builder3));

        BlockStatePropertyLootCondition.Builder builder4 = BlockStatePropertyLootCondition.builder(ModBlocks.CUCUMBER_CROP.get())
                .properties(StatePredicate.Builder.create().exactMatch(CucumberCropBlock.AGE, CucumberCropBlock.MAX_AGE));
        this.addDrop(ModBlocks.CUCUMBER_CROP.get(), this.cropDrops(ModBlocks.CUCUMBER_CROP.get(), ModItems.CUCUMBER.get(), ModItems.CUCUMBER_SEEDS.get(), builder4));

        // --- Custom Sunflower Loot Table ---
        // Only drop the item when the LOWER half is broken
        LootCondition.Builder conditionBuilder = BlockStatePropertyLootCondition.builder(ModBlocks.SUNFLOWER_BLOCK.get())
                .properties(StatePredicate.Builder.create().exactMatch(Properties.DOUBLE_BLOCK_HALF, DoubleBlockHalf.LOWER));

        // Define the drop (sunflower item)
        Item sunflowerItemToDrop = ModBlocks.SUNFLOWER_BLOCK.get().asItem();

        this.addDrop(ModBlocks.SUNFLOWER_BLOCK.get(), LootTable.builder()
                .pool(LootPool.builder()
                        .rolls(ConstantLootNumberProvider.create(1.0F)) // Always try to roll once
                        .conditionally(conditionBuilder) // Apply the condition (only drop if lower half)
                        .with(this.applyExplosionDecay(ModBlocks.SUNFLOWER_BLOCK.get(), ItemEntry.builder(sunflowerItemToDrop))) // Add the item entry
                        .conditionally(SurvivesExplosionLootCondition.builder()) // Standard condition for blocks
                )
        );

        // Drop 1-2 seeds when broken
        addDrop(ModBlocks.WILD_GREEN_BEAN_BUSH.get(), LootTable.builder()
                .pool(LootPool.builder()
                        .rolls(ConstantLootNumberProvider.create(1.0f)) // Always try to roll once
                        .with(ItemEntry.builder(ModItems.GREEN_BEAN_SEEDS.get())
                                .apply(SetCountLootFunction.builder(UniformLootNumberProvider.create(1.0f, 2.0f)))) // Drop 1 to 2 seeds
                        .conditionally(SurvivesExplosionLootCondition.builder()) // Only drop if not destroyed by explosion
                )
        );

    }


    // Keep existing multipleOreDrops helper method if needed elsewhere
    public LootTable.Builder multipleOreDrops(Block drop, Item item, float minDrops, float maxDrops) {
        return this.dropsWithSilkTouch(drop, this.applyExplosionDecay(drop, ((LeafEntry.Builder<?>)
                        ItemEntry.builder(item).apply(SetCountLootFunction.builder(UniformLootNumberProvider.create(minDrops, maxDrops)))))
                .apply(ApplyBonusLootFunction.oreDrops(Enchantments.FORTUNE)));
    }
}
```

`ModModelProvider.java`
```java
package net.dawson.adorablehamsterpets.fabric.datagen;

// (Imports omitted to save token count)

public class ModModelProvider extends FabricModelProvider {
    public ModModelProvider(FabricDataOutput output) {
        super(output);
    }

    // Helper for creating Hamster Bed models
    private void generateHamsterBedVariantModels(BlockStateModelGenerator generator) {
        // TODO: Add "pale_oak" when porting
        List<String> woodTypes = List.of("oak", "spruce", "birch", "jungle", "acacia", "dark_oak", "mangrove", "cherry", "bamboo");
        // Base model ID
        Identifier baseModelId = Identifier.of(AdorableHamsterPets.MOD_ID, "block/hamster_bed");
        for (String wood : woodTypes) {
            // Model ID for this variant
            Identifier variantModelId = Identifier.of(AdorableHamsterPets.MOD_ID, "block/hamster_bed_" + wood);
            // Texture for this variant
            Identifier particleTexture = Identifier.of(AdorableHamsterPets.MOD_ID, "block/hamster_bed_" + wood);
            // Create texture map with just the particle texture
            TextureMap textureMap = new TextureMap().put(TextureKey.PARTICLE, particleTexture);
            // Create model with base as parent and particle texture key
            Model variantModel = new Model(
                    Optional.of(baseModelId),  // parent
                    Optional.empty(),          // no variant suffix
                    TextureKey.PARTICLE        // required texture key
            );
            // Upload the model
            variantModel.upload(variantModelId, textureMap, generator.modelCollector);
        }
    }

    @Override
    public void generateBlockStateModels(BlockStateModelGenerator blockStateModelGenerator) {
        // Generate hamster bed variant models
        generateHamsterBedVariantModels(blockStateModelGenerator);

        // Generates models for crop blocks
        // (MAX_AGE = 3)
        blockStateModelGenerator.registerCrop(ModBlocks.GREEN_BEANS_CROP.get(), GreenBeansCropBlock.AGE, 0, 1, 2, 3);
        blockStateModelGenerator.registerCrop(ModBlocks.CUCUMBER_CROP.get(), CucumberCropBlock.AGE, 0, 1, 2, 3);

        // --- Step 1: Generate Block Models ---
        Identifier wildGreenBeanSeededTexture = Identifier.of(AdorableHamsterPets.MOD_ID, "block/wild_green_bean_bush_seeded");
        Identifier wildGreenBeanSeedlessTexture = Identifier.of(AdorableHamsterPets.MOD_ID, "block/wild_green_bean_bush_seedless");
        Identifier wildCucumberSeededTexture = Identifier.of(AdorableHamsterPets.MOD_ID, "block/wild_cucumber_bush_seeded");
        Identifier wildCucumberSeedlessTexture = Identifier.of(AdorableHamsterPets.MOD_ID, "block/wild_cucumber_bush_seedless");

        TextureMap greenBeanSeededMap = TextureMap.cross(wildGreenBeanSeededTexture);
        TextureMap greenBeanSeedlessMap = TextureMap.cross(wildGreenBeanSeedlessTexture);
        TextureMap cucumberSeededMap = TextureMap.cross(wildCucumberSeededTexture);
        TextureMap cucumberSeedlessMap = TextureMap.cross(wildCucumberSeedlessTexture);

        Identifier greenBeanSeededModelId = Models.CROSS.upload(ModBlocks.WILD_GREEN_BEAN_BUSH.get(), "_seeded", greenBeanSeededMap, blockStateModelGenerator.modelCollector);
        Identifier greenBeanSeedlessModelId = Models.CROSS.upload(ModBlocks.WILD_GREEN_BEAN_BUSH.get(), "_seedless", greenBeanSeedlessMap, blockStateModelGenerator.modelCollector);
        Identifier cucumberSeededModelId = Models.CROSS.upload(ModBlocks.WILD_CUCUMBER_BUSH.get(), "_seeded", cucumberSeededMap, blockStateModelGenerator.modelCollector);
        Identifier cucumberSeedlessModelId = Models.CROSS.upload(ModBlocks.WILD_CUCUMBER_BUSH.get(), "_seedless", cucumberSeedlessMap, blockStateModelGenerator.modelCollector);

        // --- Step 2: Generate Block States ---
        blockStateModelGenerator.blockStateCollector.accept(VariantsBlockStateSupplier.create(ModBlocks.WILD_GREEN_BEAN_BUSH.get())
                .coordinate(BlockStateModelGenerator.createBooleanModelMap(
                        WildGreenBeanBushBlock.SEEDED,
                        greenBeanSeededModelId,
                        greenBeanSeedlessModelId
                ))
        );

        blockStateModelGenerator.blockStateCollector.accept(VariantsBlockStateSupplier.create(ModBlocks.WILD_CUCUMBER_BUSH.get())
                .coordinate(BlockStateModelGenerator.createBooleanModelMap(
                        WildCucumberBushBlock.SEEDED,
                        cucumberSeededModelId,
                        cucumberSeedlessModelId
                ))
        );
        // Sunflower and wild bush models handled manually
    }


    @Override
    public void generateItemModels(ItemModelGenerator itemModelGenerator) {
        itemModelGenerator.register(ModItems.ANNOUNCEMENT_BELL_ICON.get(), Models.GENERATED);
        itemModelGenerator.register(ModItems.HAMSTER_SPAWN_EGG.get(), Models.GENERATED);
        itemModelGenerator.register(ModItems.CUCUMBER.get(), Models.GENERATED);
        itemModelGenerator.register(ModItems.SLICED_CUCUMBER.get(), Models.GENERATED);
        itemModelGenerator.register(ModItems.GREEN_BEANS.get(), Models.GENERATED);
        itemModelGenerator.register(ModItems.STEAMED_GREEN_BEANS.get(), Models.GENERATED);
        itemModelGenerator.register(ModItems.CHEESE.get(), Models.GENERATED);
        itemModelGenerator.register(ModItems.HAMSTER_FOOD_MIX.get(), Models.GENERATED);
        itemModelGenerator.register(ModItems.SUNFLOWER_SEEDS.get(), Models.GENERATED);
        itemModelGenerator.register(ModBlocks.WILD_GREEN_BEAN_BUSH.get().asItem(), Models.GENERATED);
        itemModelGenerator.register(ModBlocks.WILD_CUCUMBER_BUSH.get().asItem(), Models.GENERATED);
        itemModelGenerator.register(ModItems.HAMSTER_BEDDING.get(), Models.GENERATED);
        for (RegistrySupplier<Item> bedItemSupplier : ModItems.HAMSTER_BED_ITEMS.values()) {
            // Register each bed item variant to use the 'hamster_bed' item model.
            itemModelGenerator.register(bedItemSupplier.get(), new Model(Optional.of(Identifier.of(AdorableHamsterPets.MOD_ID, "item/hamster_bed")), Optional.empty()));
        }
    }
}
```

`ModRecipeProvider.java`
```java
package net.dawson.adorablehamsterpets.fabric.datagen;

// (Imports omitted to save token count)

public class ModRecipeProvider extends FabricRecipeProvider {

    // --- 1. Constructor ---
    // 1.20.1 signature
    public ModRecipeProvider(FabricDataOutput output) {
        super(output);
    }

    // --- 2. Helpers ---
    // For Hamster Bed variants
    // 1.20.1 signature
    private void offerHamsterBedRecipe(Consumer<RecipeJsonProvider> exporter, Item planks, WoodVariant variant) {
        // Result is the specific item for this variant
        Item resultItem = ModItems.HAMSTER_BED_ITEMS.get(variant).get();

        ShapedRecipeJsonBuilder.create(RecipeCategory.DECORATIONS, resultItem)
                .pattern(" H ")
                .pattern("HHH")
                .pattern("PPP")
                .input('H', ModItems.HAMSTER_BEDDING.get())
                .input('P', planks)
                .group("hamster_bed")
                .criterion("has_hamster_bedding", conditionsFromItem(ModItems.HAMSTER_BEDDING.get()))
                // 1.20.1: Use new Identifier()
                .offerTo(exporter, new Identifier(AdorableHamsterPets.MOD_ID, "hamster_bed_" + variant.asString()));
    }

    // --- 3. Public Methods ---
    @Override
    public void generate(Consumer<RecipeJsonProvider> exporter) {
        // --- Smelting Recipes ---
        // Smelting Green Beans to Steamed Green Beans
        // The list should only contain items that can be smelted into the result.
        offerSmelting(exporter, List.of(ModItems.GREEN_BEANS.get()), RecipeCategory.FOOD, ModItems.STEAMED_GREEN_BEANS.get(),
                0.35f, 200, "steamed_green_beans");

        // --- Shaped Crafting Recipes ---
        // Hamster Bed
        // On 1.20.1, pass the 'exporter' consumer directly
        offerHamsterBedRecipe(exporter, Items.OAK_PLANKS, WoodVariant.OAK);
        offerHamsterBedRecipe(exporter, Items.SPRUCE_PLANKS, WoodVariant.SPRUCE);
        offerHamsterBedRecipe(exporter, Items.BIRCH_PLANKS, WoodVariant.BIRCH);
        offerHamsterBedRecipe(exporter, Items.JUNGLE_PLANKS, WoodVariant.JUNGLE);
        offerHamsterBedRecipe(exporter, Items.ACACIA_PLANKS, WoodVariant.ACACIA);
        offerHamsterBedRecipe(exporter, Items.DARK_OAK_PLANKS, WoodVariant.DARK_OAK);
        offerHamsterBedRecipe(exporter, Items.MANGROVE_PLANKS, WoodVariant.MANGROVE);
        offerHamsterBedRecipe(exporter, Items.CHERRY_PLANKS, WoodVariant.CHERRY);
        offerHamsterBedRecipe(exporter, Items.BAMBOO_PLANKS, WoodVariant.BAMBOO);

        // Hamster Food Mix
        ShapedRecipeJsonBuilder.create(RecipeCategory.FOOD, ModItems.HAMSTER_FOOD_MIX.get(), 1)
                .pattern("SSS")
                .pattern("PCP")
                .pattern("WWW")
                .input('S', ModItems.SUNFLOWER_SEEDS.get())
                .input('P', Items.PUMPKIN_SEEDS)
                .input('C', Items.CARROT)
                .input('W', Items.WHEAT_SEEDS)
                .criterion("has_sunflower_seeds", conditionsFromItem(ModItems.SUNFLOWER_SEEDS.get()))
                .offerTo(exporter, Identifier.of(AdorableHamsterPets.MOD_ID, "hamster_food_mix_from_ingredients"));

        // Hamster Bedding
        ShapelessRecipeJsonBuilder.create(RecipeCategory.MISC, ModItems.HAMSTER_BEDDING.get(), 2)
                .input(Items.OAK_LEAVES)
                .input(Items.BIRCH_LEAVES)
                .input(Items.DEAD_BUSH)
                .input(Items.PODZOL)
                .criterion("has_oak_leaves", conditionsFromItem(Items.OAK_LEAVES))
                .criterion("has_birch_leaves", conditionsFromItem(Items.BIRCH_LEAVES))
                .criterion("has_dead_bush", conditionsFromItem(Items.DEAD_BUSH))
                .criterion("has_podzol", conditionsFromItem(Items.PODZOL))
                .offerTo(exporter);

        // --- Shapeless Crafting Recipes ---
        // Sliced Cucumber
        ShapelessRecipeJsonBuilder.create(RecipeCategory.FOOD, ModItems.SLICED_CUCUMBER.get(), 3)
                .input(ModItems.CUCUMBER.get())
                .criterion("has_cucumber", conditionsFromItem(ModItems.CUCUMBER.get()))
                .offerTo(exporter);

        // Cheese
        ShapelessRecipeJsonBuilder.create(RecipeCategory.FOOD, ModItems.CHEESE.get(), 3)
                .input(Items.MILK_BUCKET)
                .criterion("has_milk_bucket", conditionsFromItem(Items.MILK_BUCKET))
                .offerTo(exporter);

        // Modded Sunflower to Vanilla Sunflower
        ShapelessRecipeJsonBuilder.create(RecipeCategory.DECORATIONS, Items.SUNFLOWER, 1)
                .input(ModBlocks.SUNFLOWER_BLOCK.get())
                .criterion("has_modded_sunflower", conditionsFromItem(ModBlocks.SUNFLOWER_BLOCK.get()))
                .offerTo(exporter, Identifier.of(AdorableHamsterPets.MOD_ID, "vanilla_sunflower_from_modded"));
    }
}
```

### 📂 `fabric/src/main/java/net/dawson/adorablehamsterpets/item/custom/fabric/`
`HamsterBedItemImpl.java`
```java
package net.dawson.adorablehamsterpets.item.custom.fabric;

// (Imports omitted to save token count)

public class HamsterBedItemImpl {
    public static HamsterBedItem create(Block block, WoodVariant variant, Item.Settings settings) {
        // Fabric just returns the normal item, as it uses createRenderer inside the class
        return new HamsterBedItem(block, variant, settings);
    }
}
```

### 📂 `fabric/src/main/java/net/dawson/adorablehamsterpets/item/fabric/`
`ModItemsImpl.java`
```java
package net.dawson.adorablehamsterpets.item.fabric;

// (Imports omitted to save token count)

public class ModItemsImpl {
    /**
     * Provides the Fabric implementation for registering the spawn egg.
     * It uses the vanilla SpawnEggItem and can safely call .get() on the EntityType
     * because Fabric's loader order allows it.
     */
    public static RegistrySupplier<Item> registerSpawnEgg() {
        return ModItems.ITEMS.register("hamster_spawn_egg",
                () -> new SpawnEggItem(ModEntities.HAMSTER.get(), 0x9c631f, 0xffffff, new Item.Settings()));
    }
}
```

### 📂 `fabric/src/main/java/net/dawson/adorablehamsterpets/world/fabric/`
`ModSpawnPlacementsImpl.java`
```java
package net.dawson.adorablehamsterpets.world.fabric;

// (Imports omitted to save token count)

/**
 * The Fabric-specific implementation for {@link ModSpawnPlacements}.
 * This class is called by the @ExpectPlatform bridge.
 */
public class ModSpawnPlacementsImpl {
    public static <T extends MobEntity> void register(EntityType<T> entityType, SpawnRestriction.Location location, Heightmap.Type heightmapType, SpawnRestriction.SpawnPredicate<T> predicate) {
        // On Fabric, call the vanilla/Fabric static method directly.
        SpawnRestriction.register(entityType, location, heightmapType, predicate);
    }
}
```

`ModWorldGenerationImpl.java`
```java
package net.dawson.adorablehamsterpets.world.fabric;

// (Imports omitted to save token count)

public class ModWorldGenerationImpl {
    public static void registerBiomeModifications() {
        // A universal predicate that allows our decider logic to run for every biome.
        Predicate<BiomeModifications.BiomeContext> universalSelector = context -> true;

        BiomeModifications.addProperties(universalSelector, (context, props) -> {
            // --- 1. Sunflower Replacement Logic ---
            // First, check if the biome is even a candidate according to the config.
            if (ModWorldGeneration.shouldFeatureSpawnInBiome(ModPlacedFeatures.CUSTOM_SUNFLOWER_PLACED_KEY, context)) {
                // Second, check if this biome actually has the vanilla sunflower feature.
                boolean hasVanillaSunflower = false;
                for (RegistryEntry<PlacedFeature> entry : props.getGenerationProperties().getFeatures(GenerationStep.Feature.VEGETAL_DECORATION)) {
                    if (entry.matchesKey(VegetationPlacedFeatures.PATCH_SUNFLOWER)) {
                        hasVanillaSunflower = true;
                        break;
                    }
                }

                // Only if BOTH conditions are true, perform the replacement.
                if (hasVanillaSunflower) {
                    props.getGenerationProperties().removeFeature(GenerationStep.Feature.VEGETAL_DECORATION, VegetationPlacedFeatures.PATCH_SUNFLOWER);
                    props.getGenerationProperties().addFeature(GenerationStep.Feature.VEGETAL_DECORATION, ModPlacedFeatures.CUSTOM_SUNFLOWER_PLACED_KEY);
                }
            }

            // --- 2. Bush Addition Logic ---
            if (ModWorldGeneration.shouldFeatureSpawnInBiome(ModPlacedFeatures.WILD_GREEN_BEAN_BUSH_PLACED_KEY, context)) {
                props.getGenerationProperties().addFeature(GenerationStep.Feature.VEGETAL_DECORATION, ModPlacedFeatures.WILD_GREEN_BEAN_BUSH_PLACED_KEY);
            }
            if (ModWorldGeneration.shouldFeatureSpawnInBiome(ModPlacedFeatures.WILD_CUCUMBER_BUSH_PLACED_KEY, context)) {
                props.getGenerationProperties().addFeature(GenerationStep.Feature.VEGETAL_DECORATION, ModPlacedFeatures.WILD_CUCUMBER_BUSH_PLACED_KEY);
            }
        });
    }
}
```

### 📂 `fabric/src/main/java/net/dawson/adorablehamsterpets/fabric/client/`
`AdorableHamsterPetsFabricClient.java`
```java
package net.dawson.adorablehamsterpets.fabric.client;

// (Imports omitted to save token count)

public final class AdorableHamsterPetsFabricClient implements ClientModInitializer {
    @Override
    public void onInitializeClient() {
        AdorableHamsterPetsClient.init();
        AdorableHamsterPetsClient.initScreenHandlers();
        AdorableHamsterPetsClient.initEntityRenderers();
        AdorableHamsterPetsClient.initBlockEntityRenderers();

        // --- Register keybindings for Fabric ---
        ModKeyBindings.init();
        KeyMappingRegistry.register(ModKeyBindings.THROW_HAMSTER_KEY);
        KeyMappingRegistry.register(ModKeyBindings.DISMOUNT_HAMSTER_KEY);
        KeyMappingRegistry.register(ModKeyBindings.FORCE_MOUNT_HAMSTER_KEY);

        // --- Register Particle Provider for all variants ---
        // On 1.20.1, use DefaultParticleType
        for (RegistrySupplier<net.minecraft.particle.DefaultParticleType> particleSupplier : ModParticles.BEDDING_PARTICLES.values()) {
            ParticleFactoryRegistry.getInstance().register(particleSupplier.get(), HamsterBeddingParticle.Factory::new);
        }
    }
}
```

### 📂 `fabric/src/main/java/net/dawson/adorablehamsterpets/fabric/`
`AdorableHamsterPetsFabric.java`
```java
package net.dawson.adorablehamsterpets.fabric;

// (Imports omitted to save token count)

public final class AdorableHamsterPetsFabric implements ModInitializer {
    @Override
    public void onInitialize() {
        AdorableHamsterPets.initRegistries();
        AdorableHamsterPets.initAttributes();
        AdorableHamsterPets.initCommonSetup();
        BiomeModifications.addProperties(
                ModEntitySpawns::shouldSpawnInBiome, // Use the common decider method
                (context, props) -> {
                    props.getSpawnProperties().addSpawn(
                            SpawnGroup.CREATURE,
                            new SpawnSettings.SpawnEntry(
                                    ModEntities.HAMSTER.get(),
                                    Configs.AHP_WORLDGEN.spawnWeight.get(),
                                    1,
                                    Configs.AHP_WORLDGEN.maxGroupSize.get()
                            )
                    );
                }
        );
    }
}










```

### 📂 `fabric/src/main/resources/`
`fabric.mod.json`
```json
{
  "schemaVersion": 1,
  "id": "adorablehamsterpets",
  "version": "${version}",
  "name": "Adorable Hamster Pets",
  "description": "Sure, you’ve got dragons and machines, but let’s be honest— no respectable mod pack is complete without tiny fluffy hamsters running around.",
  "authors": [
    "The Scarlet Fox"
  ],
  "contact": {
    "homepage": "https://www.fortheking.design/",
    "sources": "https://github.com/DawsonBodenhamer/AdorableHamsterPets-Public/",
    "issues": "https://github.com/DawsonBodenhamer/AdorableHamsterPets-Public/issues"
  },
  "license": "All Rights Reserved",
  "icon": "assets/adorablehamsterpets/icon.png",
  "environment": "*",
  "entrypoints": {
    "main": [
      "net.dawson.adorablehamsterpets.fabric.AdorableHamsterPetsFabric"
    ],
    "client": [
      "net.dawson.adorablehamsterpets.fabric.client.AdorableHamsterPetsFabricClient"
    ],
    "fabric-datagen": [
      "net.dawson.adorablehamsterpets.fabric.datagen.AdorableHamsterPetsDataGenerator"
    ],
    "jade": [
      "net.dawson.adorablehamsterpets.integration.jade.AHPJadePlugin"
    ]
  },
  "mixins": [
    "adorablehamsterpets.mixins.json"
  ],
  "depends": {
    "fabricloader": ">=0.15.11",
    "minecraft": "~1.20.1",
    "java": ">=17",
    "fabric-api": ">=0.91.0+1.20.1",
    "architectury": ">=9.2.14",
    "geckolib": ">=4.4.9",
    "fzzy_config": ">=0.7.3+1.20.1",
    "placeholder-api": ">=2.1.1+1.20",
    "patchouli": ">=1.20.1-84.1-FABRIC"
  },
  "suggests": {
    "modmenu": "*",
    "jade": "*"
  },
  "custom": {
    "fzzy_config": [
      "adorablehamsterpets:main"
    ],
    "architectury": {
      "common": "net.dawson.adorablehamsterpets.AdorableHamsterPets"
    },
    "mc-publish": {
      "loaders": ["fabric", "quilt"]
    }
  }
}

```

### 📂 `forge/`
`build.gradle`
```groovy
plugins {
    id 'com.gradleup.shadow'
}

architectury {
    platformSetupLoomIde()
    forge()
}

evaluationDependsOn ':common'

loom {
    forge {
        mixinConfig "adorablehamsterpets.mixins.json"
    }
    mods {
        main {
            sourceSet sourceSets.main
            sourceSet project(':common').sourceSets.main
        }
    }
}

sourceSets {
    main {
        resources {
            srcDir project(':fabric').file('src/main/generated')
            exclude(".cache/**")
        }
    }
}

// ---------- Datagen wiring ----------
// Make Forge’s resource processing wait for Fabric datagen
processResources {
    dependsOn(":fabric:runDatagen")      // simple string form avoids IDE “no candidates” warnings
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    exclude(".cache/**")                  // belt & suspenders
}

// And jars should also be cache-free/duplicate-tolerant
tasks.withType(Jar).configureEach {
    exclude(".cache/**")
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}
// ---------- End Datagen wiring ----------

configurations {
    common {
        canBeResolved = true
        canBeConsumed = false
    }
    compileClasspath.extendsFrom common
    runtimeClasspath.extendsFrom common
    developmentForge.extendsFrom common
    shadowBundle {
        canBeResolved = true
        canBeConsumed = false
    }
}

dependencies {
    forge "net.minecraftforge:forge:$rootProject.forge_version"
    modImplementation "dev.architectury:architectury-forge:$rootProject.architectury_api_version"

    // Forge Dependencies
    modImplementation "software.bernie.geckolib:geckolib-forge-$rootProject.minecraft_version:$rootProject.geckolib_version"
    modImplementation "curse.maven:jade-324717:${rootProject.jade_version_forge}"
    modImplementation "me.fzzyhmstrs:fzzy_config:${rootProject.fzzy_config_version}+forge"
    modRuntimeOnly "thedarkcolour:kotlinforforge:${rootProject.kff_version}"

    modCompileOnly "vazkii.patchouli:Patchouli:1.20.1-84.1-FORGE:api"
    modRuntimeOnly  "vazkii.patchouli:Patchouli:1.20.1-84.1-FORGE"

    common(project(path: ':common', configuration: 'namedElements')) { transitive false }
    shadowBundle project(path: ':common', configuration: 'transformProductionForge')
}

processResources {
    dependsOn(":fabric:runDatagen")
    from(project(':fabric').file('src/main/generated')) {
        exclude('.cache/**')
    }
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    from project(":common").sourceSets.main.resources

    filesMatching(["META-INF/mods.toml", "*.mixins.json"]) {
        expand version: project.version
    }

    from sourceSets.main.resources

    inputs.property 'version', project.version
}

shadowJar {
    exclude "fabric.mod.json"
    configurations = [project.configurations.shadowBundle]
    archiveClassifier = 'dev-shadow'
}

remapJar {
    inputFile.set shadowJar.archiveFile
    dependsOn shadowJar
}

sourcesJar {
    dependsOn(":fabric:runDatagen")
    exclude(".cache/**")
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    def commonSources = project(":common").sourcesJar
    dependsOn commonSources
    from commonSources.archiveFile.map { zipTree(it) }
}

components.java {
    withVariantsFromConfiguration(project.configurations.shadowRuntimeElements) {
        skip()
    }
}
```

`gradle.properties`
```properties
loom.platform = forge

```

### 📂 `forge/src/main/java/net/dawson/adorablehamsterpets/item/custom/forge/`
`HamsterBedItemImpl.java`
```java
package net.dawson.adorablehamsterpets.item.custom.forge;

// (Imports omitted to save token count)

/**
 * The Forge-specific implementation for creating {@link HamsterBedItem} instances.
 * <p>
 * This factory returns an anonymous subclass of {@code HamsterBedItem} that overrides
 * {@code initializeClient}. This is required on Forge 1.20.1 to register the GeckoLib
 * renderer via {@link IClientItemExtensions},
 * as the standard {@code createRenderer} method is ignored by the loader.
 */
public class HamsterBedItemImpl {
    public static HamsterBedItem create(Block block, WoodVariant variant, Item.Settings settings) {
        return new HamsterBedItem(block, variant, settings) {
            @Override
            public void initializeClient(Consumer<IClientItemExtensions> consumer) {
                consumer.accept(new IClientItemExtensions() {
                    private HamsterBedItemRenderer renderer;

                    @Override
                    public BuiltinModelItemRenderer getCustomRenderer() {
                        if (this.renderer == null) {
                            this.renderer = new HamsterBedItemRenderer();
                        }
                        return this.renderer;
                    }
                });
            }
        };
    }
}
```

### 📂 `forge/src/main/java/net/dawson/adorablehamsterpets/item/forge/`
`ModItemsImpl.java`
```java
package net.dawson.adorablehamsterpets.item.forge;

// (Imports omitted to save token count)

public class ModItemsImpl {
    /**
     * Provides the Forge implementation for registering the spawn egg.
     * It uses ForgeSpawnEggItem, which correctly handles the deferred entity type supplier.
     */
    public static RegistrySupplier<Item> registerSpawnEgg() {
        return ModItems.ITEMS.register("hamster_spawn_egg",
                () -> new ForgeSpawnEggItem(ModEntities.HAMSTER, 0x9c631f, 0xffffff, new Item.Settings()));
    }
}
```

### 📂 `forge/src/main/java/net/dawson/adorablehamsterpets/world/forge/`
`ConfigurableFeatureModifier.java`
```java
package net.dawson.adorablehamsterpets.world.forge;

// (Imports omitted to save token count)

public record ConfigurableFeatureModifier(
        RegistryEntryList<Biome> biomes,
        Optional<RegistryEntryList<PlacedFeature>> featuresToAdd,
        Optional<RegistryEntryList<PlacedFeature>> featuresToRemove
) implements BiomeModifier {

    public static final MapCodec<ConfigurableFeatureModifier> CODEC = RecordCodecBuilder.mapCodec(instance ->
            instance.group(
                    RegistryCodecs.entryList(RegistryKeys.BIOME).fieldOf("biomes").forGetter(ConfigurableFeatureModifier::biomes),
                    RegistryCodecs.entryList(RegistryKeys.PLACED_FEATURE).optionalFieldOf("features_to_add").forGetter(ConfigurableFeatureModifier::featuresToAdd),
                    RegistryCodecs.entryList(RegistryKeys.PLACED_FEATURE).optionalFieldOf("features_to_remove").forGetter(ConfigurableFeatureModifier::featuresToRemove)
            ).apply(instance, ConfigurableFeatureModifier::new)
    );

    @Override
    public void modify(RegistryEntry<Biome> biome, Phase phase, ModifiableBiomeInfo.BiomeInfo.Builder builder) {
        if (phase == Phase.ADD && this.biomes.contains(biome)) {
            this.featuresToAdd.ifPresent(additions -> {
                for (RegistryEntry<PlacedFeature> feature : additions) {
                    // Use centralized helper methods to decide if the feature should be added to this specific biome
                    if (ModWorldGeneration.shouldFeatureSpawnInBiome(feature, biome)) {
                        builder.getGenerationSettings().getFeatures(GenerationStep.Feature.VEGETAL_DECORATION).add(feature);
                    }
                }
            });
        }
        if (phase == Phase.REMOVE && this.biomes.contains(biome)) {
            this.featuresToRemove.ifPresent(removals -> {
                for (RegistryEntry<PlacedFeature> feature : removals) {
                    if (ModWorldGeneration.shouldFeatureSpawnInBiome(feature, biome)) {
                        builder.getGenerationSettings().getFeatures(GenerationStep.Feature.VEGETAL_DECORATION).remove(feature);
                    }
                }
            });
        }
    }

    @Override
    public Codec<? extends BiomeModifier> codec() {
        return ModBiomeModifiers.CONFIGURABLE_FEATURE_MODIFIER.get();
    }
}
```

`ConfigurableHamsterSpawnModifier.java`
```java
package net.dawson.adorablehamsterpets.world.forge;

// (Imports omitted to save token count)

/**
 * A custom biome modifier that adds hamster spawns to biomes based on runtime configuration.
 * This modifier is triggered by a simple JSON file and performs its logic in Java, allowing
 * spawn weights and counts to be controlled by the user's config file.
 */
public class ConfigurableHamsterSpawnModifier implements BiomeModifier {
    /**
     * The codec for this biome modifier. A "unit" codec is used because this modifier
     * does not read any data from its JSON definition; all logic is self-contained.
     */
    public static final MapCodec<ConfigurableHamsterSpawnModifier> CODEC =
            MapCodec.unit(ConfigurableHamsterSpawnModifier::new);

    public void modify(RegistryEntry<Biome> biome, Phase phase, ModifiableBiomeInfo.BiomeInfo.Builder builder) {
        // We only want to add spawns, so we only act during the ADD phase.
        if (phase != Phase.ADD) {
            return;
        }

        // The Forge modifier directly checks the biome entry against the parsed config sets.
        // This avoids the need for a BiomeContext object.
        if (ModEntitySpawns.shouldSpawnInBiomeForge(biome)) {
            var spawnBuilder = builder.getMobSpawnSettings();
            var spawnEntry = new SpawnSettings.SpawnEntry(
                    ModEntities.HAMSTER.get(),
                    Configs.AHP_WORLDGEN.spawnWeight.get(),
                    1, // minCount is always 1
                    Configs.AHP_WORLDGEN.maxGroupSize.get()
            );

            // Add the new spawn entry to the CREATURE spawn group.
            spawnBuilder.spawn(SpawnGroup.CREATURE, spawnEntry);
        }
    }

    /**
     * Returns the registered codec that serializes this modifier.
     * This is required by the {@link BiomeModifier} interface.
     *
     * @return The unique {@link Codec} for this modifier type.
     */
    @Override
    public Codec<? extends BiomeModifier> codec() {
        // Return the Codec representation of our MapCodec
        return ModBiomeModifiers.CONFIGURABLE_HAMSTER_SPAWN.get();
    }
}
```

`ModBiomeModifiers.java`
```java
package net.dawson.adorablehamsterpets.world.forge;

// (Imports omitted to save token count)

/**
 * Forge-side registration of biome-modifier codecs.
 * <p>
 * NOTE:  Forge’s {@linkplain ForgeRegistries.Keys#BIOME_MODIFIER_SERIALIZERS
 * BIOME_MODIFIER_SERIALIZERS} registry stores {@code Codec<? extends BiomeModifier>}
 * – not {@code MapCodec}.  Using {@code Codec} here resolves the generic-mismatch
 * errors your IDE highlighted.
 */
public final class ModBiomeModifiers {

    private ModBiomeModifiers() {}

    /* ------------------------------------------------------------ */
    /* Deferred register                                             */
    /* ------------------------------------------------------------ */

    public static final DeferredRegister<Codec<? extends BiomeModifier>> BIOME_MODIFIER_SERIALIZERS =
            DeferredRegister.create(
                    ForgeRegistries.Keys.BIOME_MODIFIER_SERIALIZERS,
                    AdorableHamsterPets.MOD_ID
            );

    /* ------------------------------------------------------------ */
    /* Entries                                                      */
    /* ------------------------------------------------------------ */

    public static final RegistryObject<Codec<ConfigurableHamsterSpawnModifier>> CONFIGURABLE_HAMSTER_SPAWN =
            BIOME_MODIFIER_SERIALIZERS.register(
                    "configurable_hamster_spawns",
                    ConfigurableHamsterSpawnModifier.CODEC::codec
            );



    public static final RegistryObject<Codec<ConfigurableFeatureModifier>> CONFIGURABLE_FEATURE_MODIFIER =
            BIOME_MODIFIER_SERIALIZERS.register(
                    "configurable_feature_modifier",
                    ConfigurableFeatureModifier.CODEC::codec
            );

    /* ------------------------------------------------------------ */
    /* Hook into the mod-event bus                                  */
    /* ------------------------------------------------------------ */

    public static void register(IEventBus modEventBus) {
        BIOME_MODIFIER_SERIALIZERS.register(modEventBus);
    }
}
```

`ModSpawnPlacementsImpl.java`
```java
package net.dawson.adorablehamsterpets.world.forge;

// (Imports omitted to save token count)

/**
 * The Forge-specific implementation for spawn placements.
 * This class uses the Forge event bus to register spawn restrictions.
 * NOTE: This class is registered to the event bus in the main Forge entrypoint.
 */
public class ModSpawnPlacementsImpl {

    private static final List<SpawnPlacementData<?>> PENDING_PLACEMENTS = new ArrayList<>();

    /**
     * Caches the spawn placement data passed from the common module via the @ExpectPlatform bridge.
     */
    public static <T extends MobEntity> void register(EntityType<T> entityType, SpawnRestriction.Location location, Heightmap.Type heightmapType, SpawnRestriction.SpawnPredicate<T> predicate) {
        PENDING_PLACEMENTS.add(new SpawnPlacementData<>(entityType, location, heightmapType, predicate));
    }

    /**
     * Listens for the Forge event and registers all cached spawn placements.
     * This method is static and is automatically called by Forge because its class is registered to the event bus.
     * @param event The event fired by Forge for registering spawn placements.
     */
    @SubscribeEvent
    public static void onRegisterSpawnPlacements(SpawnPlacementRegisterEvent event) {
        for (SpawnPlacementData<?> data : PENDING_PLACEMENTS) {
            data.register(event);
        }
        PENDING_PLACEMENTS.clear();
    }

    /**
     * A helper record to store the parameters for a single spawn placement registration.
     */
    private record SpawnPlacementData<T extends MobEntity>(
            EntityType<T> entityType,
            SpawnRestriction.Location location,
            Heightmap.Type heightmapType,
            SpawnRestriction.SpawnPredicate<T> predicate
    ) {
        /**
         * Registers the cached data to the event.
         * @param event The spawn placement registration event.
         */
        void register(SpawnPlacementRegisterEvent event) {
            event.register(this.entityType, this.location, this.heightmapType, this.predicate, SpawnPlacementRegisterEvent.Operation.REPLACE);
        }
    }
}
```

`ModWorldGenerationImpl.java`
```java
package net.dawson.adorablehamsterpets.world.forge;

public class ModWorldGenerationImpl {
    public static void registerBiomeModifications() {
        // This is intentionally empty.
        // Forge handles biome modifications through data-driven biome_modifiers.
    }
}
```

### 📂 `forge/src/main/java/net/dawson/adorablehamsterpets/forge/client/`
`AdorableHamsterPetsForgeClient.java`
```java
package net.dawson.adorablehamsterpets.forge.client;

// (Imports omitted to save token count)

/**
 * Forge-only client initialisation.
 * All class names use Yarn mappings (1.20.1 build 10).
 */
@OnlyIn(Dist.CLIENT)
@Mod.EventBusSubscriber(
        modid = AdorableHamsterPets.MOD_ID,
        bus = Mod.EventBusSubscriber.Bus.MOD,
        value = Dist.CLIENT
)
public final class AdorableHamsterPetsForgeClient {

    private AdorableHamsterPetsForgeClient() {}

    /* ------------------------------------------------------------ */
    /* Client setup                                                 */
    /* ------------------------------------------------------------ */

    @SubscribeEvent
    public static void onClientSetup(FMLClientSetupEvent event) {
        // General Architectury/fabric-style init that must run on the main thread.
        event.enqueueWork(AdorableHamsterPetsClient::init);

        // Register the hamster-inventory screen with its ScreenHandler type.
        event.enqueueWork(() ->
                HandledScreens.register(
                        ModScreenHandlers.HAMSTER_INVENTORY_SCREEN_HANDLER.get(),
                        HamsterInventoryScreen::new
                )
        );
    }

    @SubscribeEvent
    public static void onRegisterParticleProviders(RegisterParticleProvidersEvent event) {
        // Register particle factory for all variants.
        // On 1.20.1, use DefaultParticleType
        for (RegistrySupplier<DefaultParticleType> particleSupplier : ModParticles.BEDDING_PARTICLES.values()) {
            event.registerSpriteSet(particleSupplier.get(), HamsterBeddingParticle.Factory::new);
        }
    }

    @SubscribeEvent
    public static void onRegisterKeyMappings(RegisterKeyMappingsEvent event) {
        // Construct the key mapping objects if they haven’t been created yet.
        if (ModKeyBindings.THROW_HAMSTER_KEY == null) {
            ModKeyBindings.init();
        }
        // Manually register the keys with Forge's event.
        event.register(ModKeyBindings.THROW_HAMSTER_KEY);
        event.register(ModKeyBindings.DISMOUNT_HAMSTER_KEY);
    }

    /* ------------------------------------------------------------ */
    /* Renderer & layer registrations                               */
    /* ------------------------------------------------------------ */

    @SubscribeEvent
    public static void onRegisterRenderers(EntityRenderersEvent.RegisterRenderers event) {
        event.registerEntityRenderer(ModEntities.HAMSTER.get(), HamsterRenderer::new);
    }

    @SubscribeEvent
    public static void onRegisterBlockEntityRenderers(EntityRenderersEvent.RegisterRenderers event) {
        event.registerBlockEntityRenderer(ModBlockEntities.HAMSTER_BED_BLOCK_ENTITY.get(), HamsterBedRenderer::new);
    }

    /**
     * Add the shoulder-hamster feature to both vanilla player models.
     * Vanilla (and thus Forge) identify them with the keys
     * {@code "default"} (Steve) and {@code "slim"} (Alex).
     */
    @SubscribeEvent
    public static void onAddLayers(EntityRenderersEvent.AddLayers event) {
        // Steve
        PlayerEntityRenderer steveRenderer = event.getSkin("default");
        if (steveRenderer != null) {
            steveRenderer.addFeature(new HamsterShoulderFeatureRenderer(steveRenderer));
        }

        // Alex
        PlayerEntityRenderer alexRenderer = event.getSkin("slim");
        if (alexRenderer != null) {
            alexRenderer.addFeature(new HamsterShoulderFeatureRenderer(alexRenderer));
        }
    }
}
```

### 📂 `forge/src/main/java/net/dawson/adorablehamsterpets/forge/`
`AdorableHamsterPetsForge.java`
```java
package net.dawson.adorablehamsterpets.forge;

// (Imports omitted to save token count)

@Mod(AdorableHamsterPets.MOD_ID)
public final class AdorableHamsterPetsForge {

    public AdorableHamsterPetsForge() {
        IEventBus modEventBus = FMLJavaModLoadingContext.get().getModEventBus();

        // Submit event bus to let architectury handle its own registrations.
        EventBuses.registerModEventBus(AdorableHamsterPets.MOD_ID, modEventBus);

        // Register all items, blocks, etc.
        AdorableHamsterPets.initRegistries();
        ModBiomeModifiers.register(modEventBus);

        // Register event listeners for the mod lifecycle
        modEventBus.addListener(this::onCommonSetup);
        modEventBus.addListener(this::onAttributeCreate); // listener for attributes
        modEventBus.register(ModSpawnPlacementsImpl.class);

        if (FMLEnvironment.dist == Dist.CLIENT) {
            modEventBus.register(AdorableHamsterPetsForgeClient.class);
        }
    }

    private void onCommonSetup(final FMLCommonSetupEvent event) {
        // initCommonSetup is correct here.
        event.enqueueWork(AdorableHamsterPets::initCommonSetup);
    }

    // This handles the attribute creation event at the correct time.
    private void onAttributeCreate(final EntityAttributeCreationEvent event) {
        event.put(ModEntities.HAMSTER.get(), HamsterEntity.createHamsterAttributes().build());
    }
}
```

### 📂 `forge/src/main/resources/META-INF/`
`mods.toml`
```toml
modLoader = "javafml"
loaderVersion = "[47,)"
license = "All Rights Reserved"
issueTrackerURL = "https://github.com/DawsonBodenhamer/AdorableHamsterPets-Public/issues"

[[mods]]
modId = "adorablehamsterpets"
version = "${version}"
displayName = "Adorable Hamster Pets"
authors = "The Scarlet Fox"
description = '''
Sure, you’ve got dragons and machines, but let’s be honest— no respectable mod pack is complete without tiny fluffy hamsters running around.
'''
logoFile = "assets/adorablehamsterpets/icon.png"

[entryPoints]
main = "net.dawson.adorablehamsterpets.forge.AdorableHamsterPetsForge"

[[dependencies.adorablehamsterpets]]
modId="forge"
mandatory=true
versionRange="[47,)"
ordering="NONE"
side="BOTH"

[[dependencies.adorablehamsterpets]]
modId="minecraft"
mandatory=true
versionRange="[1.20.1,)"
ordering="NONE"
side="BOTH"

[[dependencies.adorablehamsterpets]]
modId="architectury"
mandatory=true
versionRange="[9.2.14,)"
ordering="AFTER"
side="BOTH"

[[dependencies.adorablehamsterpets]]
modId="geckolib"
mandatory=true
versionRange="[4.4.9,)"
ordering="NONE"
side="BOTH"

[[dependencies.adorablehamsterpets]]
modId="fzzy_config"
mandatory=true
versionRange="[0.7.3,)"
ordering="NONE"
side="BOTH"

[[dependencies.adorablehamsterpets]]
modId="patchouli"
mandatory=true
versionRange = "[1.20.1-84.1-FORGE,)"
ordering="NONE"
side="BOTH"

[[dependencies.adorablehamsterpets]]
modId="jade"
mandatory=false
versionRange="[11.7.0,)"
ordering="NONE"
side="BOTH"

[[mixins]]
config = "adorablehamsterpets.mixins.json"
```

### 📂 `forge/src/main/resources/data/adorablehamsterpets/forge/biome_modifier/`
`add_sunflowers.json`
```json
{
  "type": "adorablehamsterpets:configurable_feature_modifier",
  "biomes": "#minecraft:is_overworld",
  "features_to_remove": [
    "minecraft:patch_sunflower"
  ],
  "features_to_add": [
    "adorablehamsterpets:custom_sunflower_placed"
  ]
}
```

`add_wild_cucumber_bush.json`
```json
{
  "type": "adorablehamsterpets:configurable_feature_modifier",
  "biomes": "#minecraft:is_overworld",
  "features_to_add": [
    "adorablehamsterpets:wild_cucumber_bush_placed"
  ]
}
```

`add_wild_green_bean_bush.json`
```json
{
  "type": "adorablehamsterpets:configurable_feature_modifier",
  "biomes": "#minecraft:is_overworld",
  "features_to_add": [
    "adorablehamsterpets:wild_green_bean_bush_placed"
  ]
}
```

`hamster_spawns.json`
```json
{
  "type": "adorablehamsterpets:configurable_hamster_spawns"
}
```

### 📂 `.github/workflows/`
`publish.yml`
```yaml
name: Build & Publish Mod

# PURPOSE:
# Builds both Fabric/Quilt and Forge jars and publishes them to Modrinth and CurseForge.
# TRIGGER:
# - Automatically runs when a lightweight tag like "v3.1.0" is pushed.
# - Can also be run manually via the "Run workflow" button (workflow_dispatch).
#
# NOTE:
# - This file is for 1.20.x line. For 1.21.1, an alternate version of this file exists.
# - Do NOT put comments inside the dependency lists (the lines after a "|"), as they are literal blocks.

on:
  push:
    tags:
      - "v*"
  workflow_dispatch: {}

jobs:
  publish:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    # Capture the raw tag name, e.g. "v3.1.0" as an environment variable for extraction
    env:
      VERSION: ${{ github.ref_name }}
    steps:
      # 1) Get source at the tagged commit
      - name: Check out code
        uses: actions/checkout@v4

      # 2) Java toolchain for Gradle/loom
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'
          cache: gradle

      # 3) Build both subprojects (fabric, forge). Output jars end up under each module's build/libs
      - name: Build jars
        run: |
          chmod +x ./gradlew
          ./gradlew clean build

      # 4) Strip the leading "v" to reuse the numeric version in file names & labels
      - name: Derive version without leading v
        id: vars
        run: |
          V="${VERSION#v}"
          echo "V=$V" >> $GITHUB_OUTPUT

      # 5) Pull the public changelog (kept in a separate repo) into the workspace
      - name: Download CHANGELOG.md from public repo
        run: |
          curl -fL "https://raw.githubusercontent.com/DawsonBodenhamer/AdorableHamsterPets-Source/develop/CHANGELOG.md" -o CHANGELOG.md

      # 6) Extract only the section for this tag from the changelog
      #    Logic:
      #    - Find "## [<version>] ..." line
      #    - Capture everything after it until the next line that is exactly "---"
      #    - Be tolerant of leading spaces on headings/separators and trim them in output
      - name: Extract changelog for this version
        shell: bash
        run: |
          # Strip the leading 'v' from the tag if present
          V="${VERSION#v}"
  
          # Grab everything after '## [<version>]' until the next '---' separator
          # Match headings/separators with optional leading spaces and trim leading spaces.
          awk -v ver="$V" '
            $0 ~ "^[[:space:]]*## \\[" ver "\\]" {p=1; next}
            p && /^[[:space:]]*---/ {exit}
            p {
              print
            }
          ' CHANGELOG.md > release_changelog.md

          echo "Extracted changelog for version $V:"
          sed -n '1,120p' release_changelog.md

      # 7) Publish Fabric/Quilt build to Modrinth & CurseForge
      #    - Uses exact jar path produced by the build (keeps naming scheme intact)
      #    - Attaches dependencies per platform
      #    - Attaches extracted changelog snippet
      - name: Publish Fabric/Quilt version
        uses: Kir-Antipov/mc-publish@v3.3
        with:

          # Project identifiers and API tokens
          modrinth-id: LmrhZdK2
          modrinth-token: ${{ secrets.MODRINTH_TOKEN }}
          curseforge-id: 1306061
          curseforge-token: ${{ secrets.CURSEFORGE_TOKEN }}

          # Human-visible version name for Modrinth/CurseForge
          version: ${{ steps.vars.outputs.V }}-1.20.1+fabric
          version-type: beta

          # EXACT jar  file path + name produced by Gradle build (fabric module)
          files: fabric/build/libs/adorablehamsterpets-${{ steps.vars.outputs.V }}-1.20.1+fabric.jar

          # Fabric/Quilt dependency slugs for Modrinth (no comments allowed inside the block)
          modrinth-dependencies: |
            fabric-api(required)
            architectury-api(required)
            geckolib(required)
            fzzy-config(required)
            fabric-language-kotlin(required)
            modmenu(optional)
            patchouli(required)
            jade(optional)

          # Fabric/Quilt dependency IDs For CurseForge (no comments allowed inside the block)
          curseforge-dependencies: |
            306612(required)
            419699(required)
            388172(required)
            1005914(required)
            308769(required)
            308702(optional)
            393236(required)
            324717(optional)

          # Attach the changelog snippet that was extracted above
          changelog-file: release_changelog.md

          # Mark as Fabric & Quilt, and target the correct MC version
          loaders: |
            fabric
            quilt
          game-versions: 1.20.1

      # 8) Publish Forge build to Modrinth & CurseForge
      #    - Same approach as Fabric, but with Forge jar and its dependencies
      - name: Publish Forge version
        uses: Kir-Antipov/mc-publish@v3.3
        with:

          # Project identifiers and API tokens
          modrinth-id: LmrhZdK2
          modrinth-token: ${{ secrets.MODRINTH_TOKEN }}
          curseforge-id: 1306061
          curseforge-token: ${{ secrets.CURSEFORGE_TOKEN }}

          # Human-visible version name for Modrinth/CurseForge
          version: ${{ steps.vars.outputs.V }}-1.20.1+forge
          version-type: beta

          # EXACT jar file path + name produced by Gradle build (forge module)
          files: forge/build/libs/adorablehamsterpets-${{ steps.vars.outputs.V }}-1.20.1+forge.jar

          # Forge dependency slugs for Modrinth (no comments allowed inside the block)
          modrinth-dependencies: |
            architectury-api(required)
            geckolib(required)
            fzzy-config(required)
            kotlin-for-forge(required)
            patchouli(required)
            jade(optional)

          # Forge dependency IDs for CurseForge (no comments allowed inside the block)
          curseforge-dependencies: |
            419699(required)
            388172(required)
            1005914(required)
            351264(required)
            306770(required)
            324717(optional)

          # Attach the changelog snippet that was extracted above
          changelog-file: release_changelog.md

          # Mark as Forge and target the correct MC version
          loaders: forge
          game-versions: 1.20.1
```

End AHP Provided Code

---

Let’s begin.