# Technical Specification: Chunk Party Spreader

**Target Platform:** Minecraft 1.20.1 (Forge)
**Recommended Forge Version:** 47.1.3+ (Targeting 47.4.13)
**Mod ID:** `chunkpartyspreader` (Proposed)
**Dependencies:** `chunkbychunk` (Required for generation command)

---

## 1. Architectural Overview

The **Chunk Party Spreader** is a server-side utility mod designed to manage the distribution of players in a "Void World" scenario. It functions as a state machine that tracks the number of unique joins and assigns each new player a coordinate based on a growing square spiral pattern.

It intercepts player joins and respawns to enforce specific geographic rules, ensuring players are spaced out, land in valid biomes, and have their assigned chunk pre-generated by the *Chunk By Chunk* mod before arrival.

---

## 2. Core Data Structures & Persistence

To ensure the "Spiral Index" and player assignments survive server restarts and crashes, the mod will utilize Forge's standard `SavedData` system attached to the Overworld (`Level.OVERWORLD`).

### 2.1. Class: `SpreaderWorldData`
Extends `net.minecraft.world.level.saveddata.SavedData`.

**Fields:**
*   `private int currentSpiralIndex`: Tracks the global counter for the next available slot in the spiral. Defaults to `0` (or `1`).
*   `private Map<UUID, BlockPos> playerAssignments`: A persistent map linking a Player's UUID to their specific assigned "Home Chunk" center block.

**Methods:**
*   `save(CompoundTag tag)`: Serializes the index and the UUID map to NBT.
*   `load(CompoundTag tag)`: Deserializes the NBT back into memory.
*   `get(ServerLevel level)`: Static helper to retrieve or create the data from `DimensionDataStorage`.

**NBT Structure:**
```json
{
  "SpiralIndex": 5,
  "Assignments": [
    { "UUID": "c06f8906-...", "X": 100, "Y": 70, "Z": 100 },
    { "UUID": "...", "X": -400, "Y": 70, "Z": 100 }
  ]
}
```

---

## 3. Configuration (`chunkpartyspreader-common.toml`)

Using standard Forge Config.

*   `grid_spacing_chunks` (Integer, Default: `25`): The distance between spiral points in chunks. (25 chunks * 16 blocks = 400 blocks).
*   `skip_oceans` (Boolean, Default: `true`): If true, the algorithm discards coordinates that land in an Ocean biome and increments to the next index.
*   `generation_command` (String, Default: `/chunkbychunk:spawnChunk %d %d`): The command to execute. `%d` placeholders used for ChunkX and ChunkZ.
*   `center_offset_x` (Integer, Default: `0`): The X coordinate (in chunks) for the center of the spiral.
*   `center_offset_z` (Integer, Default: `0`): The Z coordinate (in chunks) for the center of the spiral.

---

## 4. Algorithms & Logic Flow

### 4.1. The Spiral Algorithm (Ulam Variation)
A utility class `SpiralCalculator` will handle the math.
*   **Input:** `index` (int).
*   **Output:** `ChunkPos` (x, z).
*   **Logic:**
    1.  Convert `index` to a coordinate on a unit grid (1, 2, 3...) moving Right, Down, Left, Up.
    2.  Multiply unit coordinates by `grid_spacing_chunks`.
    3.  Add `center_offset`.

### 4.2. Biome Validation (Ocean Skipping)
Before assigning a spot:
1.  Calculate target `ChunkPos` from the Spiral Algorithm.
2.  Convert to world `BlockPos` (center of chunk): `x = chunkX * 16 + 8`, `z = chunkZ * 16 + 8`.
3.  Query `ServerLevel.getBiome(pos)`.
4.  Check `biome.is(BiomeTags.IS_OCEAN)` (and potentially `IS_DEEP_OCEAN`).
5.  **If Ocean:** Increment `currentSpiralIndex`, `markDirty()`, and recurse/loop to the next index.
6.  **If Safe:** Lock this index, save data, and proceed to generation.

### 4.3. The First-Join Workflow
**Event:** `PlayerEvent.PlayerLoggedInEvent`

1.  **Check Data:** Query `SpreaderWorldData`. Does `playerAssignments` contain the player's UUID?
    *   **Yes:** Do nothing (or optional: check if they are in the void and rescue them).
    *   **No:** Proceed to Assignment Logic.
2.  **Assignment Logic:**
    *   Teleport player to `0, 300, 0` (High Y, Creative Flight/Invulnerability buffer) to prevent instant void death during calculation.
    *   Run **Spiral Algorithm** + **Biome Validation** loop to find `targetChunkPos`.
    *   Store UUID -> Pos mapping in `SpreaderWorldData`.
    *   Update `currentSpiralIndex`.
    *   Call `setDirty()`.
3.  **Generation:**
    *   Construct command string: `String.format(config.generationCommand, targetChunkPos.x, targetChunkPos.z)`.
    *   Execute via `server.getCommands().performPrefixedCommand(source, cmd)`.
4.  **Teleportation:**
    *   Calculate surface Y: `level.getHeight(Types.WORLD_SURFACE, targetX, targetZ)`.
    *   Teleport player to `targetX, surfaceY + 1, targetZ`.
    *   Set Respawn Point: `player.setRespawnPosition(level.dimension(), pos, angle, true, false)`.

### 4.4. The Respawn Fallback Workflow
**Event:** `PlayerEvent.PlayerRespawnEvent`

1.  Check `event.isEndConquered()`. If true, ignore.
2.  Check if player has a valid bed/anchor (`!player.isBedSpawn()`).
3.  **Logic:**
    *   If the player *does not* have a valid bed (meaning they are defaulting to World Spawn), intercept.
    *   Lookup UUID in `SpreaderWorldData`.
    *   If record exists: Overwrite event respawn location to their stored `Home Chunk` coordinates.

---

## 5. Implementation Steps (Developer Checklist)

1.  **Project Setup:**
    *   Initialize Forge MDK 1.20.1 - 47.x.
    *   Adjust `mods.toml` to define dependency on `chunkbychunk` (ordering: AFTER).

2.  **Data Layer:**
    *   Implement `SpreaderWorldData`.
    *   Register event handler for `LevelEvent.Save` (though `setDirty` usually handles this auto-magically in 1.20, verify explicit save hooks).

3.  **Math Layer:**
    *   Write `SpiralCalculator` unit test (Java main class) to verify the spiral output sequences (0,0 -> 1,0 -> 1,1 -> 0,1 -> -1,1 etc) before putting it in the game.

4.  **Logic Integration:**
    *   Implement `PlayerLoggedInEvent`.
    *   Implement command execution wrapper.
    *   Implement `PlayerRespawnEvent`.

5.  **Testing Strategy:**
    *   **Test 1 (Void Safety):** Join world. Ensure player floats/waits while command runs.
    *   **Test 2 (Persistence):** Join 2 players. Stop Server. Start Server. Join 3rd player. Ensure 3rd player does not overwrite Player 1 or 2.
    *   **Test 3 (Ocean):** Set config `grid_spacing` to 1. Force logic to run over an ocean seed. Verify indices skip correctly.
    *   **Test 4 (Respawn):** Break bed. `/kill`. Verify respawn at assigned chunk, not 0,0.

---

## 6. Potential Edge Cases & Mitigations

*   **Chunk By Chunk Missing:**
    *   *Mitigation:* Check `ModList.get().isLoaded("chunkbychunk")`. If false, log a generic error "Mod missing" and disable the generation command (teleport only).
*   **Generation Lag:**
    *   *Mitigation:* The `performPrefixedCommand` is synchronous. The server will likely hang for 50-200ms while generating the chunk. This is acceptable for a join event.
*   **Spawn Block Obstructed:**
    *   *Mitigation:* When calculating Surface Y, ensure the target block isn't leaves or logs (if spawning in a jungle). If obstructed, add to Y until air is found.

---

# Project Files

## CPS Provided Code

End CPS Provided Code

---